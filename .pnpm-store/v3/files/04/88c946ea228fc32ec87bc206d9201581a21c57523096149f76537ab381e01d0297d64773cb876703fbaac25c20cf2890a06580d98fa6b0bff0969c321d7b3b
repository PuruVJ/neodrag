{"version":3,"file":"abbreviation.es.js","sources":["../src/parser/TokenScanner.ts","../src/parser/index.ts","../src/tokenizer/utils.ts","../src/tokenizer/index.ts","../src/stringify.ts","../src/convert.ts","../src/index.ts"],"sourcesContent":["import { AllTokens } from '../tokenizer';\n\nexport interface TokenScanner {\n    tokens: AllTokens[];\n    start: number;\n    pos: number;\n    size: number;\n}\n\ntype TestFn = (token?: AllTokens) => boolean;\n\nexport default function tokenScanner(tokens: AllTokens[]): TokenScanner {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\n\nexport function peek(scanner: TokenScanner): AllTokens | undefined {\n    return scanner.tokens[scanner.pos];\n}\n\nexport function next(scanner: TokenScanner): AllTokens | undefined {\n    return scanner.tokens[scanner.pos++];\n}\n\nexport function slice(scanner: TokenScanner, from = scanner.start, to = scanner.pos): AllTokens[] {\n    return scanner.tokens.slice(from, to);\n}\n\nexport function readable(scanner: TokenScanner): boolean {\n    return scanner.pos < scanner.size;\n}\n\nexport function consume(scanner: TokenScanner, test: TestFn): boolean {\n    const token = peek(scanner);\n    if (token && test(token)) {\n        scanner.pos++;\n        return true;\n    }\n\n    return false;\n}\n\nexport function error(scanner: TokenScanner, message: string, token = peek(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n\n    return err;\n}\n\nexport function consumeWhile(scanner: TokenScanner, test: TestFn): boolean {\n    const start = scanner.pos;\n    while (consume(scanner, test)) { /* */ }\n    return scanner.pos !== start;\n}\n","import { NameToken, ValueToken, Repeater, AllTokens, BracketType, Bracket, Operator, OperatorType, Quote, WhiteSpace, Literal } from '../tokenizer';\nimport tokenScanner, { TokenScanner, peek, consume, readable, next, error, slice } from './TokenScanner';\nimport { ParserOptions } from '../types';\n\nexport type TokenStatement = TokenElement | TokenGroup;\n\nexport interface TokenAttribute {\n    name?: ValueToken[];\n    value?: ValueToken[];\n    expression?: boolean;\n}\n\nexport interface TokenElement {\n    type: 'TokenElement';\n    name?: NameToken[];\n    attributes?: TokenAttribute[];\n    value?: ValueToken[];\n    repeat?: Repeater;\n    selfClose: boolean;\n    elements: TokenStatement[];\n}\n\nexport interface TokenGroup {\n    type: 'TokenGroup';\n    elements: TokenStatement[];\n    repeat?: Repeater;\n}\n\nexport default function abbreviation(abbr: AllTokens[], options: ParserOptions = {}): TokenGroup {\n    const scanner = tokenScanner(abbr);\n    const result = statements(scanner, options);\n    if (readable(scanner)) {\n        throw error(scanner, 'Unexpected character');\n    }\n\n    return result;\n}\n\nfunction statements(scanner: TokenScanner, options: ParserOptions): TokenGroup {\n    const result: TokenGroup = {\n        type: 'TokenGroup',\n        elements: []\n    };\n\n    let ctx: TokenStatement = result;\n    let node: TokenStatement | undefined;\n    const stack: TokenStatement[] = [];\n\n    while (readable(scanner)) {\n        if (node = element(scanner, options) || group(scanner, options)) {\n            ctx.elements.push(node);\n            if (consume(scanner, isChildOperator)) {\n                stack.push(ctx);\n                ctx = node;\n            } else if (consume(scanner, isSiblingOperator)) {\n                continue;\n            } else if (consume(scanner, isClimbOperator)) {\n                do {\n                    if (stack.length) {\n                        ctx = stack.pop()!;\n                    }\n                } while (consume(scanner, isClimbOperator));\n            }\n        } else {\n            break;\n        }\n    }\n\n    return result;\n}\n\n/**\n * Consumes group from given scanner\n */\nfunction group(scanner: TokenScanner, options: ParserOptions): TokenGroup | undefined {\n    if (consume(scanner, isGroupStart)) {\n        const result = statements(scanner, options);\n        const token = next(scanner);\n        if (isBracket(token, 'group', false)) {\n            result.repeat = repeater(scanner);\n        }\n        return result;\n    }\n}\n\n/**\n * Consumes single element from given scanner\n */\nfunction element(scanner: TokenScanner, options: ParserOptions): TokenElement | undefined {\n    let attr: TokenAttribute | TokenAttribute[] | undefined;\n    const elem: TokenElement = {\n        type: 'TokenElement',\n        name: void 0,\n        attributes: void 0,\n        value: void 0,\n        repeat: void 0,\n        selfClose: false,\n        elements: []\n    };\n\n    if (elementName(scanner, options)) {\n        elem.name = slice(scanner) as NameToken[];\n    }\n\n    while (readable(scanner)) {\n        scanner.start = scanner.pos;\n        if (!elem.repeat && !isEmpty(elem) && consume(scanner, isRepeater)) {\n            elem.repeat = scanner.tokens[scanner.pos - 1] as Repeater;\n        } else if (!elem.value && text(scanner)) {\n            elem.value = getText(scanner);\n        } else if (attr = shortAttribute(scanner, 'id', options) || shortAttribute(scanner, 'class', options) || attributeSet(scanner)) {\n            if (!elem.attributes) {\n                elem.attributes = Array.isArray(attr) ? attr.slice() : [attr];\n            } else {\n                elem.attributes = elem.attributes.concat(attr);\n            }\n        } else {\n            if (!isEmpty(elem) && consume(scanner, isCloseOperator)) {\n                elem.selfClose = true;\n                if (!elem.repeat && consume(scanner, isRepeater)) {\n                    elem.repeat = scanner.tokens[scanner.pos - 1] as Repeater;\n                }\n            }\n            break;\n        }\n    }\n\n    return !isEmpty(elem) ? elem : void 0;\n}\n\n/**\n * Consumes attribute set from given scanner\n */\nfunction attributeSet(scanner: TokenScanner): TokenAttribute[] | undefined {\n    if (consume(scanner, isAttributeSetStart)) {\n        const attributes: TokenAttribute[] = [];\n        let attr: TokenAttribute | undefined;\n\n        while (readable(scanner)) {\n            if (attr = attribute(scanner)) {\n                attributes.push(attr);\n            } else if (consume(scanner, isAttributeSetEnd)) {\n                break;\n            } else if (!consume(scanner, isWhiteSpace)) {\n                throw error(scanner, `Unexpected \"${peek(scanner)!.type}\" token`);\n            }\n        }\n\n        return attributes;\n    }\n}\n\n/**\n * Consumes attribute shorthand (class or id) from given scanner\n */\nfunction shortAttribute(scanner: TokenScanner, type: 'class' | 'id', options: ParserOptions): TokenAttribute | undefined {\n    if (isOperator(peek(scanner), type)) {\n        scanner.pos++;\n        const attr: TokenAttribute = {\n            name: [createLiteral(type)]\n        };\n\n        // Consume expression after shorthand start for React-like components\n        if (options.jsx && text(scanner)) {\n            attr.value = getText(scanner);\n            attr.expression = true;\n        } else {\n            attr.value = literal(scanner) ? slice(scanner) as ValueToken[] : void 0;\n        }\n\n        return attr;\n    }\n}\n\n/**\n * Consumes single attribute from given scanner\n */\nfunction attribute(scanner: TokenScanner): TokenAttribute | undefined {\n    if (quoted(scanner)) {\n        // Consumed quoted value: it’s a value for default attribute\n        return {\n            value: slice(scanner) as ValueToken[]\n        };\n    }\n\n    if (literal(scanner, true)) {\n        return {\n            name: slice(scanner) as NameToken[],\n            value: consume(scanner, isEquals) && (quoted(scanner) || literal(scanner, true))\n                ? slice(scanner) as ValueToken[]\n                : void 0\n        };\n    }\n}\n\nfunction repeater(scanner: TokenScanner): Repeater | undefined {\n    return isRepeater(peek(scanner))\n        ? scanner.tokens[scanner.pos++] as Repeater\n        : void 0;\n}\n\n/**\n * Consumes quoted value from given scanner, if possible\n */\nfunction quoted(scanner: TokenScanner): boolean {\n    const start = scanner.pos;\n    const quote = peek(scanner);\n    if (isQuote(quote)) {\n        scanner.pos++;\n        while (readable(scanner)) {\n            if (isQuote(next(scanner), quote.single)) {\n                scanner.start = start;\n                return true;\n            }\n        }\n\n        throw error(scanner, 'Unclosed quote', quote);\n    }\n\n    return false;\n}\n\n/**\n * Consumes literal (unquoted value) from given scanner\n */\nfunction literal(scanner: TokenScanner, allowBrackets?: boolean): boolean {\n    const start = scanner.pos;\n    const brackets: { [type in BracketType]: number } = {\n        attribute: 0,\n        expression: 0,\n        group: 0\n    };\n\n    while (readable(scanner)) {\n        const token = peek(scanner);\n        if (brackets.expression) {\n            // If we’re inside expression, we should consume all content in it\n            if (isBracket(token, 'expression')) {\n                brackets[token.context] += token.open ? 1 : -1;\n            }\n        } else if (isQuote(token) || isOperator(token) || isWhiteSpace(token) || isRepeater(token)) {\n            break;\n        } else if (isBracket(token)) {\n            if (!allowBrackets) {\n                break;\n            }\n\n            if (token.open) {\n                brackets[token.context]++;\n            } else if (!brackets[token.context]) {\n                // Stop if found unmatched closing brace: it must be handled\n                // by parent consumer\n                break;\n            } else {\n                brackets[token.context]--;\n            }\n        }\n\n        scanner.pos++;\n    }\n\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Consumes element name from given scanner\n */\nfunction elementName(scanner: TokenScanner, options: ParserOptions): boolean {\n    const start = scanner.pos;\n\n    if (options.jsx && consume(scanner, isCapitalizedLiteral)) {\n        // Check for edge case: consume immediate capitalized class names\n        // for React-like components, e.g. `Foo.Bar.Baz`\n        while (readable(scanner)) {\n            const { pos } = scanner;\n            if (!consume(scanner, isClassNameOperator) || !consume(scanner, isCapitalizedLiteral)) {\n                scanner.pos = pos;\n                break;\n            }\n        }\n    }\n\n    while (readable(scanner) && consume(scanner, isElementName)) {\n        // empty\n    }\n\n    if (scanner.pos !== start) {\n        scanner.start = start;\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Consumes text value from given scanner\n */\nfunction text(scanner: TokenScanner): boolean {\n    const start = scanner.pos;\n    if (consume(scanner, isTextStart)) {\n        let brackets = 0;\n        while (readable(scanner)) {\n            const token = next(scanner);\n            if (isBracket(token, 'expression')) {\n                if (token.open) {\n                    brackets++;\n                } else if (!brackets) {\n                    break;\n                } else {\n                    brackets--;\n                }\n            }\n        }\n\n        scanner.start = start;\n        return true;\n    }\n\n    return false;\n}\n\nfunction getText(scanner: TokenScanner): ValueToken[] {\n    let from = scanner.start;\n    let to = scanner.pos;\n    if (isBracket(scanner.tokens[from], 'expression', true)) {\n        from++;\n    }\n\n    if (isBracket(scanner.tokens[to - 1], 'expression', false)) {\n        to--;\n    }\n\n    return slice(scanner, from, to) as ValueToken[];\n}\n\nexport function isBracket(token: AllTokens | undefined, context?: BracketType, isOpen?: boolean): token is Bracket {\n    return Boolean(token && token.type === 'Bracket'\n        && (!context || token.context === context)\n        && (isOpen == null || token.open === isOpen));\n}\n\nexport function isOperator(token: AllTokens | undefined, type?: OperatorType): token is Operator {\n    return Boolean(token && token.type === 'Operator' && (!type || token.operator === type));\n}\n\nexport function isQuote(token: AllTokens | undefined, isSingle?: boolean): token is Quote {\n    return Boolean(token && token.type === 'Quote' && (isSingle == null || token.single === isSingle));\n}\n\nfunction isWhiteSpace(token?: AllTokens): token is WhiteSpace {\n    return Boolean(token && token.type === 'WhiteSpace');\n}\n\nfunction isEquals(token: AllTokens) {\n    return isOperator(token, 'equal');\n}\n\nfunction isRepeater(token?: AllTokens): token is Repeater {\n    return Boolean(token && token.type === 'Repeater');\n}\n\nfunction isLiteral(token: AllTokens): token is Literal {\n    return token.type === 'Literal';\n}\n\nfunction isCapitalizedLiteral(token: AllTokens) {\n    if (isLiteral(token)) {\n        const ch = token.value.charCodeAt(0);\n        return ch >= 65 && ch <= 90;\n    }\n    return false;\n}\n\nfunction isElementName(token: AllTokens): boolean {\n    return token.type === 'Literal' || token.type === 'RepeaterNumber' || token.type === 'RepeaterPlaceholder';\n}\n\nfunction isClassNameOperator(token: AllTokens) {\n    return isOperator(token, 'class');\n}\n\nfunction isAttributeSetStart(token?: AllTokens) {\n    return isBracket(token, 'attribute', true);\n}\n\nfunction isAttributeSetEnd(token?: AllTokens) {\n    return isBracket(token, 'attribute', false);\n}\n\nfunction isTextStart(token: AllTokens) {\n    return isBracket(token, 'expression', true);\n}\n\nfunction isGroupStart(token: AllTokens) {\n    return isBracket(token, 'group', true);\n}\n\nfunction createLiteral(value: string): Literal {\n    return { type: 'Literal', value };\n}\n\nfunction isEmpty(elem: TokenElement): boolean {\n    return !elem.name && !elem.value && !elem.attributes;\n}\n\nfunction isChildOperator(token: AllTokens) {\n    return isOperator(token, 'child');\n}\n\nfunction isSiblingOperator(token: AllTokens) {\n    return isOperator(token, 'sibling');\n}\n\nfunction isClimbOperator(token: AllTokens) {\n    return isOperator(token, 'climb');\n}\n\nfunction isCloseOperator(token: AllTokens) {\n    return isOperator(token, 'close');\n}\n","import Scanner from '@emmetio/scanner';\n\nexport const enum Chars {\n    /** `{` character */\n    CurlyBracketOpen = 123,\n\n    /** `}` character */\n    CurlyBracketClose = 125,\n\n    /** `\\\\` character */\n    Escape = 92,\n\n    /** `=` character */\n    Equals = 61,\n\n    /** `[` character */\n    SquareBracketOpen = 91,\n\n    /** `]` character */\n    SquareBracketClose = 93,\n\n    /** `*` character */\n    Asterisk = 42,\n\n    /** `#` character */\n    Hash = 35,\n\n    /** `$` character */\n    Dollar = 36,\n\n    /** `-` character */\n    Dash = 45,\n\n    /** `.` character */\n    Dot = 46,\n\n    /** `/` character */\n    Slash = 47,\n\n    /** `:` character */\n    Colon = 58,\n\n    /** `!` character */\n    Excl = 33,\n\n    /** `@` character */\n    At = 64,\n\n    /** `_` character */\n    Underscore = 95,\n\n    /** `(` character */\n    RoundBracketOpen = 40,\n\n    /** `)` character */\n    RoundBracketClose = 41,\n\n    /** `+` character */\n    Sibling = 43,\n\n    /** `>` character */\n    Child = 62,\n\n    /** `^` character */\n    Climb = 94,\n\n    /** `'` character */\n    SingleQuote = 39,\n\n    /** `\"\"` character */\n    DoubleQuote = 34,\n}\n\n/**\n * If consumes escape character, sets current stream range to escaped value\n */\nexport function escaped(scanner: Scanner): boolean {\n    if (scanner.eat(Chars.Escape)) {\n        scanner.start = scanner.pos;\n        if (!scanner.eof()) {\n            scanner.pos++;\n        }\n        return true;\n    }\n\n    return false;\n}\n","import Scanner, { isSpace, isQuote, isNumber, isAlpha, isAlphaNumericWord } from '@emmetio/scanner';\nimport { Literal, WhiteSpace, Quote, Bracket, BracketType, OperatorType, Operator, RepeaterPlaceholder, Repeater, Field, RepeaterNumber, AllTokens } from './tokens';\nimport { Chars, escaped } from './utils';\n\nexport * from './tokens';\n\ntype Context =  { [ctx in BracketType]: number } & { quote: number };\n\nexport default function tokenize(source: string): AllTokens[] {\n    const scanner = new Scanner(source);\n    const result: AllTokens[] = [];\n    const ctx: Context = {\n        group: 0,\n        attribute: 0,\n        expression: 0,\n        quote: 0\n    };\n\n    let ch = 0;\n    let token: AllTokens | undefined;\n\n    while (!scanner.eof()) {\n        ch = scanner.peek();\n        token = getToken(scanner, ctx);\n\n        if (token) {\n            result.push(token);\n            if (token.type === 'Quote') {\n                ctx.quote = ch === ctx.quote ? 0 : ch;\n            } else if (token.type === 'Bracket') {\n                ctx[token.context] += token.open ? 1 : -1;\n            }\n        } else {\n            throw scanner.error('Unexpected character');\n        }\n    }\n\n    return result;\n}\n\n/**\n * Returns next token from given scanner, if possible\n */\nexport function getToken(scanner: Scanner, ctx: Context): AllTokens | undefined {\n    return field(scanner, ctx)\n        || repeaterPlaceholder(scanner)\n        || repeaterNumber(scanner)\n        || repeater(scanner)\n        || whiteSpace(scanner)\n        || literal(scanner, ctx)\n        || operator(scanner)\n        || quote(scanner)\n        || bracket(scanner);\n}\n\n/**\n * Consumes literal from given scanner\n */\nfunction literal(scanner: Scanner, ctx: Context): Literal | undefined {\n    const start = scanner.pos;\n    let value = '';\n\n    while (!scanner.eof()) {\n        // Consume escaped sequence no matter of context\n        if (escaped(scanner)) {\n            value += scanner.current();\n            continue;\n        }\n\n        const ch = scanner.peek();\n\n        if (ch === ctx.quote || ch === Chars.Dollar || isAllowedOperator(ch, ctx)) {\n            // 1. Found matching quote\n            // 2. The `$` character has special meaning in every context\n            // 3. Depending on context, some characters should be treated as operators\n            break;\n        }\n\n        if (ctx.expression && ch === Chars.CurlyBracketClose) {\n            break;\n        }\n\n        if (!ctx.quote && !ctx.expression) {\n            // Consuming element name\n            if (!ctx.attribute && !isElementName(ch)) {\n                break;\n            }\n\n            if (isAllowedSpace(ch, ctx) || isAllowedRepeater(ch, ctx) || isQuote(ch) || bracketType(ch)) {\n                // Stop for characters not allowed in unquoted literal\n                break;\n            }\n        }\n\n\n        value += scanner.string[scanner.pos++];\n    }\n\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return {\n            type: 'Literal',\n            value,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner: Scanner): WhiteSpace | undefined {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos,\n            value: scanner.substring(start, scanner.pos)\n        };\n    }\n}\n\n/**\n * Consumes quote from given scanner\n */\nfunction quote(scanner: Scanner): Quote | undefined {\n    const ch = scanner.peek();\n    if (isQuote(ch)) {\n        return {\n            type: 'Quote',\n            single: ch === Chars.SingleQuote,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner: Scanner): Bracket | undefined {\n    const ch = scanner.peek();\n    const context = bracketType(ch);\n    if (context) {\n        return {\n            type: 'Bracket',\n            open: isOpenBracket(ch),\n            context,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner: Scanner): Operator | undefined {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n\n/**\n * Consumes node repeat token from current stream position and returns its\n * parsed value\n */\nfunction repeater(scanner: Scanner): Repeater | undefined {\n    const start = scanner.pos;\n    if (scanner.eat(Chars.Asterisk)) {\n        scanner.start = scanner.pos;\n        let count = 1;\n        let implicit = false;\n\n        if (scanner.eatWhile(isNumber)) {\n            count = Number(scanner.current());\n        } else {\n            implicit = true;\n        }\n\n        return {\n            type: 'Repeater',\n            count,\n            value: 0,\n            implicit,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n\n/**\n * Consumes repeater placeholder `$#` from given scanner\n */\nfunction repeaterPlaceholder(scanner: Scanner): RepeaterPlaceholder | undefined {\n    const start = scanner.pos;\n    if (scanner.eat(Chars.Dollar) && scanner.eat(Chars.Hash)) {\n        return {\n            type: 'RepeaterPlaceholder',\n            value: void 0,\n            start,\n            end: scanner.pos\n        };\n    }\n\n    scanner.pos = start;\n}\n\n/**\n * Consumes numbering token like `$` from given scanner state\n */\nfunction repeaterNumber(scanner: Scanner): RepeaterNumber | undefined {\n    const start = scanner.pos;\n    if (scanner.eatWhile(Chars.Dollar)) {\n        const size = scanner.pos - start;\n        let reverse = false;\n        let base = 1;\n        let parent = 0;\n\n        if (scanner.eat(Chars.At)) {\n            // Consume numbering modifiers\n            while (scanner.eat(Chars.Climb)) {\n                parent++;\n            }\n\n            reverse = scanner.eat(Chars.Dash);\n            scanner.start = scanner.pos;\n            if (scanner.eatWhile(isNumber)) {\n                base = Number(scanner.current());\n            }\n        }\n\n        scanner.start = start;\n\n        return {\n            type: 'RepeaterNumber',\n            size,\n            reverse,\n            base,\n            parent,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n\nfunction field(scanner: Scanner, ctx: Context): Field | undefined {\n    const start = scanner.pos;\n    // Fields are allowed inside expressions and attributes\n    if ((ctx.expression || ctx.attribute) && scanner.eat(Chars.Dollar) && scanner.eat(Chars.CurlyBracketOpen)) {\n        scanner.start = scanner.pos;\n\n        let index: number | undefined;\n        let name: string = '';\n\n        if (scanner.eatWhile(isNumber)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(Chars.Colon) ? consumePlaceholder(scanner) : '';\n        } else if (isAlpha(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder(scanner);\n        }\n\n        if (scanner.eat(Chars.CurlyBracketClose)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n\n        throw scanner.error('Expecting }');\n    }\n\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder(stream: Scanner): string {\n    const stack: number[] = [];\n    stream.start = stream.pos;\n\n    while (!stream.eof()) {\n        if (stream.eat(Chars.CurlyBracketOpen)) {\n            stack.push(stream.pos);\n        } else if (stream.eat(Chars.CurlyBracketClose)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        } else {\n            stream.pos++;\n        }\n    }\n\n    if (stack.length) {\n        stream.pos = stack.pop()!;\n        throw stream.error(`Expecting }`);\n    }\n\n    return stream.current();\n}\n\n/**\n * Check if given character code is an operator and it’s allowed in current context\n */\nfunction isAllowedOperator(ch: number, ctx: Context): boolean {\n    const op = operatorType(ch);\n    if (!op || ctx.quote || ctx.expression) {\n        // No operators inside quoted values or expressions\n        return false;\n    }\n\n    // Inside attributes, only `equals` is allowed\n    return !ctx.attribute || op === 'equal';\n}\n\n/**\n * Check if given character is a space character and is allowed to be consumed\n * as a space token in current context\n */\nfunction isAllowedSpace(ch: number, ctx: Context): boolean {\n    return isSpace(ch) && !ctx.expression;\n}\n\n/**\n * Check if given character can be consumed as repeater in current context\n */\nfunction isAllowedRepeater(ch: number, ctx: Context): boolean {\n    return ch === Chars.Asterisk && !ctx.attribute && !ctx.expression;\n}\n\n/**\n * If given character is a bracket, returns it’s type\n */\nfunction bracketType(ch: number): BracketType | undefined {\n    if (ch === Chars.RoundBracketOpen || ch === Chars.RoundBracketClose) {\n        return 'group';\n    }\n\n    if (ch === Chars.SquareBracketOpen || ch === Chars.SquareBracketClose) {\n        return 'attribute';\n    }\n\n    if (ch === Chars.CurlyBracketOpen || ch === Chars.CurlyBracketClose) {\n        return 'expression';\n    }\n}\n\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType(ch: number): OperatorType | undefined {\n    return (ch === Chars.Child && 'child')\n        || (ch === Chars.Sibling && 'sibling')\n        || (ch === Chars.Climb && 'climb')\n        || (ch === Chars.Dot && 'class')\n        || (ch === Chars.Hash && 'id')\n        || (ch === Chars.Slash && 'close')\n        || (ch === Chars.Equals && 'equal')\n        || void 0;\n}\n\n/**\n * Check if given character is an open bracket\n */\nfunction isOpenBracket(ch: number): boolean {\n    return ch === Chars.CurlyBracketOpen\n        || ch === Chars.SquareBracketOpen\n        || ch === Chars.RoundBracketOpen;\n}\n\n/**\n * Check if given character is allowed in element name\n */\nfunction isElementName(ch: number) {\n    return isAlphaNumericWord(ch)\n        || ch === Chars.Dash\n        || ch === Chars.Colon\n        || ch === Chars.Excl;\n}\n","import { Token, Literal, Bracket, Field, RepeaterPlaceholder, Repeater, RepeaterNumber, ValueToken, Quote, Operator, OperatorType, WhiteSpace } from './tokenizer/tokens';\nimport { ConvertState } from './types';\n\ntype TokenVisitor = (token: Token, state: ConvertState) => string;\n\nconst operators: { [key in OperatorType]: string } = {\n    child: '>',\n    class: '.',\n    climb: '^',\n    id: '#',\n    equal: '=',\n    close: '/',\n    sibling: '+'\n};\n\nconst tokenVisitor: { [name: string]: TokenVisitor } = {\n    Literal(token: Literal): string {\n        return token.value;\n    },\n    Quote(token: Quote) {\n        return token.single ? '\\'' : '\"';\n    },\n    Bracket(token: Bracket): string {\n        if (token.context === 'attribute') {\n            return token.open ? '[' : ']';\n        } else if (token.context === 'expression') {\n            return token.open ? '{' : '}';\n        } else {\n            return token.open ? '(' : '}';\n        }\n    },\n    Operator(token: Operator) {\n        return operators[token.operator];\n    },\n    Field(token: Field, state) {\n        if (token.index != null) {\n            // It’s a field: by default, return TextMate-compatible field\n            return token.name\n                ? `\\${${token.index}:${token.name}}`\n                : `\\${${token.index}`;\n        } else if (token.name) {\n            // It’s a variable\n            return state.getVariable(token.name);\n        }\n\n        return '';\n    },\n    RepeaterPlaceholder(token: RepeaterPlaceholder, state) {\n        // Find closest implicit repeater\n        let repeater: Repeater | undefined;\n        for (let i = state.repeaters.length - 1; i >= 0; i--) {\n            if (state.repeaters[i]!.implicit) {\n                repeater = state.repeaters[i]!;\n                break;\n            }\n        }\n\n        state.inserted = true;\n        return state.getText(repeater && repeater.value);\n    },\n    RepeaterNumber(token: RepeaterNumber, state) {\n        let value = 1;\n        const lastIx = state.repeaters.length - 1;\n        // const repeaterIx = Math.max(0, state.repeaters.length - 1 - token.parent);\n        const repeater = state.repeaters[lastIx];\n        if (repeater) {\n            value = token.reverse\n                ? token.base + repeater.count - repeater.value! - 1\n                : token.base + repeater.value!;\n\n            if (token.parent) {\n                const parentIx = Math.max(0, lastIx - token.parent);\n                if (parentIx !== lastIx) {\n                    const parentRepeater = state.repeaters[parentIx];\n                    value += repeater.count * parentRepeater.value;\n                }\n            }\n        }\n\n        let result = String(value);\n        while (result.length < token.size) {\n            result = '0' + result;\n        }\n\n        return result;\n    },\n    WhiteSpace(token: WhiteSpace) {\n        return token.value;\n    }\n};\n\n/**\n * Converts given value token to string\n */\nexport default function stringify(token: ValueToken, state: ConvertState): string {\n    if (!tokenVisitor[token.type]) {\n        throw new Error(`Unknown token ${token.type}`);\n    }\n    return tokenVisitor[token.type](token, state);\n}\n","import { TokenGroup, TokenStatement, TokenElement, TokenAttribute, isQuote, isBracket } from './parser';\nimport { Abbreviation, ParserOptions, AbbreviationNode, ConvertState, Value, AbbreviationAttribute, AttributeType } from './types';\nimport { Repeater, ValueToken, Quote, Field } from './tokenizer';\nimport stringify from './stringify';\n\nconst urlRegex = /^((https?:|ftp:|file:)?\\/\\/|(www|ftp)\\.)[^ ]*$/;\nconst emailRegex = /^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,5}$/;\n\n/**\n * Converts given token-based abbreviation into simplified and unrolled node-based\n * abbreviation\n */\nexport default function convert(abbr: TokenGroup, options: ParserOptions = {}): Abbreviation {\n    let textInserted = false;\n\n    let cleanText: string | string[] | undefined;\n    if (options.text) {\n        if (Array.isArray(options.text)) {\n            cleanText = options.text.filter(s => s.trim());\n        } else {\n            cleanText = options.text;\n        }\n    }\n\n    const result: Abbreviation = {\n        type: 'Abbreviation',\n        children: convertGroup(abbr, {\n            inserted: false,\n            repeaters: [],\n            text: options.text,\n            cleanText,\n            repeatGuard: options.maxRepeat || Number.POSITIVE_INFINITY,\n            getText(pos) {\n                textInserted = true;\n\n                let value: string;\n                if (Array.isArray(options.text)) {\n                    if (pos !== undefined && pos >= 0 && pos < cleanText!.length) {\n                        return cleanText![pos];\n                    }\n                    value = pos !== undefined ? options.text[pos] : options.text.join('\\n');\n                } else {\n                    value = options.text ?? '';\n                }\n                return value;\n            },\n            getVariable(name) {\n                const varValue = options.variables && options.variables[name];\n                return varValue != null ? varValue : name;\n            }\n        })\n    };\n\n    if (options.text != null && !textInserted) {\n        // Text given but no implicitly repeated elements: insert it into\n        // deepest child\n        const deepest = deepestNode(last(result.children));\n        if (deepest) {\n            const text = Array.isArray(options.text) ? options.text.join('\\n') : options.text;\n            insertText(deepest, text);\n\n            if (deepest.name === 'a' && options.href) {\n                // Automatically update value of `<a>` element if inserting URL or email\n                insertHref(deepest, text);\n            }\n        }\n    }\n\n    return result;\n}\n\n/**\n * Converts given statement to abbreviation nodes\n */\nfunction convertStatement(node: TokenStatement, state: ConvertState): AbbreviationNode[] {\n    let result: AbbreviationNode[] = [];\n\n    if (node.repeat) {\n        // Node is repeated: we should create copies of given node\n        // and supply context token with actual repeater state\n        const original = node.repeat;\n        const repeat = { ...original } as Repeater;\n        repeat.count = repeat.implicit && Array.isArray(state.text)\n            ? state.cleanText!.length\n            : (repeat.count || 1);\n        let items: AbbreviationNode[];\n\n        state.repeaters.push(repeat);\n\n        for (let i = 0; i < repeat.count; i++) {\n            repeat.value = i;\n            node.repeat = repeat;\n            items = isGroup(node)\n                ? convertGroup(node, state)\n                : convertElement(node, state);\n\n            if (repeat.implicit && !state.inserted) {\n                // It’s an implicit repeater but no repeater placeholders found inside,\n                // we should insert text into deepest node\n                const target = last(items);\n                const deepest = target && deepestNode(target);\n                if (deepest) {\n                    insertText(deepest, state.getText(repeat.value));\n                }\n            }\n\n            result = result.concat(items);\n\n            // We should output at least one repeated item even if it’s reached\n            // repeat limit\n            if (--state.repeatGuard <= 0) {\n                break;\n            }\n        }\n\n        state.repeaters.pop();\n        node.repeat = original;\n\n        if (repeat.implicit) {\n            state.inserted = true;\n        }\n    } else {\n        result = result.concat(isGroup(node) ? convertGroup(node, state) : convertElement(node, state));\n    }\n\n    return result;\n}\n\nfunction convertElement(node: TokenElement, state: ConvertState): AbbreviationNode[] {\n    let children: AbbreviationNode[] = [];\n\n    const elem = {\n        type: 'AbbreviationNode',\n        name: node.name && stringifyName(node.name, state),\n        value: node.value && stringifyValue(node.value, state),\n        attributes: void 0,\n        children,\n        repeat: node.repeat && { ...node.repeat },\n        selfClosing: node.selfClose,\n    } as AbbreviationNode;\n    let result: AbbreviationNode[] = [elem];\n\n    for (const child of node.elements) {\n        children = children.concat(convertStatement(child, state));\n    }\n\n    if (node.attributes) {\n        elem.attributes = [];\n        for (const attr of node.attributes) {\n            elem.attributes.push(convertAttribute(attr, state));\n        }\n    }\n\n    // In case if current node is a text-only snippet without fields, we should\n    // put all children as siblings\n    if (!elem.name && !elem.attributes && elem.value && !elem.value.some(isField)) {\n        // XXX it’s unclear that `children` is not bound to `elem`\n        // due to concat operation\n        result = result.concat(children);\n    } else {\n        elem.children = children;\n    }\n\n    return result;\n}\n\nfunction convertGroup(node: TokenGroup, state: ConvertState): AbbreviationNode[] {\n    let result: AbbreviationNode[] = [];\n    for (const child of node.elements) {\n        result = result.concat(convertStatement(child, state));\n    }\n\n    if (node.repeat) {\n        result = attachRepeater(result, node.repeat);\n    }\n\n    return result;\n}\n\nfunction convertAttribute(node: TokenAttribute, state: ConvertState): AbbreviationAttribute {\n    let implied = false;\n    let isBoolean = false;\n    let valueType: AttributeType = node.expression ? 'expression' : 'raw';\n    let value: Value[] | undefined;\n    const name = node.name && stringifyName(node.name, state);\n\n    if (name && name[0] === '!') {\n        implied = true;\n    }\n\n    if (name && name[name.length - 1] === '.') {\n        isBoolean = true;\n    }\n\n    if (node.value) {\n        const tokens = node.value.slice();\n\n        if (isQuote(tokens[0])) {\n            // It’s a quoted value: remove quotes from output but mark attribute\n            // value as quoted\n            const quote = tokens.shift() as Quote;\n            if (tokens.length && last(tokens).type === quote.type) {\n                tokens.pop();\n            }\n            valueType = quote.single ? 'singleQuote' : 'doubleQuote';\n        } else if (isBracket(tokens[0], 'expression', true)) {\n            // Value is expression: remove brackets but mark value type\n            valueType = 'expression';\n            tokens.shift();\n            if (isBracket(last(tokens), 'expression', false)) {\n                tokens.pop();\n            }\n        }\n\n        value = stringifyValue(tokens, state);\n    }\n\n    return {\n        name: isBoolean || implied\n            ? name!.slice(implied ? 1 : 0, isBoolean ? -1 : void 0)\n            : name,\n        value,\n        boolean: isBoolean,\n        implied,\n        valueType\n    };\n}\n\n/**\n * Converts given token list to string\n */\nfunction stringifyName(tokens: ValueToken[], state: ConvertState): string {\n    let str = '';\n    for (let i = 0; i < tokens.length; i++) {\n        str += stringify(tokens[i], state);\n    }\n\n    return str;\n}\n\n/**\n * Converts given token list to value list\n */\nfunction stringifyValue(tokens: ValueToken[], state: ConvertState): Value[] {\n    const result: Value[] = [];\n    let str = '';\n    for (let i = 0, token: ValueToken; i < tokens.length; i++) {\n        token = tokens[i];\n        if (isField(token)) {\n            // We should keep original fields in output since some editors has their\n            // own syntax for field or doesn’t support fields at all so we should\n            // capture actual field location in output stream\n            if (str) {\n                result.push(str);\n                str = '';\n            }\n            result.push(token);\n        } else {\n            str += stringify(token, state);\n        }\n    }\n\n    if (str) {\n        result.push(str);\n    }\n\n    return result;\n}\n\nexport function isGroup(node: any): node is TokenGroup {\n    return node.type === 'TokenGroup';\n}\n\nfunction isField(token: any): token is Field {\n    return typeof token === 'object' && token.type === 'Field' && token.index != null;\n}\n\nfunction last<T>(arr: T[]): T {\n    return arr[arr.length - 1];\n}\n\nfunction deepestNode(node: AbbreviationNode): AbbreviationNode {\n    return node.children.length ? deepestNode(last(node.children)) : node;\n}\n\nfunction insertText(node: AbbreviationNode, text: string) {\n    if (node.value) {\n        const lastToken = last(node.value);\n        if (typeof lastToken === 'string') {\n            node.value[node.value.length - 1] += text;\n        } else {\n            node.value.push(text);\n        }\n    } else {\n        node.value = [text];\n    }\n}\n\nfunction insertHref(node: AbbreviationNode, text: string) {\n    let href = '';\n    if (urlRegex.test(text)) {\n        href = text;\n        if (!/\\w+:/.test(href) && !href.startsWith('//')) {\n            href = `http://${href}`;\n        }\n    } else if (emailRegex.test(text)) {\n        href = `mailto:${text}`;\n    }\n\n    const hrefAttribute = node.attributes?.find(attr => attr.name === 'href');\n    if (!hrefAttribute) {\n        if (!node.attributes) {\n            node.attributes = [];\n        }\n        node.attributes.push({ name: 'href', value: [href], valueType: 'doubleQuote' });\n    } else if (!hrefAttribute.value) {\n        hrefAttribute.value = [href];\n    }\n}\n\nfunction attachRepeater(items: AbbreviationNode[], repeater: Repeater): AbbreviationNode[] {\n    for (const item of items) {\n        if (!item.repeat) {\n            item.repeat = { ...repeater };\n        }\n    }\n\n    return items;\n}\n","import { ScannerError } from '@emmetio/scanner';\nimport parse, { TokenGroup } from './parser';\nimport tokenize, { getToken, AllTokens } from './tokenizer';\nimport convert from './convert';\nimport { ParserOptions } from './types';\n\nexport { parse, tokenize, getToken, convert };\nexport * from './tokenizer/tokens';\nexport * from './types';\nexport type MarkupAbbreviation = TokenGroup;\n\n/**\n * Parses given abbreviation into node tree\n */\nexport default function parseAbbreviation(abbr: string | AllTokens[], options?: ParserOptions) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr) : abbr;\n        return convert(parse(tokens, options), options);\n    } catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n\n        throw err;\n    }\n}\n"],"names":["repeater","literal","isElementName","isQuote","parse"],"mappings":"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"}