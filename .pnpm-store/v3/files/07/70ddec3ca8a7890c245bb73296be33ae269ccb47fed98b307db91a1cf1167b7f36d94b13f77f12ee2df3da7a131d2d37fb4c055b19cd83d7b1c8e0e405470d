{"version":3,"file":"index.js","sources":["../src/options.ts","../src/printer/elements.ts","../src/printer/utils.ts","../src/printer/index.ts","../src/printer/embed.ts","../src/index.ts"],"sourcesContent":["import { SupportOption } from 'prettier';\n\ninterface PluginOptions {\n\tastroAllowShorthand: boolean;\n}\n\ndeclare module 'prettier' {\n\t// eslint-disable-next-line @typescript-eslint/no-empty-interface\n\tinterface RequiredOptions extends PluginOptions {}\n}\n\n// https://prettier.io/docs/en/plugins.html#options\nexport const options: Record<keyof PluginOptions, SupportOption> = {\n\tastroAllowShorthand: {\n\t\tsince: '0.0.10',\n\t\tcategory: 'Astro',\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tdescription: 'Enable/disable attribute shorthand if attribute name and expression are the same',\n\t},\n};\n","export type TagName = keyof HTMLElementTagNameMap | 'svg';\n\n// https://github.com/prettier/prettier/blob/main/vendors/html-void-elements.json\nexport const selfClosingTags = [\n\t'area',\n\t'base',\n\t'basefont',\n\t'bgsound',\n\t'br',\n\t'col',\n\t'command',\n\t'embed',\n\t'frame',\n\t'hr',\n\t'image',\n\t'img',\n\t'input',\n\t'isindex',\n\t'keygen',\n\t'link',\n\t'menuitem',\n\t'meta',\n\t'nextid',\n\t'param',\n\t'slot',\n\t'source',\n\t'track',\n\t'wbr',\n];\n\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements#Elements\nexport const blockElements: TagName[] = [\n\t'address',\n\t'article',\n\t'aside',\n\t'blockquote',\n\t'details',\n\t'dialog',\n\t'dd',\n\t'div',\n\t'dl',\n\t'dt',\n\t'fieldset',\n\t'figcaption',\n\t'figure',\n\t'footer',\n\t'form',\n\t'h1',\n\t'h2',\n\t'h3',\n\t'h4',\n\t'h5',\n\t'h6',\n\t'header',\n\t'hgroup',\n\t'hr',\n\t'li',\n\t'main',\n\t'nav',\n\t'ol',\n\t'p',\n\t'pre',\n\t'section',\n\t'table',\n\t'ul',\n\t// TODO: WIP\n\t'title',\n\t'html',\n];\n\n/**\n * HTML attributes that we may safely reformat (trim whitespace, add or remove newlines)\n */\nexport const formattableAttributes: string[] = [\n\t// None at the moment\n\t// Prettier HTML does not format attributes at all\n\t// and to be consistent we leave this array empty for now\n];\n","import { createRequire } from 'node:module';\nimport { AstPath as AstP, Doc, ParserOptions as ParserOpts } from 'prettier';\nimport { createSyncFn } from 'synckit';\nimport { blockElements, formattableAttributes, TagName } from './elements';\nimport {\n\tanyNode,\n\tCommentNode,\n\tExpressionNode,\n\tNode,\n\tParentLikeNode,\n\tTagLikeNode,\n\tTextNode,\n} from './nodes';\n\nexport type printFn = (path: AstPath) => Doc;\nexport type ParserOptions = ParserOpts<anyNode>;\nexport type AstPath = AstP<anyNode>;\n\nconst req = createRequire(import.meta.url);\nlet workerPath;\ntry {\n\tworkerPath = req.resolve('../workers/serialize-worker.js');\n} catch (e) {\n\tworkerPath = req.resolve('prettier-plugin-astro/workers/serialize-worker.js');\n}\nconst serialize = createSyncFn(req.resolve(workerPath));\n\nexport const openingBracketReplace = '_Pé';\nexport const closingBracketReplace = 'èP_';\nexport const atSignReplace = 'ΩP_';\nexport const dotReplace = 'ωP_';\n\nexport function isInlineElement(path: AstPath, opts: ParserOptions, node: anyNode): boolean {\n\treturn node && node.type === 'element' && !isBlockElement(node, opts) && !isPreTagContent(path);\n}\n\nexport function isBlockElement(node: anyNode, opts: ParserOptions): boolean {\n\treturn (\n\t\tnode &&\n\t\tnode.type === 'element' &&\n\t\topts.htmlWhitespaceSensitivity !== 'strict' &&\n\t\t(opts.htmlWhitespaceSensitivity === 'ignore' || blockElements.includes(node.name as TagName))\n\t);\n}\n\nexport function isIgnoreDirective(node: Node): boolean {\n\treturn node.type === 'comment' && node.value.trim() === 'prettier-ignore';\n}\n\n/**\n *  Returns the content of the node\n */\nexport function printRaw(node: anyNode, stripLeadingAndTrailingNewline = false): string {\n\tif (!isNodeWithChildren(node)) {\n\t\treturn '';\n\t}\n\n\tif (node.children.length === 0) {\n\t\treturn '';\n\t}\n\n\tlet raw = node.children.reduce((prev: string, curr: Node) => prev + serialize(curr), '');\n\n\tif (!stripLeadingAndTrailingNewline) {\n\t\treturn raw;\n\t}\n\n\tif (startsWithLinebreak(raw)) {\n\t\traw = raw.substring(raw.indexOf('\\n') + 1);\n\t}\n\tif (endsWithLinebreak(raw)) {\n\t\traw = raw.substring(0, raw.lastIndexOf('\\n'));\n\t\tif (raw.charAt(raw.length - 1) === '\\r') {\n\t\t\traw = raw.substring(0, raw.length - 1);\n\t\t}\n\t}\n\n\treturn raw;\n}\n\nexport function isNodeWithChildren(node: anyNode): node is anyNode & ParentLikeNode {\n\treturn node && 'children' in node && Array.isArray(node.children);\n}\n\nexport const isEmptyTextNode = (node: anyNode): boolean => {\n\treturn !!node && node.type === 'text' && getUnencodedText(node).trim() === '';\n};\n\nexport function getUnencodedText(node: TextNode | CommentNode): string {\n\treturn node.value;\n}\n\nexport function isTextNodeStartingWithLinebreak(node: TextNode, nrLines = 1): node is TextNode {\n\treturn startsWithLinebreak(getUnencodedText(node), nrLines);\n}\n\nexport function startsWithLinebreak(text: string, nrLines = 1): boolean {\n\treturn new RegExp(`^([\\\\t\\\\f\\\\r ]*\\\\n){${nrLines}}`).test(text);\n}\n\nexport function endsWithLinebreak(text: string, nrLines = 1): boolean {\n\treturn new RegExp(`(\\\\n[\\\\t\\\\f\\\\r ]*){${nrLines}}$`).test(text);\n}\n\nexport function isTextNodeStartingWithWhitespace(node: Node): node is TextNode {\n\treturn isTextNode(node) && /^\\s/.test(getUnencodedText(node));\n}\n\nfunction endsWithWhitespace(text: string) {\n\treturn /\\s$/.test(text);\n}\n\nexport function isTextNodeEndingWithWhitespace(node: Node): node is TextNode {\n\treturn isTextNode(node) && endsWithWhitespace(getUnencodedText(node));\n}\n\nexport function hasSetDirectives(node: TagLikeNode) {\n\tconst attributes = Array.from(node.attributes, (attr) => attr.name);\n\treturn attributes.some((attr) => ['set:html', 'set:text'].includes(attr));\n}\n\n/**\n * Check if given node's start tag should hug its first child. This is the case for inline elements when there's\n * no whitespace between the `>` and the first child.\n */\nexport function shouldHugStart(node: anyNode, opts: ParserOptions): boolean {\n\tif (isBlockElement(node, opts)) {\n\t\treturn false;\n\t}\n\n\tif (!isNodeWithChildren(node)) {\n\t\treturn false;\n\t}\n\n\tconst children = node.children;\n\tif (children.length === 0) {\n\t\treturn true;\n\t}\n\n\tconst firstChild = children[0];\n\treturn !isTextNodeStartingWithWhitespace(firstChild);\n}\n\n/**\n * Check if given node's end tag should hug its last child. This is the case for inline elements when there's\n * no whitespace between the last child and the `</`.\n */\nexport function shouldHugEnd(node: anyNode, opts: ParserOptions): boolean {\n\tif (isBlockElement(node, opts)) {\n\t\treturn false;\n\t}\n\n\tif (!isNodeWithChildren(node)) {\n\t\treturn false;\n\t}\n\n\tconst children = node.children;\n\tif (children.length === 0) {\n\t\treturn true;\n\t}\n\n\tconst lastChild = children[children.length - 1];\n\tif (isExpressionNode(lastChild)) return true;\n\tif (!isTextNode(lastChild)) return false;\n\treturn !endsWithWhitespace(getUnencodedText(lastChild));\n}\n\n/**\n * Returns true if the softline between `</tagName` and `>` can be omitted.\n */\nexport function canOmitSoftlineBeforeClosingTag(path: AstPath, opts: ParserOptions): boolean {\n\treturn isLastChildWithinParentBlockElement(path, opts);\n}\n\nfunction getChildren(node: anyNode): Node[] {\n\treturn isNodeWithChildren(node) ? node.children : [];\n}\n\nfunction isLastChildWithinParentBlockElement(path: AstPath, opts: ParserOptions): boolean {\n\tconst parent = path.getParentNode();\n\tif (!parent || !isBlockElement(parent, opts)) {\n\t\treturn false;\n\t}\n\n\tconst children = getChildren(parent);\n\tconst lastChild = children[children.length - 1];\n\treturn lastChild === path.getNode();\n}\n\nexport function trimTextNodeLeft(node: TextNode): void {\n\tnode.value = node.value && node.value.trimStart();\n}\n\nexport function trimTextNodeRight(node: TextNode): void {\n\tnode.value = node.value && node.value.trimEnd();\n}\n\nexport function printClassNames(value: string) {\n\treturn value.trim().split(/\\s+/).join(' ');\n}\n\n/** dedent string & return tabSize (the last part is what we need) */\nexport function manualDedent(input: string): {\n\ttabSize: number;\n\tchar: string;\n\tresult: string;\n} {\n\tlet minTabSize = Infinity;\n\tlet result = input;\n\t// 1. normalize\n\tresult = result.replace(/\\r\\n/g, '\\n');\n\n\t// 2. count tabSize\n\tlet char = '';\n\tfor (const line of result.split('\\n')) {\n\t\tif (!line) continue;\n\t\t// if any line begins with a non-whitespace char, minTabSize is 0\n\t\tif (line[0] && /^[^\\s]/.test(line[0])) {\n\t\t\tminTabSize = 0;\n\t\t\tbreak;\n\t\t}\n\t\tconst match = line.match(/^(\\s+)\\S+/); // \\S ensures we don’t count lines of pure whitespace\n\t\tif (match) {\n\t\t\tif (match[1] && !char) char = match[1][0];\n\t\t\tif (match[1].length < minTabSize) minTabSize = match[1].length;\n\t\t}\n\t}\n\n\t// 3. reformat string\n\tif (minTabSize > 0 && Number.isFinite(minTabSize)) {\n\t\tresult = result.replace(new RegExp(`^${new Array(minTabSize + 1).join(char)}`, 'gm'), '');\n\t}\n\n\treturn {\n\t\ttabSize: minTabSize === Infinity ? 0 : minTabSize,\n\t\tchar,\n\t\tresult,\n\t};\n}\n\n/** True if the node is of type text */\nexport function isTextNode(node: anyNode): node is TextNode {\n\treturn node.type === 'text';\n}\n\nexport function isExpressionNode(node: anyNode): node is ExpressionNode {\n\treturn node.type === 'expression';\n}\n\n/** True if the node is TagLikeNode:\n *\n * ElementNode | ComponentNode | CustomElementNode | FragmentNode */\nexport function isTagLikeNode(node: anyNode): node is TagLikeNode {\n\treturn (\n\t\tnode.type === 'element' ||\n\t\tnode.type === 'component' ||\n\t\tnode.type === 'custom-element' ||\n\t\tnode.type === 'fragment'\n\t);\n}\n\n/**\n * Returns siblings, that is, the children of the parent.\n */\nexport function getSiblings(path: AstPath): anyNode[] {\n\tconst parent = path.getParentNode();\n\tif (!parent) return [];\n\n\treturn getChildren(parent);\n}\n\nexport function getNextNode(path: AstPath): anyNode | null {\n\tconst node = path.getNode();\n\tif (node) {\n\t\tconst siblings = getSiblings(path);\n\t\tif (node.position?.start === siblings[siblings.length - 1].position?.start) return null;\n\t\tfor (let i = 0; i < siblings.length; i++) {\n\t\t\tconst sibling = siblings[i];\n\t\t\tif (sibling.position?.start === node.position?.start && i !== siblings.length - 1) {\n\t\t\t\treturn siblings[i + 1];\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n}\n\nexport const isPreTagContent = (path: AstPath): boolean => {\n\tif (!path || !path.stack || !Array.isArray(path.stack)) return false;\n\treturn path.stack.some(\n\t\t(node: anyNode) =>\n\t\t\t(node.type === 'element' && node.name.toLowerCase() === 'pre') ||\n\t\t\t(node.type === 'attribute' && !formattableAttributes.includes(node.name))\n\t);\n};\n\ninterface QuoteResult {\n\tquote: '\"' | \"'\";\n\tregex: RegExp;\n\tescaped: string;\n}\n\n// Adapted from Prettier's source code as it's unfortunately not exported\n// https://github.com/prettier/prettier/blob/237e681936fc533c27d7ce8577d3fc98838a3314/src/common/util.js#L238\nexport function getPreferredQuote(rawContent: string, preferredQuote: string): QuoteResult {\n\tconst double: QuoteResult = { quote: '\"', regex: /\"/g, escaped: '&quot;' };\n\tconst single: QuoteResult = { quote: \"'\", regex: /'/g, escaped: '&apos;' };\n\n\tconst preferred = preferredQuote === \"'\" ? single : double;\n\tconst alternate = preferred === single ? double : single;\n\n\tlet result = preferred;\n\n\t// If `rawContent` contains at least one of the quote preferred for enclosing\n\t// the string, we might want to enclose with the alternate quote instead, to\n\t// minimize the number of escaped quotes.\n\tif (rawContent.includes(preferred.quote) || rawContent.includes(alternate.quote)) {\n\t\tconst numPreferredQuotes = (rawContent.match(preferred.regex) || []).length;\n\t\tconst numAlternateQuotes = (rawContent.match(alternate.regex) || []).length;\n\n\t\tresult = numPreferredQuotes > numAlternateQuotes ? alternate : preferred;\n\t}\n\n\treturn result;\n}\n","import { Doc } from 'prettier';\nimport { selfClosingTags } from './elements';\nimport { TextNode } from './nodes';\nimport {\n\tAstPath,\n\tcanOmitSoftlineBeforeClosingTag,\n\tendsWithLinebreak,\n\tgetNextNode,\n\tgetPreferredQuote,\n\tgetUnencodedText,\n\thasSetDirectives,\n\tisEmptyTextNode,\n\tisIgnoreDirective,\n\tisInlineElement,\n\tisPreTagContent,\n\tisTagLikeNode,\n\tisTextNode,\n\tisTextNodeEndingWithWhitespace,\n\tisTextNodeStartingWithLinebreak,\n\tisTextNodeStartingWithWhitespace,\n\tParserOptions,\n\tprintClassNames,\n\tprintFn,\n\tprintRaw,\n\tshouldHugEnd,\n\tshouldHugStart,\n\tstartsWithLinebreak,\n\ttrimTextNodeLeft,\n\ttrimTextNodeRight,\n} from './utils';\n\nimport _doc from 'prettier/doc';\nconst {\n\tbuilders: {\n\t\tbreakParent,\n\t\tdedent,\n\t\tfill,\n\t\tgroup,\n\t\tindent,\n\t\tjoin,\n\t\tline,\n\t\tsoftline,\n\t\thardline,\n\t\tliteralline,\n\t},\n\tutils: { stripTrailingHardline },\n} = _doc;\n\nlet ignoreNext = false;\n\n// https://prettier.io/docs/en/plugins.html#print\n// eslint-disable-next-line @typescript-eslint/no-shadow\nexport function print(path: AstPath, opts: ParserOptions, print: printFn): Doc {\n\tconst node = path.getValue();\n\n\t// 1. handle special node types\n\tif (!node) {\n\t\treturn '';\n\t}\n\n\tif (ignoreNext && !isEmptyTextNode(node)) {\n\t\tignoreNext = false;\n\t\treturn [\n\t\t\topts.originalText\n\t\t\t\t.slice(opts.locStart(node), opts.locEnd(node))\n\t\t\t\t.split('\\n')\n\t\t\t\t.map((lineContent, i) => (i == 0 ? [lineContent] : [literalline, lineContent]))\n\t\t\t\t.flat(),\n\t\t];\n\t}\n\n\tif (typeof node === 'string') {\n\t\treturn node;\n\t}\n\n\t// 2. handle printing\n\tswitch (node.type) {\n\t\tcase 'root': {\n\t\t\treturn [stripTrailingHardline(path.map(print, 'children')), hardline];\n\t\t}\n\n\t\tcase 'text': {\n\t\t\tconst rawText = getUnencodedText(node);\n\n\t\t\t// TODO: TEST PRE TAGS\n\t\t\t// if (isPreTagContent(path)) {\n\t\t\t//   if (path.getParentNode()?.type === 'Attribute') {\n\t\t\t//     // Direct child of attribute value -> add literallines at end of lines\n\t\t\t//     // so that other things don't break in unexpected places\n\t\t\t//     return replaceEndOfLineWith(rawText, literalline);\n\t\t\t//   }\n\t\t\t//   return rawText;\n\t\t\t// }\n\n\t\t\tif (isEmptyTextNode(node)) {\n\t\t\t\tconst hasWhiteSpace = rawText.trim().length < getUnencodedText(node).length;\n\t\t\t\tconst hasOneOrMoreNewlines = /\\n/.test(getUnencodedText(node));\n\t\t\t\tconst hasTwoOrMoreNewlines = /\\n\\r?\\s*\\n\\r?/.test(getUnencodedText(node));\n\t\t\t\tif (hasTwoOrMoreNewlines) {\n\t\t\t\t\treturn [hardline, hardline];\n\t\t\t\t}\n\t\t\t\tif (hasOneOrMoreNewlines) {\n\t\t\t\t\treturn hardline;\n\t\t\t\t}\n\t\t\t\tif (hasWhiteSpace) {\n\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn '';\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * For non-empty text nodes each sequence of non-whitespace characters (effectively,\n\t\t\t * each \"word\") is joined by a single `line`, which will be rendered as a single space\n\t\t\t * until this node's current line is out of room, at which `fill` will break at the\n\t\t\t * most convenient instance of `line`.\n\t\t\t */\n\t\t\treturn fill(splitTextToDocs(node));\n\t\t}\n\n\t\tcase 'component':\n\t\tcase 'fragment':\n\t\tcase 'custom-element':\n\t\tcase 'element': {\n\t\t\tlet isEmpty: boolean;\n\t\t\tif (!node.children) {\n\t\t\t\tisEmpty = true;\n\t\t\t} else {\n\t\t\t\tisEmpty = node.children.every((child) => isEmptyTextNode(child));\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * An element is allowed to self close only if:\n\t\t\t * It is empty AND\n\t\t\t *  It's a component OR\n\t\t\t *  It's in the HTML spec as a void element OR\n\t\t\t *  It has a `set:*` directive\n\t\t\t */\n\t\t\tconst isSelfClosingTag =\n\t\t\t\tisEmpty &&\n\t\t\t\t(node.type === 'component' ||\n\t\t\t\t\tselfClosingTags.includes(node.name) ||\n\t\t\t\t\thasSetDirectives(node));\n\n\t\t\tconst isSingleLinePerAttribute = opts.singleAttributePerLine && node.attributes.length > 1;\n\t\t\tconst attributeLine = isSingleLinePerAttribute ? breakParent : '';\n\t\t\tconst attributes = join(attributeLine, path.map(print, 'attributes'));\n\n\t\t\tif (isSelfClosingTag) {\n\t\t\t\treturn group(['<', node.name, indent(attributes), line, `/>`]);\n\t\t\t}\n\n\t\t\tif (node.children) {\n\t\t\t\tconst children = node.children;\n\t\t\t\tconst firstChild = children[0];\n\t\t\t\tconst lastChild = children[children.length - 1];\n\n\t\t\t\t// No hugging of content means it's either a block element and/or there's whitespace at the start/end\n\t\t\t\tlet noHugSeparatorStart:\n\t\t\t\t\t| _doc.builders.Concat\n\t\t\t\t\t| _doc.builders.Line\n\t\t\t\t\t| _doc.builders.Softline\n\t\t\t\t\t| string = softline;\n\t\t\t\tlet noHugSeparatorEnd:\n\t\t\t\t\t| _doc.builders.Concat\n\t\t\t\t\t| _doc.builders.Line\n\t\t\t\t\t| _doc.builders.Softline\n\t\t\t\t\t| string = softline;\n\t\t\t\tconst hugStart = shouldHugStart(node, opts);\n\t\t\t\tconst hugEnd = shouldHugEnd(node, opts);\n\n\t\t\t\tlet body;\n\n\t\t\t\tif (isEmpty) {\n\t\t\t\t\tbody =\n\t\t\t\t\t\tisInlineElement(path, opts, node) &&\n\t\t\t\t\t\tnode.children.length &&\n\t\t\t\t\t\tisTextNodeStartingWithWhitespace(node.children[0]) &&\n\t\t\t\t\t\t!isPreTagContent(path)\n\t\t\t\t\t\t\t? () => line\n\t\t\t\t\t\t\t: () => softline;\n\t\t\t\t} else if (isPreTagContent(path)) {\n\t\t\t\t\tbody = () => printRaw(node);\n\t\t\t\t} else if (isInlineElement(path, opts, node) && !isPreTagContent(path)) {\n\t\t\t\t\tbody = () => path.map(print, 'children');\n\t\t\t\t} else {\n\t\t\t\t\tbody = () => path.map(print, 'children');\n\t\t\t\t}\n\n\t\t\t\tconst openingTag = [\n\t\t\t\t\t'<',\n\t\t\t\t\tnode.name,\n\t\t\t\t\tindent(\n\t\t\t\t\t\tgroup([\n\t\t\t\t\t\t\tattributes,\n\t\t\t\t\t\t\thugStart\n\t\t\t\t\t\t\t\t? ''\n\t\t\t\t\t\t\t\t: !isPreTagContent(path) && !opts.bracketSameLine\n\t\t\t\t\t\t\t\t? dedent(softline)\n\t\t\t\t\t\t\t\t: '',\n\t\t\t\t\t\t])\n\t\t\t\t\t),\n\t\t\t\t];\n\n\t\t\t\tif (hugStart && hugEnd) {\n\t\t\t\t\tconst huggedContent = [\n\t\t\t\t\t\tisSingleLinePerAttribute ? hardline : softline,\n\t\t\t\t\t\tgroup(['>', body(), `</${node.name}`]),\n\t\t\t\t\t];\n\n\t\t\t\t\tconst omitSoftlineBeforeClosingTag =\n\t\t\t\t\t\tisEmpty || canOmitSoftlineBeforeClosingTag(path, opts);\n\t\t\t\t\treturn group([\n\t\t\t\t\t\t...openingTag,\n\t\t\t\t\t\tisEmpty ? group(huggedContent) : group(indent(huggedContent)),\n\t\t\t\t\t\tomitSoftlineBeforeClosingTag ? '' : softline,\n\t\t\t\t\t\t'>',\n\t\t\t\t\t]);\n\t\t\t\t}\n\n\t\t\t\tif (isPreTagContent(path)) {\n\t\t\t\t\tnoHugSeparatorStart = '';\n\t\t\t\t\tnoHugSeparatorEnd = '';\n\t\t\t\t} else {\n\t\t\t\t\tlet didSetEndSeparator = false;\n\n\t\t\t\t\tif (!hugStart && firstChild && isTextNode(firstChild)) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tisTextNodeStartingWithLinebreak(firstChild) &&\n\t\t\t\t\t\t\tfirstChild !== lastChild &&\n\t\t\t\t\t\t\t(!isInlineElement(path, opts, node) || isTextNodeEndingWithWhitespace(lastChild))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tnoHugSeparatorStart = hardline;\n\t\t\t\t\t\t\tnoHugSeparatorEnd = hardline;\n\t\t\t\t\t\t\tdidSetEndSeparator = true;\n\t\t\t\t\t\t} else if (isInlineElement(path, opts, node)) {\n\t\t\t\t\t\t\tnoHugSeparatorStart = line;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttrimTextNodeLeft(firstChild);\n\t\t\t\t\t}\n\t\t\t\t\tif (!hugEnd && lastChild && isTextNode(lastChild)) {\n\t\t\t\t\t\tif (isInlineElement(path, opts, node) && !didSetEndSeparator) {\n\t\t\t\t\t\t\tnoHugSeparatorEnd = softline;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttrimTextNodeRight(lastChild);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (hugStart) {\n\t\t\t\t\treturn group([\n\t\t\t\t\t\t...openingTag,\n\t\t\t\t\t\tindent([softline, group(['>', body()])]),\n\t\t\t\t\t\tnoHugSeparatorEnd,\n\t\t\t\t\t\t`</${node.name}>`,\n\t\t\t\t\t]);\n\t\t\t\t}\n\n\t\t\t\tif (hugEnd) {\n\t\t\t\t\treturn group([\n\t\t\t\t\t\t...openingTag,\n\t\t\t\t\t\t'>',\n\t\t\t\t\t\tindent([noHugSeparatorStart, group([body(), `</${node.name}`])]),\n\t\t\t\t\t\tcanOmitSoftlineBeforeClosingTag(path, opts) ? '' : softline,\n\t\t\t\t\t\t'>',\n\t\t\t\t\t]);\n\t\t\t\t}\n\n\t\t\t\tif (isEmpty) {\n\t\t\t\t\treturn group([...openingTag, '>', body(), `</${node.name}>`]);\n\t\t\t\t}\n\n\t\t\t\treturn group([\n\t\t\t\t\t...openingTag,\n\t\t\t\t\t'>',\n\t\t\t\t\tindent([noHugSeparatorStart, body()]),\n\t\t\t\t\tnoHugSeparatorEnd,\n\t\t\t\t\t`</${node.name}>`,\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\t// TODO: WIP\n\t\t\treturn '';\n\t\t}\n\n\t\tcase 'attribute': {\n\t\t\tconst name = node.name.trim();\n\t\t\tswitch (node.kind) {\n\t\t\t\tcase 'empty':\n\t\t\t\t\treturn [line, name];\n\t\t\t\tcase 'expression':\n\t\t\t\t\t// Handled in the `embed` function\n\t\t\t\t\t// See embed.ts\n\t\t\t\t\treturn '';\n\t\t\t\tcase 'quoted':\n\t\t\t\t\tlet value = node.value;\n\n\t\t\t\t\tif (node.name === 'class') {\n\t\t\t\t\t\tvalue = printClassNames(value);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst unescapedValue = value.replace(/&apos;/g, \"'\").replace(/&quot;/g, '\"');\n\t\t\t\t\tconst { escaped, quote, regex } = getPreferredQuote(\n\t\t\t\t\t\tunescapedValue,\n\t\t\t\t\t\topts.jsxSingleQuote ? \"'\" : '\"'\n\t\t\t\t\t);\n\n\t\t\t\t\tconst result = unescapedValue.replace(regex, escaped);\n\t\t\t\t\treturn [line, name, '=', quote, result, quote];\n\t\t\t\tcase 'shorthand':\n\t\t\t\t\treturn [line, '{', name, '}'];\n\t\t\t\tcase 'spread':\n\t\t\t\t\treturn [line, '{...', name, '}'];\n\t\t\t\tcase 'template-literal':\n\t\t\t\t\treturn [line, name, '=', '`', node.value, '`'];\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn '';\n\t\t}\n\n\t\tcase 'doctype': {\n\t\t\t// https://www.w3.org/wiki/Doctypes_and_markup_styles\n\t\t\treturn ['<!DOCTYPE html>', hardline];\n\t\t}\n\n\t\tcase 'comment':\n\t\t\tif (isIgnoreDirective(node)) {\n\t\t\t\tignoreNext = true;\n\t\t\t}\n\n\t\t\tconst nextNode = getNextNode(path);\n\t\t\tlet trailingLine: _doc.builders.Concat | string = '';\n\t\t\tif (nextNode && isTagLikeNode(nextNode)) {\n\t\t\t\ttrailingLine = hardline;\n\t\t\t}\n\t\t\treturn ['<!--', getUnencodedText(node), '-->', trailingLine];\n\n\t\tdefault: {\n\t\t\tthrow new Error(`Unhandled node type \"${node.type}\"!`);\n\t\t}\n\t}\n}\n\n/**\n * Split the text into words separated by whitespace. Replace the whitespaces by lines,\n * collapsing multiple whitespaces into a single line.\n *\n * If the text starts or ends with multiple newlines, two of those should be kept.\n */\nfunction splitTextToDocs(node: TextNode): Doc[] {\n\tconst text = getUnencodedText(node);\n\n\tconst textLines = text.split(/[\\t\\n\\f\\r ]+/);\n\n\tlet docs = join(line, textLines).parts.filter((s) => s !== '');\n\n\tif (startsWithLinebreak(text)) {\n\t\tdocs[0] = hardline;\n\t}\n\tif (startsWithLinebreak(text, 2)) {\n\t\tdocs = [hardline, ...docs];\n\t}\n\n\tif (endsWithLinebreak(text)) {\n\t\tdocs[docs.length - 1] = hardline;\n\t}\n\tif (endsWithLinebreak(text, 2)) {\n\t\tdocs = [...docs, hardline];\n\t}\n\n\treturn docs;\n}\n","import { BuiltInParsers, Doc, ParserOptions } from 'prettier';\nimport _doc from 'prettier/doc';\nimport { SassFormatter, SassFormatterConfig } from 'sass-formatter';\nimport { AttributeNode, ExpressionNode, FragmentNode, Node } from './nodes';\nimport {\n\tAstPath,\n\tatSignReplace,\n\tclosingBracketReplace,\n\tdotReplace,\n\tisNodeWithChildren,\n\tisTagLikeNode,\n\tisTextNode,\n\tmanualDedent,\n\topeningBracketReplace,\n\tprintFn,\n\tprintRaw,\n} from './utils';\n\nconst {\n\tbuilders: { group, indent, join, line, softline, hardline, lineSuffixBoundary },\n\tutils: { stripTrailingHardline, mapDoc },\n} = _doc;\n\ntype supportedStyleLang = 'css' | 'scss' | 'sass';\n\n// https://prettier.io/docs/en/plugins.html#optional-embed\nexport function embed(\n\tpath: AstPath,\n\tprint: printFn,\n\ttextToDoc: (text: string, options: object) => Doc,\n\topts: ParserOptions\n) {\n\tconst node = path.getValue();\n\n\tif (!node) return null;\n\n\tif (node.type === 'expression') {\n\t\tconst jsxNode = makeNodeJSXCompatible<ExpressionNode>(node);\n\t\tconst textContent = printRaw(jsxNode);\n\n\t\tlet content: Doc;\n\n\t\tcontent = wrapParserTryCatch(textToDoc, forceIntoExpression(textContent), {\n\t\t\t...opts,\n\t\t\tparser: expressionParser,\n\t\t});\n\n\t\tcontent = stripTrailingHardline(content);\n\n\t\t// HACK: Bit of a weird hack to get if a document is exclusively comments\n\t\t// Using `mapDoc` directly to build the array for some reason caused it to always be undefined? Not sure why\n\t\tconst strings: string[] = [];\n\t\tmapDoc(content, (doc) => {\n\t\t\tif (typeof doc === 'string') {\n\t\t\t\tstrings.push(doc);\n\t\t\t}\n\t\t});\n\n\t\tif (strings.every((value) => value.startsWith('//'))) {\n\t\t\treturn group(['{', content, softline, lineSuffixBoundary, '}']);\n\t\t}\n\n\t\t// Create a Doc without the things we had to add to make the expression compatible with Babel\n\t\tconst astroDoc = mapDoc(content, (doc) => {\n\t\t\tif (typeof doc === 'string') {\n\t\t\t\tdoc = doc.replace(openingBracketReplace, '{');\n\t\t\t\tdoc = doc.replace(closingBracketReplace, '}');\n\t\t\t\tdoc = doc.replace(atSignReplace, '@');\n\t\t\t\tdoc = doc.replace(dotReplace, '.');\n\t\t\t}\n\n\t\t\treturn doc;\n\t\t});\n\n\t\treturn group(['{', indent([softline, astroDoc]), softline, lineSuffixBoundary, '}']);\n\t}\n\n\t// Attribute using an expression as value\n\tif (node.type === 'attribute' && node.kind === 'expression') {\n\t\tconst value = node.value.trim();\n\t\tconst name = node.name.trim();\n\n\t\tconst attrNodeValue = wrapParserTryCatch(textToDoc, forceIntoExpression(value), {\n\t\t\t...opts,\n\t\t\tparser: expressionParser,\n\t\t});\n\n\t\tif (name === value && opts.astroAllowShorthand) {\n\t\t\treturn [line, '{', attrNodeValue, '}'];\n\t\t}\n\n\t\treturn [line, name, '=', '{', attrNodeValue, '}'];\n\t}\n\n\t// Frontmatter\n\tif (node.type === 'frontmatter') {\n\t\tconst frontmatterContent = wrapParserTryCatch(textToDoc, node.value, {\n\t\t\t...opts,\n\t\t\tparser: 'typescript',\n\t\t});\n\n\t\treturn [group(['---', hardline, frontmatterContent, '---', hardline]), hardline];\n\t}\n\n\t// Script tags\n\tif (node.type === 'element' && node.name === 'script') {\n\t\tconst scriptContent = printRaw(node);\n\t\tlet formattedScript = wrapParserTryCatch(textToDoc, scriptContent, {\n\t\t\t...opts,\n\t\t\tparser: 'typescript',\n\t\t});\n\n\t\tformattedScript = stripTrailingHardline(formattedScript);\n\t\tconst isEmpty = /^\\s*$/.test(scriptContent);\n\n\t\t// print\n\t\tconst attributes = path.map(print, 'attributes');\n\t\tconst openingTag = group(['<script', indent(group(attributes)), softline, '>']);\n\t\treturn [\n\t\t\topeningTag,\n\t\t\tindent([isEmpty ? '' : hardline, formattedScript]),\n\t\t\tisEmpty ? '' : hardline,\n\t\t\t'</script>',\n\t\t];\n\t}\n\n\t// Style tags\n\tif (node.type === 'element' && node.name === 'style') {\n\t\tconst content = printRaw(node);\n\t\tconst supportedStyleLangValues = ['css', 'scss', 'sass'];\n\t\tlet parserLang: supportedStyleLang = 'css';\n\n\t\tif (node.attributes) {\n\t\t\tconst langAttribute = node.attributes.filter((x) => x.name === 'lang');\n\t\t\tif (langAttribute.length) {\n\t\t\t\tconst styleLang = langAttribute[0].value.toLowerCase();\n\t\t\t\tif (supportedStyleLangValues.includes(styleLang))\n\t\t\t\t\tparserLang = styleLang as supportedStyleLang;\n\t\t\t}\n\t\t}\n\n\t\treturn embedStyle(parserLang, content, path, print, textToDoc, opts);\n\t}\n\n\treturn null;\n}\n\nfunction wrapParserTryCatch(\n\tcb: (text: string, options: object) => Doc,\n\ttext: string,\n\toptions: ParserOptions\n) {\n\ttry {\n\t\treturn cb(text, options);\n\t} catch (e) {\n\t\t// If we couldn't parse the expression (ex: syntax error) and we throw here, Prettier fallback to `print` and we'll\n\t\t// get a totally useless error message (ex: unhandled node type). An undocumented way to work around this is to set\n\t\t// `PRETTIER_DEBUG=1`, but nobody know that exists / want to do that just to get useful error messages. So we force it on\n\t\tprocess.env.PRETTIER_DEBUG = 'true';\n\t\tthrow e;\n\t}\n}\n\nfunction forceIntoExpression(statement: string) {\n\t// note the trailing newline: if the statement ends in a // comment,\n\t// we can't add the closing bracket right afterwards\n\treturn `<>{${statement}\\n}</>`;\n}\n\nfunction expressionParser(text: string, parsers: BuiltInParsers, options: ParserOptions) {\n\tconst ast = parsers['babel-ts'](text, options);\n\n\treturn {\n\t\t...ast,\n\t\tprogram: ast.program.body[0].expression.children[0].expression,\n\t};\n}\n\n/**\n * Due to the differences between Astro and JSX, Prettier's TypeScript parsers (be it `typescript` or `babel-ts`) are not\n * able to parse all expressions. So we need to first make the expression compatible before passing it to the parser\n *\n * A list of the difference that matters here:\n * - Astro allows a shorthand syntax for props. ex: `<Component {props} />`\n * - Astro allows multiple root elements. ex: `<div></div><div></div>`\n * - Astro allows attributes to include at signs (@) and dots (.)\n */\nfunction makeNodeJSXCompatible<T>(node: any): T {\n\tconst newNode = { ...node };\n\tconst childBundle: Node[][] = [];\n\tlet childBundleIndex = 0;\n\n\tif (isNodeWithChildren(newNode)) {\n\t\tnewNode.children = newNode.children.reduce((result: Node[], child, index) => {\n\t\t\tconst previousChildren = newNode.children[index - 1];\n\t\t\tconst nextChildren = newNode.children[index + 1];\n\t\t\tif (isTagLikeNode(child)) {\n\t\t\t\tchild.attributes = child.attributes.map(makeAttributeJSXCompatible);\n\n\t\t\t\tif (!childBundle[childBundleIndex]) {\n\t\t\t\t\tchildBundle[childBundleIndex] = [];\n\t\t\t\t}\n\n\t\t\t\tif (isNodeWithChildren(child)) {\n\t\t\t\t\tchild = makeNodeJSXCompatible<typeof child>(child);\n\t\t\t\t}\n\n\t\t\t\t// If we don't have a previous children, or it's not an element AND\n\t\t\t\t// we have a next children, and it's an element. Add the current children to the bundle\n\t\t\t\tif (\n\t\t\t\t\t(!previousChildren || isTextNode(previousChildren)) &&\n\t\t\t\t\tnextChildren &&\n\t\t\t\t\tisTagLikeNode(nextChildren)\n\t\t\t\t) {\n\t\t\t\t\tchildBundle[childBundleIndex].push(child);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t// If we have elements in our bundle, and there's no next children, or it's a text node\n\t\t\t\t// Create a fake parent, and add all the previous encountered elements as children of it\n\t\t\t\tif (\n\t\t\t\t\t(!nextChildren || isTextNode(nextChildren)) &&\n\t\t\t\t\tchildBundle[childBundleIndex].length > 0\n\t\t\t\t) {\n\t\t\t\t\tchildBundle[childBundleIndex].push(child);\n\n\t\t\t\t\tconst parentNode: FragmentNode = {\n\t\t\t\t\t\ttype: 'fragment',\n\t\t\t\t\t\tname: '',\n\t\t\t\t\t\tattributes: [],\n\t\t\t\t\t\tchildren: childBundle[childBundleIndex],\n\t\t\t\t\t};\n\n\t\t\t\t\tchildBundleIndex += 1;\n\t\t\t\t\tresult.push(parentNode);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tchildBundleIndex += 1;\n\t\t\t}\n\n\t\t\tresult.push(child);\n\t\t\treturn result;\n\t\t}, []);\n\t}\n\n\treturn newNode;\n\n\tfunction makeAttributeJSXCompatible(attr: AttributeNode): AttributeNode {\n\t\t// Transform shorthand attributes into an empty attribute, ex: `{shorthand}` becomes `shorthand` and wrap it\n\t\t// so we can transform it back into {}\n\t\tif (attr.kind === 'shorthand') {\n\t\t\tattr.kind = 'empty';\n\t\t\tattr.name = openingBracketReplace + attr.name + closingBracketReplace;\n\t\t}\n\n\t\tif (attr.name.includes('@')) {\n\t\t\tattr.name = attr.name.replace('@', atSignReplace);\n\t\t}\n\n\t\tif (attr.name.includes('.')) {\n\t\t\tattr.name = attr.name.replace('.', dotReplace);\n\t\t}\n\n\t\treturn attr;\n\t}\n}\n\n/**\n * Format the content of a style tag and print the entire element\n */\nfunction embedStyle(\n\tlang: supportedStyleLang,\n\tcontent: string,\n\tpath: AstPath,\n\tprint: printFn,\n\ttextToDoc: (text: string, options: object) => Doc,\n\toptions: ParserOptions\n) {\n\tconst isEmpty = /^\\s*$/.test(content);\n\n\tswitch (lang) {\n\t\tcase 'css':\n\t\tcase 'scss': {\n\t\t\tlet formattedStyles = wrapParserTryCatch(textToDoc, content, { ...options, parser: lang });\n\n\t\t\t// The css parser appends an extra indented hardline, which we want outside of the `indent()`,\n\t\t\t// so we remove the last element of the array\n\t\t\tformattedStyles = stripTrailingHardline(formattedStyles);\n\n\t\t\t// print\n\t\t\tconst attributes = path.map(print, 'attributes');\n\t\t\tconst openingTag = group(['<style', indent(group(attributes)), softline, '>']);\n\t\t\treturn [\n\t\t\t\topeningTag,\n\t\t\t\tindent([isEmpty ? '' : hardline, formattedStyles]),\n\t\t\t\tisEmpty ? '' : hardline,\n\t\t\t\t'</style>',\n\t\t\t];\n\t\t}\n\t\tcase 'sass': {\n\t\t\tconst lineEnding = options.endOfLine.toUpperCase() === 'CRLF' ? 'CRLF' : 'LF';\n\t\t\tconst sassOptions: Partial<SassFormatterConfig> = {\n\t\t\t\ttabSize: options.tabWidth,\n\t\t\t\tinsertSpaces: !options.useTabs,\n\t\t\t\tlineEnding,\n\t\t\t};\n\n\t\t\t// dedent the .sass, otherwise SassFormatter gets indentation wrong\n\t\t\tconst { result: raw } = manualDedent(content);\n\n\t\t\t// format\n\t\t\tconst formattedSassIndented = SassFormatter.Format(raw, sassOptions).trim();\n\n\t\t\t// print\n\t\t\tconst formattedSass = join(hardline, formattedSassIndented.split('\\n'));\n\t\t\tconst attributes = path.map(print, 'attributes');\n\t\t\tconst openingTag = group(['<style', indent(group(attributes)), softline, '>']);\n\t\t\treturn [\n\t\t\t\topeningTag,\n\t\t\t\tindent([isEmpty ? '' : hardline, formattedSass]),\n\t\t\t\tisEmpty ? '' : hardline,\n\t\t\t\t'</style>',\n\t\t\t];\n\t\t}\n\t}\n}\n","import { createRequire } from 'node:module';\nimport { Parser, Printer, SupportLanguage } from 'prettier';\nimport { createSyncFn } from 'synckit';\nimport { options } from './options';\nimport { print } from './printer';\nimport { embed } from './printer/embed';\n\nconst req = createRequire(import.meta.url);\nlet workerPath;\ntry {\n\tworkerPath = req.resolve('../workers/parse-worker.js');\n} catch (e) {\n\tworkerPath = req.resolve('prettier-plugin-astro/workers/parse-worker.js');\n}\nconst parse = createSyncFn(req.resolve(workerPath));\n\n// https://prettier.io/docs/en/plugins.html#languages\nexport const languages: Partial<SupportLanguage>[] = [\n\t{\n\t\tname: 'astro',\n\t\tparsers: ['astro'],\n\t\textensions: ['.astro'],\n\t\tvscodeLanguageIds: ['astro'],\n\t},\n];\n\n// https://prettier.io/docs/en/plugins.html#parsers\nexport const parsers: Record<string, Parser> = {\n\tastro: {\n\t\tparse: (source) => parse(source),\n\t\tastFormat: 'astro',\n\t\tlocStart: (node) => node.position.start.offset,\n\t\tlocEnd: (node) => node.position.end.offset,\n\t},\n};\n\n// https://prettier.io/docs/en/plugins.html#printers\nexport const printers: Record<string, Printer> = {\n\tastro: {\n\t\tprint,\n\t\tembed,\n\t},\n};\n\nconst defaultOptions = {\n\ttabWidth: 2,\n};\n\nexport { options, defaultOptions };\n"],"names":["req","createRequire","workerPath","createSyncFn","group","indent","join","line","softline","hardline","stripTrailingHardline","SassFormatter"],"mappings":"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"}