{"version":3,"names":["isInType","path","parent","type","parentPath","findParent","exportKind","GLOBAL_TYPES","WeakMap","NEEDS_EXPLICIT_ESM","PARSED_PARAMS","WeakSet","isGlobalType","scope","name","hasBinding","get","has","console","warn","registerGlobalType","programScope","add","safeRemove","ids","getBindingIdentifiers","Object","keys","binding","getBinding","identifier","removeBinding","opts","noScope","remove","declare","api","types","t","template","assertVersion","JSX_PRAGMA_REGEX","allowNamespaces","jsxPragma","jsxPragmaFrag","onlyRemoveTypeImports","optimizeConstEnums","allowDeclareFields","classMemberVisitors","field","node","buildCodeFrameError","value","decorators","definite","isClassPrivateProperty","accessibility","abstract","readonly","optional","typeAnnotation","override","method","constructor","classPath","assigns","paramPath","param","parameter","id","isIdentifier","isAssignmentPattern","left","push","statement","ast","cloneNode","replaceWith","registerBinding","injectInitialization","inherits","syntaxTypeScript","visitor","Pattern","visitPattern","Identifier","RestElement","Program","enter","state","file","fileJsxPragma","fileJsxPragmaFrag","set","Set","comments","comment","jsxMatches","exec","pragmaImportName","split","pragmaFragImportName","stmt","isImportDeclaration","program","importKind","specifier","specifiers","local","importsToRemove","specifiersLength","length","isAllSpecifiersElided","size","isImportTypeOnly","programPath","importPath","isExportDeclaration","isVariableDeclaration","isTSTypeAliasDeclaration","isTSDeclareFunction","isTSInterfaceDeclaration","isClassDeclaration","isTSEnumDeclaration","isTSModuleDeclaration","exit","sourceType","pushContainer","exportNamedDeclaration","ExportNamedDeclaration","source","every","isExportSpecifier","ExportSpecifier","ExportDefaultDeclaration","declaration","TSDeclareFunction","TSDeclareMethod","VariableDeclaration","VariableDeclarator","TSIndexSignature","ClassDeclaration","Class","typeParameters","superTypeParameters","implements","forEach","child","isClassMethod","isClassPrivateMethod","kind","isClassProperty","Function","returnType","params","shift","TSModuleDeclaration","transpileNamespace","TSInterfaceDeclaration","TSTypeAliasDeclaration","TSEnumDeclaration","const","transpileConstEnum","transpileEnum","TSImportEqualsDeclaration","isTSExternalModuleReference","moduleReference","expression","variableDeclaration","variableDeclarator","entityNameToExpr","TSExportAssignment","TSTypeAssertion","tsSatisfiesExpression","isTSAsExpression","isTSSatisfiesExpression","tsInstantiationExpression","CallExpression","OptionalCallExpression","NewExpression","JSXOpeningElement","TaggedTemplateExpression","isTSQualifiedName","memberExpression","right","referencePaths","sourceFileHasJsx","traverse","stop"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport syntaxTypeScript from \"@babel/plugin-syntax-typescript\";\nimport type { types as t } from \"@babel/core\";\nimport { injectInitialization } from \"@babel/helper-create-class-features-plugin\";\nimport type { Binding, NodePath, Scope } from \"@babel/traverse\";\nimport type { Options as SyntaxOptions } from \"@babel/plugin-syntax-typescript\";\n\nimport transpileConstEnum from \"./const-enum\";\nimport type { NodePathConstEnum } from \"./const-enum\";\nimport transpileEnum from \"./enum\";\nimport transpileNamespace from \"./namespace\";\n\nfunction isInType(path: NodePath) {\n  switch (path.parent.type) {\n    case \"TSTypeReference\":\n    case \"TSExpressionWithTypeArguments\":\n    case \"TSTypeQuery\":\n      return true;\n    case \"TSQualifiedName\":\n      return (\n        // `import foo = ns.bar` is transformed to `var foo = ns.bar` and should not be removed\n        path.parentPath.findParent(path => path.type !== \"TSQualifiedName\")\n          .type !== \"TSImportEqualsDeclaration\"\n      );\n    case \"ExportSpecifier\":\n      return (\n        // @ts-expect-error: DeclareExportDeclaration does not have `exportKind`\n        (path.parentPath as NodePath<t.ExportSpecifier>).parent.exportKind ===\n        \"type\"\n      );\n    default:\n      return false;\n  }\n}\n\nconst GLOBAL_TYPES = new WeakMap<Scope, Set<string>>();\n// Track programs which contain imports/exports of values, so that we can include\n// empty exports for programs that do not, but were parsed as modules. This allows\n// tools to infer unambiguously that results are ESM.\nconst NEEDS_EXPLICIT_ESM = new WeakMap();\nconst PARSED_PARAMS = new WeakSet();\n\nfunction isGlobalType({ scope }: NodePath, name: string) {\n  if (scope.hasBinding(name)) return false;\n  if (GLOBAL_TYPES.get(scope).has(name)) return true;\n\n  console.warn(\n    `The exported identifier \"${name}\" is not declared in Babel's scope tracker\\n` +\n      `as a JavaScript value binding, and \"@babel/plugin-transform-typescript\"\\n` +\n      `never encountered it as a TypeScript type declaration.\\n` +\n      `It will be treated as a JavaScript value.\\n\\n` +\n      `This problem is likely caused by another plugin injecting\\n` +\n      `\"${name}\" without registering it in the scope tracker. If you are the author\\n` +\n      ` of that plugin, please use \"scope.registerDeclaration(declarationPath)\".`,\n  );\n\n  return false;\n}\n\nfunction registerGlobalType(programScope: Scope, name: string) {\n  GLOBAL_TYPES.get(programScope).add(name);\n}\n\n// A hack to avoid removing the impl Binding when we remove the declare NodePath\nfunction safeRemove(path: NodePath) {\n  const ids = path.getBindingIdentifiers();\n  for (const name of Object.keys(ids)) {\n    const binding = path.scope.getBinding(name);\n    if (binding && binding.identifier === ids[name]) {\n      binding.scope.removeBinding(name);\n    }\n  }\n  path.opts.noScope = true;\n  path.remove();\n  path.opts.noScope = false;\n}\n\nexport interface Options extends SyntaxOptions {\n  /** @default true */\n  allowNamespaces?: boolean;\n  /** @default \"React.createElement\" */\n  jsxPragma?: string;\n  /** @default \"React.Fragment\" */\n  jsxPragmaFrag?: string;\n  onlyRemoveTypeImports?: boolean;\n  optimizeConstEnums?: boolean;\n  allowDeclareFields?: boolean;\n}\n\ntype ExtraNodeProps = {\n  declare?: unknown;\n  accessibility?: unknown;\n  abstract?: unknown;\n  optional?: unknown;\n  override?: unknown;\n};\n\nexport default declare((api, opts: Options) => {\n  // `@babel/core` and `@babel/types` are bundled in some downstream libraries.\n  // Ref: https://github.com/babel/babel/issues/15089\n  const { types: t, template } = api;\n\n  api.assertVersion(7);\n\n  const JSX_PRAGMA_REGEX = /\\*?\\s*@jsx((?:Frag)?)\\s+([^\\s]+)/;\n\n  const {\n    allowNamespaces = true,\n    jsxPragma = \"React.createElement\",\n    jsxPragmaFrag = \"React.Fragment\",\n    onlyRemoveTypeImports = false,\n    optimizeConstEnums = false,\n  } = opts;\n\n  if (!process.env.BABEL_8_BREAKING) {\n    // eslint-disable-next-line no-var\n    var { allowDeclareFields = false } = opts;\n  }\n\n  const classMemberVisitors = {\n    field(\n      path: NodePath<\n        (t.ClassPrivateProperty | t.ClassProperty) & ExtraNodeProps\n      >,\n    ) {\n      const { node } = path;\n\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!allowDeclareFields && node.declare) {\n          throw path.buildCodeFrameError(\n            `The 'declare' modifier is only allowed when the 'allowDeclareFields' option of ` +\n              `@babel/plugin-transform-typescript or @babel/preset-typescript is enabled.`,\n          );\n        }\n      }\n      if (node.declare) {\n        if (node.value) {\n          throw path.buildCodeFrameError(\n            `Fields with the 'declare' modifier cannot be initialized here, but only in the constructor`,\n          );\n        }\n        if (!node.decorators) {\n          path.remove();\n        }\n      } else if (node.definite) {\n        if (node.value) {\n          throw path.buildCodeFrameError(\n            `Definitely assigned fields cannot be initialized here, but only in the constructor`,\n          );\n        }\n        if (!process.env.BABEL_8_BREAKING) {\n          // keep the definitely assigned fields only when `allowDeclareFields` (equivalent of\n          // Typescript's `useDefineForClassFields`) is true\n          if (\n            !allowDeclareFields &&\n            !node.decorators &&\n            !t.isClassPrivateProperty(node)\n          ) {\n            path.remove();\n          }\n        }\n      } else if (!process.env.BABEL_8_BREAKING) {\n        if (\n          !allowDeclareFields &&\n          !node.value &&\n          !node.decorators &&\n          !t.isClassPrivateProperty(node)\n        ) {\n          path.remove();\n        }\n      }\n\n      if (node.accessibility) node.accessibility = null;\n      if (node.abstract) node.abstract = null;\n      if (node.readonly) node.readonly = null;\n      if (node.optional) node.optional = null;\n      if (node.typeAnnotation) node.typeAnnotation = null;\n      if (node.definite) node.definite = null;\n      if (node.declare) node.declare = null;\n      if (node.override) node.override = null;\n    },\n    method({ node }: NodePath<t.ClassMethod | t.ClassPrivateMethod>) {\n      if (node.accessibility) node.accessibility = null;\n      if (node.abstract) node.abstract = null;\n      if (node.optional) node.optional = null;\n      if (node.override) node.override = null;\n\n      // Rest handled by Function visitor\n    },\n    constructor(path: NodePath<t.ClassMethod>, classPath: NodePath<t.Class>) {\n      if (path.node.accessibility) path.node.accessibility = null;\n      // Collects parameter properties so that we can add an assignment\n      // for each of them in the constructor body\n      //\n      // We use a WeakSet to ensure an assignment for a parameter\n      // property is only added once. This is necessary for cases like\n      // using `transform-classes`, which causes this visitor to run\n      // twice.\n      const assigns = [];\n      const { scope } = path;\n      for (const paramPath of path.get(\"params\")) {\n        const param = paramPath.node;\n        if (param.type === \"TSParameterProperty\") {\n          const parameter = param.parameter;\n          if (PARSED_PARAMS.has(parameter)) continue;\n          PARSED_PARAMS.add(parameter);\n          let id;\n          if (t.isIdentifier(parameter)) {\n            id = parameter;\n          } else if (\n            t.isAssignmentPattern(parameter) &&\n            t.isIdentifier(parameter.left)\n          ) {\n            id = parameter.left;\n          } else {\n            throw paramPath.buildCodeFrameError(\n              \"Parameter properties can not be destructuring patterns.\",\n            );\n          }\n          assigns.push(template.statement.ast`\n          this.${t.cloneNode(id)} = ${t.cloneNode(id)}`);\n\n          paramPath.replaceWith(paramPath.get(\"parameter\"));\n          scope.registerBinding(\"param\", paramPath);\n        }\n      }\n      injectInitialization(classPath, path, assigns);\n    },\n  };\n\n  return {\n    name: \"transform-typescript\",\n    inherits: syntaxTypeScript,\n\n    visitor: {\n      //\"Pattern\" alias doesn't include Identifier or RestElement.\n      Pattern: visitPattern,\n      Identifier: visitPattern,\n      RestElement: visitPattern,\n\n      Program: {\n        enter(path, state) {\n          const { file } = state;\n          let fileJsxPragma = null;\n          let fileJsxPragmaFrag = null;\n          const programScope = path.scope;\n\n          if (!GLOBAL_TYPES.has(programScope)) {\n            GLOBAL_TYPES.set(programScope, new Set());\n          }\n\n          if (file.ast.comments) {\n            for (const comment of file.ast.comments) {\n              const jsxMatches = JSX_PRAGMA_REGEX.exec(comment.value);\n              if (jsxMatches) {\n                if (jsxMatches[1]) {\n                  // isFragment\n                  fileJsxPragmaFrag = jsxMatches[2];\n                } else {\n                  fileJsxPragma = jsxMatches[2];\n                }\n              }\n            }\n          }\n\n          let pragmaImportName = fileJsxPragma || jsxPragma;\n          if (pragmaImportName) {\n            [pragmaImportName] = pragmaImportName.split(\".\");\n          }\n\n          let pragmaFragImportName = fileJsxPragmaFrag || jsxPragmaFrag;\n          if (pragmaFragImportName) {\n            [pragmaFragImportName] = pragmaFragImportName.split(\".\");\n          }\n\n          // remove type imports\n          for (let stmt of path.get(\"body\")) {\n            if (stmt.isImportDeclaration()) {\n              if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {\n                NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);\n              }\n\n              if (stmt.node.importKind === \"type\") {\n                for (const specifier of stmt.node.specifiers) {\n                  registerGlobalType(programScope, specifier.local.name);\n                }\n                stmt.remove();\n                continue;\n              }\n\n              const importsToRemove: Set<NodePath<t.Node>> = new Set();\n              const specifiersLength = stmt.node.specifiers.length;\n              const isAllSpecifiersElided = () =>\n                specifiersLength > 0 &&\n                specifiersLength === importsToRemove.size;\n\n              for (const specifier of stmt.node.specifiers) {\n                if (\n                  specifier.type === \"ImportSpecifier\" &&\n                  specifier.importKind === \"type\"\n                ) {\n                  registerGlobalType(programScope, specifier.local.name);\n                  const binding = stmt.scope.getBinding(specifier.local.name);\n                  if (binding) {\n                    importsToRemove.add(binding.path);\n                  }\n                }\n              }\n\n              // If onlyRemoveTypeImports is `true`, only remove type-only imports\n              // and exports introduced in TypeScript 3.8.\n              if (onlyRemoveTypeImports) {\n                NEEDS_EXPLICIT_ESM.set(path.node, false);\n              } else {\n                // Note: this will allow both `import { } from \"m\"` and `import \"m\";`.\n                // In TypeScript, the former would be elided.\n                if (stmt.node.specifiers.length === 0) {\n                  NEEDS_EXPLICIT_ESM.set(path.node, false);\n                  continue;\n                }\n\n                for (const specifier of stmt.node.specifiers) {\n                  const binding = stmt.scope.getBinding(specifier.local.name);\n\n                  // The binding may not exist if the import node was explicitly\n                  // injected by another plugin. Currently core does not do a good job\n                  // of keeping scope bindings synchronized with the AST. For now we\n                  // just bail if there is no binding, since chances are good that if\n                  // the import statement was injected then it wasn't a typescript type\n                  // import anyway.\n                  if (binding && !importsToRemove.has(binding.path)) {\n                    if (\n                      isImportTypeOnly({\n                        binding,\n                        programPath: path,\n                        pragmaImportName,\n                        pragmaFragImportName,\n                      })\n                    ) {\n                      importsToRemove.add(binding.path);\n                    } else {\n                      NEEDS_EXPLICIT_ESM.set(path.node, false);\n                    }\n                  }\n                }\n              }\n\n              if (isAllSpecifiersElided()) {\n                stmt.remove();\n              } else {\n                for (const importPath of importsToRemove) {\n                  importPath.remove();\n                }\n              }\n\n              continue;\n            }\n\n            if (stmt.isExportDeclaration()) {\n              stmt = stmt.get(\"declaration\");\n            }\n\n            if (stmt.isVariableDeclaration({ declare: true })) {\n              for (const name of Object.keys(stmt.getBindingIdentifiers())) {\n                registerGlobalType(programScope, name);\n              }\n            } else if (\n              stmt.isTSTypeAliasDeclaration() ||\n              (stmt.isTSDeclareFunction() && stmt.get(\"id\").isIdentifier()) ||\n              stmt.isTSInterfaceDeclaration() ||\n              stmt.isClassDeclaration({ declare: true }) ||\n              stmt.isTSEnumDeclaration({ declare: true }) ||\n              (stmt.isTSModuleDeclaration({ declare: true }) &&\n                stmt.get(\"id\").isIdentifier())\n            ) {\n              registerGlobalType(\n                programScope,\n                (stmt.node.id as t.Identifier).name,\n              );\n            }\n          }\n        },\n        exit(path) {\n          if (\n            path.node.sourceType === \"module\" &&\n            NEEDS_EXPLICIT_ESM.get(path.node)\n          ) {\n            // If there are no remaining value exports, this file can no longer\n            // be inferred to be ESM. Leave behind an empty export declaration\n            // so it can be.\n            path.pushContainer(\"body\", t.exportNamedDeclaration());\n          }\n        },\n      },\n\n      ExportNamedDeclaration(path, state) {\n        if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {\n          NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);\n        }\n\n        if (path.node.exportKind === \"type\") {\n          path.remove();\n          return;\n        }\n\n        // remove export declaration that is filled with type-only specifiers\n        //   export { type A1, type A2 } from \"a\";\n        if (\n          path.node.source &&\n          path.node.specifiers.length > 0 &&\n          path.node.specifiers.every(\n            specifier =>\n              specifier.type === \"ExportSpecifier\" &&\n              specifier.exportKind === \"type\",\n          )\n        ) {\n          path.remove();\n          return;\n        }\n\n        // remove export declaration if it's exporting only types\n        // This logic is needed when exportKind is \"value\", because\n        // currently the \"type\" keyword is optional.\n        // TODO:\n        // Also, currently @babel/parser sets exportKind to \"value\" for\n        //   export interface A {}\n        //   etc.\n        if (\n          !path.node.source &&\n          path.node.specifiers.length > 0 &&\n          path.node.specifiers.every(\n            specifier =>\n              t.isExportSpecifier(specifier) &&\n              isGlobalType(path, specifier.local.name),\n          )\n        ) {\n          path.remove();\n          return;\n        }\n\n        NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);\n      },\n\n      ExportSpecifier(path) {\n        // remove type exports\n        type Parent = t.ExportDeclaration & { source?: t.StringLiteral };\n        const parent = path.parent as Parent;\n        if (\n          (!parent.source && isGlobalType(path, path.node.local.name)) ||\n          path.node.exportKind === \"type\"\n        ) {\n          path.remove();\n        }\n      },\n\n      ExportDefaultDeclaration(path, state) {\n        if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {\n          NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);\n        }\n\n        // remove whole declaration if it's exporting a TS type\n        if (\n          t.isIdentifier(path.node.declaration) &&\n          isGlobalType(path, path.node.declaration.name)\n        ) {\n          path.remove();\n\n          return;\n        }\n\n        NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);\n      },\n\n      TSDeclareFunction(path) {\n        safeRemove(path);\n      },\n\n      TSDeclareMethod(path) {\n        safeRemove(path);\n      },\n\n      VariableDeclaration(path) {\n        if (path.node.declare) {\n          safeRemove(path);\n        }\n      },\n\n      VariableDeclarator({ node }) {\n        if (node.definite) node.definite = null;\n      },\n\n      TSIndexSignature(path) {\n        path.remove();\n      },\n\n      ClassDeclaration(path) {\n        const { node } = path;\n        if (node.declare) {\n          safeRemove(path);\n        }\n      },\n\n      Class(path) {\n        const { node }: { node: typeof path.node & ExtraNodeProps } = path;\n\n        if (node.typeParameters) node.typeParameters = null;\n        if (node.superTypeParameters) node.superTypeParameters = null;\n        if (node.implements) node.implements = null;\n        if (node.abstract) node.abstract = null;\n\n        // Similar to the logic in `transform-flow-strip-types`, we need to\n        // handle `TSParameterProperty` and `ClassProperty` here because the\n        // class transform would transform the class, causing more specific\n        // visitors to not run.\n        path.get(\"body.body\").forEach(child => {\n          if (child.isClassMethod() || child.isClassPrivateMethod()) {\n            if (child.node.kind === \"constructor\") {\n              classMemberVisitors.constructor(\n                // @ts-expect-error A constructor must not be a private method\n                child,\n                path,\n              );\n            } else {\n              classMemberVisitors.method(child);\n            }\n          } else if (\n            child.isClassProperty() ||\n            child.isClassPrivateProperty()\n          ) {\n            classMemberVisitors.field(child);\n          }\n        });\n      },\n\n      Function(path) {\n        const { node } = path;\n        if (node.typeParameters) node.typeParameters = null;\n        if (node.returnType) node.returnType = null;\n\n        const params = node.params;\n        if (params.length > 0 && t.isIdentifier(params[0], { name: \"this\" })) {\n          params.shift();\n        }\n      },\n\n      TSModuleDeclaration(path) {\n        transpileNamespace(path, allowNamespaces);\n      },\n\n      TSInterfaceDeclaration(path) {\n        path.remove();\n      },\n\n      TSTypeAliasDeclaration(path) {\n        path.remove();\n      },\n\n      TSEnumDeclaration(path) {\n        if (optimizeConstEnums && path.node.const) {\n          transpileConstEnum(path as NodePathConstEnum, t);\n        } else {\n          transpileEnum(path, t);\n        }\n      },\n\n      TSImportEqualsDeclaration(path: NodePath<t.TSImportEqualsDeclaration>) {\n        if (t.isTSExternalModuleReference(path.node.moduleReference)) {\n          // import alias = require('foo');\n          throw path.buildCodeFrameError(\n            `\\`import ${path.node.id.name} = require('${path.node.moduleReference.expression.value}')\\` ` +\n              \"is not supported by @babel/plugin-transform-typescript\\n\" +\n              \"Please consider using \" +\n              `\\`import ${path.node.id.name} from '${path.node.moduleReference.expression.value}';\\` alongside ` +\n              \"Typescript's --allowSyntheticDefaultImports option.\",\n          );\n        }\n\n        // import alias = Namespace;\n        path.replaceWith(\n          t.variableDeclaration(\"var\", [\n            t.variableDeclarator(\n              path.node.id,\n              entityNameToExpr(path.node.moduleReference),\n            ),\n          ]),\n        );\n      },\n\n      TSExportAssignment(path) {\n        throw path.buildCodeFrameError(\n          \"`export =` is not supported by @babel/plugin-transform-typescript\\n\" +\n            \"Please consider using `export <value>;`.\",\n        );\n      },\n\n      TSTypeAssertion(path) {\n        path.replaceWith(path.node.expression);\n      },\n\n      [`TSAsExpression${\n        // Added in Babel 7.20.0\n        t.tsSatisfiesExpression ? \"|TSSatisfiesExpression\" : \"\"\n      }`](path: NodePath<t.TSAsExpression | t.TSSatisfiesExpression>) {\n        let { node }: { node: t.Expression } = path;\n        do {\n          node = node.expression;\n        } while (t.isTSAsExpression(node) || t.isTSSatisfiesExpression?.(node));\n        path.replaceWith(node);\n      },\n\n      [process.env.BABEL_8_BREAKING\n        ? \"TSNonNullExpression|TSInstantiationExpression\"\n        : /* This has been introduced in Babel 7.18.0\n             We use api.types.* and not t.* for feature detection,\n             because the Babel version that is running this plugin\n             (where we check if the visitor is valid) might be different\n             from the Babel version that we resolve with `import \"@babel/core\"`.\n             This happens, for example, with Next.js that bundled `@babel/core`\n             but allows loading unbundled plugin (which cannot obviously import\n             the bundled `@babel/core` version).\n           */\n        api.types.tsInstantiationExpression\n        ? \"TSNonNullExpression|TSInstantiationExpression\"\n        : \"TSNonNullExpression\"](\n        path: NodePath<t.TSNonNullExpression | t.TSExpressionWithTypeArguments>,\n      ) {\n        path.replaceWith(path.node.expression);\n      },\n\n      CallExpression(path) {\n        path.node.typeParameters = null;\n      },\n\n      OptionalCallExpression(path) {\n        path.node.typeParameters = null;\n      },\n\n      NewExpression(path) {\n        path.node.typeParameters = null;\n      },\n\n      JSXOpeningElement(path) {\n        path.node.typeParameters = null;\n      },\n\n      TaggedTemplateExpression(path) {\n        path.node.typeParameters = null;\n      },\n    },\n  };\n\n  function entityNameToExpr(node: t.TSEntityName): t.Expression {\n    if (t.isTSQualifiedName(node)) {\n      return t.memberExpression(entityNameToExpr(node.left), node.right);\n    }\n\n    return node;\n  }\n\n  function visitPattern({\n    node,\n  }: NodePath<t.Identifier | t.Pattern | t.RestElement>) {\n    if (node.typeAnnotation) node.typeAnnotation = null;\n    if (t.isIdentifier(node) && node.optional) node.optional = null;\n    // 'access' and 'readonly' are only for parameter properties, so constructor visitor will handle them.\n  }\n\n  function isImportTypeOnly({\n    binding,\n    programPath,\n    pragmaImportName,\n    pragmaFragImportName,\n  }: {\n    binding: Binding;\n    programPath: NodePath<t.Program>;\n    pragmaImportName: string;\n    pragmaFragImportName: string;\n  }) {\n    for (const path of binding.referencePaths) {\n      if (!isInType(path)) {\n        return false;\n      }\n    }\n\n    if (\n      binding.identifier.name !== pragmaImportName &&\n      binding.identifier.name !== pragmaFragImportName\n    ) {\n      return true;\n    }\n\n    // \"React\" or the JSX pragma is referenced as a value if there are any JSX elements/fragments in the code.\n    let sourceFileHasJsx = false;\n    programPath.traverse({\n      \"JSXElement|JSXFragment\"(path) {\n        sourceFileHasJsx = true;\n        path.stop();\n      },\n    });\n    return !sourceFileHasJsx;\n  }\n});\n"],"mappings":"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"}