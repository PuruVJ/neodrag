{"version":3,"file":"tsconfig-resolver.cjs.development.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/index.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { promises, readFileSync, statSync } from 'fs';\nimport {\n  ParsedPath,\n  dirname,\n  join,\n  parse as pathParse,\n  win32 as pathWin32,\n  resolve,\n} from 'path';\n\nimport JSON5 from 'json5';\nimport resolvePackageNpm from 'resolve';\nimport StripBom from 'strip-bom';\nimport { Except, SetOptional, TsConfigJson } from 'type-fest';\n\nconst { readFile, stat } = promises;\n\n/** The default search name used. */\nexport const DEFAULT_SEARCH_NAME = 'tsconfig.json';\n\ninterface IsNodeModuleRequireOptions {\n  /**\n   * Whether to simulate windows.\n   *\n   * @default undefined\n   */\n  windows?: boolean;\n}\n\ninterface ParseFilePath {\n  /**\n   * True when the file path provided is an absolute path.\n   */\n  isAbsolute: boolean;\n\n  /**\n   * True when the file path potentially refers to a node module package.\n   */\n  isPackage: boolean;\n}\n\n/**\n * Extends the default node file parser and determines whether the path provided\n * should be resolved from the node modules or directly from the provided path.\n */\nconst parseFilePath = (\n  file: string,\n  { windows }: IsNodeModuleRequireOptions = {},\n): ParsedPath & ParseFilePath => {\n  const isWindows = windows ?? process.platform === 'win32';\n  const parser = isWindows ? pathWin32.parse : pathParse;\n  const parsedPath = parser(file);\n\n  return {\n    ...parsedPath,\n    isAbsolute: Boolean(parsedPath.root),\n    isPackage: !file.startsWith('.') && !parsedPath.root,\n  };\n};\n\n/**\n * The reason that the tsconfig exist flag is false.\n */\nexport const TsConfigErrorReason = {\n  /**\n   * The `tsconfig` file could not be found.\n   */\n  NotFound: 'not-found',\n\n  /**\n   * The file was found but the configuration was invalid.\n   */\n  InvalidConfig: 'invalid-config',\n} as const;\n\ninterface TsConfigFailure {\n  /**\n   * Whether or not the configuration could be loaded.\n   *\n   * - `false` when no tsconfig could be found.\n   */\n  exists: false;\n\n  /**\n   * The configuration object.\n   *\n   * - `undefined` when the tsconfig resolver failed and no configuration was\n   *   found.\n   */\n  config?: undefined;\n\n  /**\n   * The extendedPaths array.\n   *\n   * - `undefined` when the tsconfig resolver failed to load a valid\n   *   configuration.\n   */\n  extendedPaths?: undefined;\n\n  /**\n   * The `isCircular` config flag.\n   *\n   * - `undefined` when the tsconfig resolver failed to load a valid\n   *   configuration.\n   */\n  isCircular?: undefined;\n}\n\nexport interface TsConfigFailureNotFound extends TsConfigFailure {\n  /**\n   * The reason for failure.\n   *\n   * - `TsConfigErrorReason.NotFound` when the config failure is because the\n   *   filename has not been found.\n   */\n  reason: typeof TsConfigErrorReason.NotFound;\n\n  /**\n   * The absolute path to the `tsconfig.json` or given filename.\n   *\n   * - `undefined` when not found.\n   */\n  path?: undefined;\n}\n\nexport interface TsConfigFailureInvalidConfig extends TsConfigFailure {\n  /**\n   * - `TsConfigErrorReason.InvalidConfig` when the config failure is because of\n   *   an invalid config.\n   */\n  reason: typeof TsConfigErrorReason.InvalidConfig;\n\n  /**\n   * - `string` when config json is invalid.\n   */\n  path: string;\n}\n\nexport interface TsConfigResultSuccess {\n  /**\n   * - `true` when a valid tsconfig file has been found and successfully loaded.\n   */\n  exists: true;\n\n  /**\n   * - `string` when a valid tsconfig has been loaded.\n   */\n  path: string;\n\n  /**\n   * - `string[]` of absolute paths to resolved tsconfig files when extended\n   *   paths are encountered.\n   * - `[]` an empty array when no extended paths were encountered.\n   * - `[]` an empty array when `ignoreExtends` options is set to true.\n   */\n  extendedPaths: string[];\n\n  /**\n   * - `true` when a circular `extends` property was encountered (an extends\n   *   path chain that references itself).\n   * - `false` when no circular `extends` property was encountered.\n   */\n  isCircular: boolean;\n\n  /**\n   * - `TsConfigJson` when the resolved tsconfig has been found and loaded.\n   */\n  config: TsConfigJson;\n\n  /**\n   * - `undefined` when no failure has occurred.\n   */\n  reason?: undefined;\n}\n\n/**\n * The result of loading the tsconfig. If the exists property is `true` then\n * there will be a path and config property available.\n */\nexport type TsConfigResult =\n  | TsConfigFailureNotFound\n  | TsConfigFailureInvalidConfig\n  | TsConfigResultSuccess;\n\nexport interface TsConfigLoaderParams {\n  getEnv: (key: string) => string | undefined;\n  cwd: string;\n  loadSync?(cwd: string, searchName?: string): TsConfigResult;\n}\n\n/**\n * Synchronously walk up the path until a `tsconfig` is located.\n */\nconst walkForTsConfigSync = (directory: string): string | undefined => {\n  const configPath = join(directory, './tsconfig.json');\n  if (isFileOrDirectorySync(configPath)) {\n    return configPath;\n  }\n\n  const parentDirectory = join(directory, '../');\n\n  // If we reached the top\n  if (directory === parentDirectory) {\n    return undefined;\n  }\n\n  return walkForTsConfigSync(parentDirectory);\n};\n\n/**\n * Walk up the path until a `tsconfig` is located.\n */\nconst walkForTsConfig = async (\n  directory: string,\n): Promise<string | undefined> => {\n  const configPath = join(directory, './tsconfig.json');\n  if (await isFileOrDirectory(configPath)) {\n    return configPath;\n  }\n\n  // Step up one level in the directory path.\n  const parentDirectory = join(directory, '../');\n\n  // If we reached the top\n  if (directory === parentDirectory) {\n    return undefined;\n  }\n\n  return walkForTsConfig(parentDirectory);\n};\n\n/**\n * Synchronously check that the passed string is a directory.\n */\nconst isDirectorySync = (directory: string) => {\n  try {\n    return statSync(directory).isDirectory();\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Check that the passed string is a directory.\n */\nconst isDirectory = async (directory: string) => {\n  try {\n    const stats = await stat(directory);\n    return stats.isDirectory();\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Synchronously check that the passed filePath is a valid file.\n */\nconst isFileSync = (filePath: string) => {\n  try {\n    return statSync(filePath).isFile();\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Check that the passed filePath is a valid file.\n */\nconst isFile = async (filePath: string) => {\n  try {\n    const stats = await stat(filePath);\n    return stats.isFile();\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Synchronously check that the provided `filePath` is a file or directory.\n */\nconst isFileOrDirectorySync = (filePath: string) =>\n  isFileSync(filePath) || isDirectorySync(filePath);\n\n/**\n * Check that the provided `filePath` is a file or directory.\n */\nconst isFileOrDirectory = async (filePath: string) => {\n  if (await isFile(filePath)) {\n    return true;\n  }\n\n  if (await isDirectory(filePath)) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Synchronously resolves an npm package by the given name.\n */\nconst resolvePackageSync = (name: string, basedir?: string) => {\n  try {\n    return resolvePackageNpm.sync(name, {\n      basedir,\n      extensions: ['.json', '.js'],\n    });\n  } catch {\n    return;\n  }\n};\n\n/**\n * Resolves an npm package by the given name.\n */\nconst resolvePackage = (name: string, basedir?: string) => {\n  return new Promise<string | undefined>((resolve, reject) => {\n    resolvePackageNpm(\n      name,\n      {\n        basedir,\n        extensions: ['.json', '.js'],\n      },\n      (error, resolved) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(resolved);\n        }\n      },\n    );\n  });\n};\n\n/**\n * Synchronously checks a filePath exists and if it can be resolved.\n */\nconst resolveFilePathSync = (\n  searchName: string,\n  filePath?: string,\n): string | undefined => {\n  const cwd = process.cwd();\n  if (!filePath) {\n    return;\n  }\n\n  let resolvedPath: string | undefined;\n\n  if (filePath.startsWith('npm:')) {\n    resolvedPath = resolvePackageSync(filePath.replace('npm:', ''), cwd);\n  } else {\n    resolvedPath = resolve(cwd, filePath);\n  }\n\n  if (!resolvedPath || !isDirectorySync(resolvedPath)) {\n    return resolvedPath;\n  }\n\n  return resolve(resolvedPath, searchName);\n};\n\n/**\n * When a filePath exists check if it can be resolved.\n */\nconst resolveFilePath = async (\n  searchName: string,\n  filePath?: string,\n): Promise<string | undefined> => {\n  const cwd = process.cwd();\n  if (!filePath) {\n    return;\n  }\n\n  let resolvedPath: string | undefined;\n\n  if (filePath.startsWith('npm:')) {\n    resolvedPath = await resolvePackage(filePath.replace('npm:', ''), cwd);\n  } else {\n    resolvedPath = resolve(cwd, filePath);\n  }\n\n  if (!resolvedPath || !(await isDirectory(resolvedPath))) {\n    return resolvedPath;\n  }\n\n  return resolve(resolvedPath, searchName);\n};\n\n/**\n * Get the desired path to the configuration.\n */\nconst resolveConfigPathSync = (\n  cwd: string,\n  searchName: string,\n  filePath?: string,\n): string | undefined => {\n  const resolvedFilePath = resolveFilePathSync(searchName, filePath);\n  if (resolvedFilePath) {\n    return resolvedFilePath;\n  }\n\n  if (searchName !== DEFAULT_SEARCH_NAME) {\n    const resolvedSearchName = resolve(cwd, searchName);\n    const absolutePath = isDirectorySync(resolvedSearchName)\n      ? resolve(resolvedSearchName, 'tsconfig.json')\n      : resolvedSearchName;\n\n    return isFileSync(absolutePath) ? absolutePath : undefined;\n  }\n\n  if (isFileSync(cwd)) {\n    return resolve(cwd);\n  }\n\n  const configAbsolutePath = walkForTsConfigSync(cwd);\n  return configAbsolutePath ? resolve(configAbsolutePath) : undefined;\n};\n\n/**\n * Get the desired path to the configuration.\n */\nconst resolveConfigPath = async (\n  cwd: string,\n  searchName: string,\n  filePath?: string,\n): Promise<string | undefined> => {\n  const resolvedFilePath = await resolveFilePath(searchName, filePath);\n\n  if (resolvedFilePath) {\n    return resolvedFilePath;\n  }\n\n  if (searchName !== DEFAULT_SEARCH_NAME) {\n    const resolvedSearchName = resolve(cwd, searchName);\n    const absolutePath = (await isDirectory(resolvedSearchName))\n      ? resolve(resolvedSearchName, 'tsconfig.json')\n      : resolvedSearchName;\n\n    return (await isFile(absolutePath)) ? absolutePath : undefined;\n  }\n\n  if (await isFile(cwd)) {\n    return resolve(cwd);\n  }\n\n  const configAbsolutePath = await walkForTsConfig(cwd);\n  return configAbsolutePath ? resolve(configAbsolutePath) : undefined;\n};\n\n/**\n * Loads the `jsonString` and returns it as a TsConfigJson object.\n */\nconst parseTsConfigJson = (jsonString: string): TsConfigJson | undefined => {\n  try {\n    const json = JSON5.parse(jsonString);\n    return json && typeof json === 'object' ? json : undefined;\n  } catch {\n    return undefined;\n  }\n};\n\n/**\n * Synchronously loads a tsconfig file while also resolving the `extends` path.\n */\nconst loadTsConfigSync = (\n  configFilePath: string,\n  extendedPaths: string[],\n  ignoreExtends = false,\n): TsConfigJson | undefined => {\n  if (!isFileOrDirectorySync(configFilePath)) return undefined;\n\n  const configString = readFileSync(configFilePath, 'utf8');\n  const jsonString = StripBom(configString);\n  const config = parseTsConfigJson(jsonString);\n  let extendedConfig = config?.extends;\n\n  if (!config || !extendedConfig || ignoreExtends) return config;\n\n  let base: TsConfigJson;\n\n  if (parseFilePath(extendedConfig).isPackage) {\n    const newConfigPath = resolvePackageSync(extendedConfig);\n\n    if (!newConfigPath) {\n      return config;\n    } else if (isDirectorySync(newConfigPath)) {\n      extendedConfig = join(newConfigPath, DEFAULT_SEARCH_NAME);\n    } else if (isFileSync(newConfigPath)) {\n      extendedConfig = newConfigPath;\n    } else if (isFileSync(`${newConfigPath}.json`)) {\n      extendedConfig = `${newConfigPath}.json`;\n    }\n\n    if (extendedPaths.includes(extendedConfig)) {\n      return config;\n    }\n\n    extendedPaths.push(extendedConfig);\n    base = loadTsConfigSync(extendedConfig, extendedPaths) ?? {};\n  } else {\n    if (!extendedConfig.endsWith('.json')) {\n      extendedConfig += '.json';\n    }\n\n    const currentDir = dirname(configFilePath);\n    const extendedConfigPath = join(currentDir, extendedConfig);\n\n    if (extendedPaths.includes(extendedConfigPath)) {\n      return config;\n    }\n\n    extendedPaths.push(extendedConfigPath);\n    base = loadTsConfigSync(extendedConfigPath, extendedPaths) ?? {};\n  }\n\n  // baseUrl should be interpreted as relative to the base tsconfig, but we need\n  // to update it so it is relative to the original tsconfig being loaded\n  if (base?.compilerOptions?.baseUrl) {\n    const extendsDir = dirname(extendedConfig);\n    base.compilerOptions.baseUrl = join(\n      extendsDir,\n      base.compilerOptions.baseUrl,\n    );\n  }\n\n  return {\n    ...base,\n    ...config,\n    compilerOptions: {\n      ...base.compilerOptions,\n      ...config.compilerOptions,\n    },\n  };\n};\n\n/**\n * Loads a tsconfig file while also resolving the `extends` path.\n */\nconst loadTsConfig = async (\n  configFilePath: string,\n  extendedPaths: string[],\n  ignoreExtends = false,\n): Promise<TsConfigJson | undefined> => {\n  if (!(await isFileOrDirectory(configFilePath))) return undefined;\n\n  const configString = await readFile(configFilePath, 'utf8');\n  const jsonString = StripBom(configString);\n  const config = parseTsConfigJson(jsonString);\n  let extendedConfig = config?.extends;\n\n  if (!config || !extendedConfig || ignoreExtends) return config;\n\n  let base: TsConfigJson;\n\n  if (parseFilePath(extendedConfig).isPackage) {\n    const newConfigPath = await resolvePackage(extendedConfig);\n\n    if (!newConfigPath) {\n      return config;\n    } else if (await isDirectory(newConfigPath)) {\n      extendedConfig = join(newConfigPath, DEFAULT_SEARCH_NAME);\n    } else if (await isFile(newConfigPath)) {\n      extendedConfig = newConfigPath;\n    } else if (await isFile(`${newConfigPath}.json`)) {\n      extendedConfig = `${newConfigPath}.json`;\n    }\n\n    if (extendedPaths.includes(extendedConfig)) {\n      return config;\n    }\n\n    extendedPaths.push(extendedConfig);\n    base = (await loadTsConfig(extendedConfig, extendedPaths)) ?? {};\n  } else {\n    if (!extendedConfig.endsWith('.json')) {\n      extendedConfig += '.json';\n    }\n\n    const currentDir = dirname(configFilePath);\n    const extendedConfigPath = join(currentDir, extendedConfig);\n\n    if (extendedPaths.includes(extendedConfigPath)) {\n      return config;\n    }\n\n    extendedPaths.push(extendedConfigPath);\n    base = (await loadTsConfig(extendedConfigPath, extendedPaths)) ?? {};\n  }\n\n  // baseUrl should be interpreted as relative to the base tsconfig, but we need\n  // to update it so it is relative to the original tsconfig being loaded\n  if (base?.compilerOptions?.baseUrl) {\n    const extendsDir = dirname(extendedConfig);\n    base.compilerOptions.baseUrl = join(\n      extendsDir,\n      base.compilerOptions.baseUrl,\n    );\n  }\n\n  return {\n    ...base,\n    ...config,\n    compilerOptions: {\n      ...base.compilerOptions,\n      ...config.compilerOptions,\n    },\n  };\n};\n\nexport interface TsConfigResolverOptions {\n  /**\n   * The absolute directory to start resolving from.\n   *\n   * @default `process.cwd()`\n   */\n  cwd?: string;\n\n  /**\n   * The tsconfig file name to search for. This is where the `TsConfigJson`\n   * configuration object will be loaded from.\n   *\n   * @default 'tsconfig.json'\n   */\n  searchName?: string;\n\n  /**\n   * A direct path to the tsconfig file you would like to load. The path will be\n   * relative to `cwd`. If it leads to a directory then the `searchName` will be\n   * appended.\n   *\n   * This also supports the `npm:` prefix which will find the given npm package\n   * directory, if it is installed.\n   *\n   * @default undefined\n   */\n  filePath?: string | undefined;\n\n  /**\n   * The caching strategy to use. `'never'` or `'always'` or `'directory'` or\n   * `true` or `false`.\n   *\n   * `true` is the same as `'always'`\n   * `false` is the same as `'never'`\n   *\n   * @default 'never'\n   *\n   * @remarks\n   *\n   * Sometimes you'll want to run this module several times during runtime but\n   * it can be slow and expensive walk up the file tree for the tsconfig value\n   * every time.\n   *\n   * To help prevent unnecessary lookups there are custom caching strategies\n   * available. See {@link CacheStrategy}.\n   */\n  cache?: CacheStrategyType | boolean;\n\n  /**\n   * When true will not automatically populate the `extends` argument. This is\n   * useful if all you want is the json object and not the fully resolved\n   * configuration.\n   *\n   * @default false\n   */\n  ignoreExtends?: boolean;\n}\n\ntype TsConfigResolverParams = SetOptional<\n  Required<Except<TsConfigResolverOptions, 'cache'>>,\n  'filePath'\n> & { cache: CacheStrategyType };\n\nexport const CacheStrategy = {\n  /**\n   * Caching never happens and the returned value is always recalculated.\n   */\n  Never: 'never',\n\n  /**\n   * The first time the `tsconfigResolver` method is run it will save a cached\n   * value (by `searchName`) which will be returned every time after that. This\n   * value will always be the same.\n   */\n  Always: 'always',\n\n  /**\n   * The cache will be used when the same directory (and searchName) is being\n   * searched.\n   */\n  Directory: 'directory',\n} as const;\n\n/**\n * The available cache strategies as a union of strings.\n */\nexport type CacheStrategyType = typeof CacheStrategy[keyof typeof CacheStrategy];\n\nconst cacheObject = {\n  [CacheStrategy.Always]: new Map<string, TsConfigResult>(),\n  [CacheStrategy.Directory]: new Map<string, TsConfigResult>(),\n};\n\n/**\n * Converts a boolean or string type into a cache strategy.\n */\nconst convertCacheToStrategy = (value: boolean | CacheStrategyType) =>\n  value === false\n    ? CacheStrategy.Never\n    : value === true\n    ? CacheStrategy.Always\n    : value;\n\n/**\n * Get the key to store in the cache.\n */\nconst cacheKey = ({\n  cache,\n  cwd,\n  searchName,\n  ignoreExtends,\n}: Exclude<TsConfigResolverParams, 'filePath'>) =>\n  cache === CacheStrategy.Always\n    ? `${searchName} - ${ignoreExtends}`\n    : `${join(cwd, searchName)} - ${ignoreExtends}`;\n\n/**\n * Based on the options passed in, retrieve the value from the cache or return\n * undefined if the value still needs to be calculated.\n */\nconst getCache = (\n  options: TsConfigResolverParams,\n): TsConfigResult | undefined => {\n  if (options.cache === CacheStrategy.Always) {\n    return cacheObject[CacheStrategy.Always].get(cacheKey(options));\n  }\n\n  if (options.cache === CacheStrategy.Directory) {\n    return cacheObject[CacheStrategy.Always].get(cacheKey(options));\n  }\n\n  return undefined;\n};\n\n/**\n * Updates the cache with the provided result.\n */\nconst updateCache = (\n  options: TsConfigResolverParams,\n  result: TsConfigResult,\n): void => {\n  if (options.cache === CacheStrategy.Always) {\n    cacheObject[CacheStrategy.Always].set(cacheKey(options), result);\n  } else if (options.cache === CacheStrategy.Directory) {\n    cacheObject[CacheStrategy.Always].set(cacheKey(options), result);\n  }\n};\n\n/**\n * Clears the cache.\n */\nexport const clearCache = () => {\n  for (const map of Object.values(cacheObject)) {\n    map.clear();\n  }\n};\n\n/**\n * Synchronously get the nearest tsconfig by walking up the directory.\n */\nconst getTsConfigResultSync = ({\n  cwd,\n  searchName,\n  filePath,\n  ignoreExtends,\n}: Except<TsConfigResolverParams, 'cache'>): TsConfigResult => {\n  const configPath = resolveConfigPathSync(cwd, searchName, filePath);\n\n  if (!configPath) {\n    return {\n      exists: false,\n      reason: TsConfigErrorReason.NotFound,\n    };\n  }\n\n  // This path will be mutated to include all paths that have been found.\n  const extendedPaths: string[] = [];\n\n  const config = loadTsConfigSync(configPath, extendedPaths, ignoreExtends);\n\n  if (!config) {\n    return {\n      exists: false,\n      reason: TsConfigErrorReason.InvalidConfig,\n      path: configPath,\n    };\n  }\n\n  return {\n    exists: true,\n    path: configPath,\n    extendedPaths,\n    config,\n    isCircular: extendedPaths.includes(configPath),\n  };\n};\n\n/**\n * Get the nearest tsconfig by walking up the directory.\n */\nconst getTsConfigResult = async ({\n  cwd,\n  searchName,\n  filePath,\n  ignoreExtends,\n}: Except<TsConfigResolverParams, 'cache'>): Promise<TsConfigResult> => {\n  const configPath = await resolveConfigPath(cwd, searchName, filePath);\n\n  if (!configPath) {\n    return {\n      exists: false,\n      reason: TsConfigErrorReason.NotFound,\n    };\n  }\n\n  // This path will be mutated to include all paths that have been found.\n  const extendedPaths: string[] = [];\n\n  const config = await loadTsConfig(configPath, extendedPaths, ignoreExtends);\n\n  if (!config) {\n    return {\n      exists: false,\n      reason: TsConfigErrorReason.InvalidConfig,\n      path: configPath,\n    };\n  }\n\n  return {\n    exists: true,\n    path: configPath,\n    extendedPaths,\n    config,\n    isCircular: extendedPaths.includes(configPath),\n  };\n};\n\nexport { TsConfigJson };\n\n/**\n * Resolve the `tsconfig` file synchronously. Walks up the file tree until it\n * finds a file that matches the searchName.\n *\n * @param options - `TsConfigResolverOptions`.\n *\n * @returns an object containing whether a configuration was found and is valid.\n *\n * @remarks\n *\n * If a non-default caching strategy is provided the returned result might be\n * from the cache instead.\n */\nexport function tsconfigResolverSync({\n  filePath,\n  cwd = process.cwd(),\n  cache: shouldCache = filePath ? CacheStrategy.Always : CacheStrategy.Never,\n  searchName = DEFAULT_SEARCH_NAME,\n  ignoreExtends = false,\n}: TsConfigResolverOptions = {}): TsConfigResult {\n  const cacheStrategy = convertCacheToStrategy(shouldCache);\n  const cache = getCache({\n    cwd,\n    cache: cacheStrategy,\n    searchName,\n    filePath,\n    ignoreExtends,\n  });\n\n  if (cache) {\n    return cache;\n  }\n\n  const result = getTsConfigResultSync({\n    cwd,\n    searchName,\n    filePath,\n    ignoreExtends,\n  });\n\n  updateCache(\n    { cwd, cache: cacheStrategy, searchName, filePath, ignoreExtends },\n    result,\n  );\n\n  return result;\n}\n\n/**\n * Resolve the `tsconfig` file. Walks up the file tree until it\n * finds a file that matches the searchName.\n *\n * @param options - `TsConfigResolverOptions`.\n *\n * @remarks\n *\n * If a non-default caching strategy is provided the returned result might be\n * from the cache instead.\n */\nexport async function tsconfigResolver({\n  filePath,\n  cwd = process.cwd(),\n  cache: shouldCache = filePath ? CacheStrategy.Always : CacheStrategy.Never,\n  searchName = DEFAULT_SEARCH_NAME,\n  ignoreExtends = false,\n}: TsConfigResolverOptions = {}): Promise<TsConfigResult> {\n  const cacheStrategy = convertCacheToStrategy(shouldCache);\n  const cache = getCache({\n    cwd,\n    cache: cacheStrategy,\n    searchName,\n    filePath,\n    ignoreExtends,\n  });\n\n  if (cache) {\n    return cache;\n  }\n\n  const result = await getTsConfigResult({\n    cwd,\n    searchName,\n    filePath,\n    ignoreExtends,\n  });\n\n  updateCache(\n    { cwd, cache: cacheStrategy, searchName, filePath, ignoreExtends },\n    result,\n  );\n\n  return result;\n}\n"],"names":["tsconfigResolver","filePath","cwd","process","cache","shouldCache","CacheStrategy","Always","Never","searchName","DEFAULT_SEARCH_NAME","ignoreExtends","cacheStrategy","convertCacheToStrategy","getCache","getTsConfigResult","result","updateCache","readFile","promises","stat","parseFilePath","file","windows","isWindows","platform","parser","pathWin32","parse","pathParse","parsedPath","isAbsolute","Boolean","root","isPackage","startsWith","TsConfigErrorReason","NotFound","InvalidConfig","walkForTsConfigSync","directory","configPath","join","isFileOrDirectorySync","parentDirectory","undefined","walkForTsConfig","isFileOrDirectory","isDirectorySync","statSync","isDirectory","stats","isFileSync","isFile","resolvePackageSync","name","basedir","resolvePackageNpm","sync","extensions","resolvePackage","Promise","resolve","reject","error","resolved","resolveFilePathSync","resolvedPath","replace","resolveFilePath","resolveConfigPathSync","resolvedFilePath","resolvedSearchName","absolutePath","configAbsolutePath","resolveConfigPath","parseTsConfigJson","jsonString","json","JSON5","loadTsConfigSync","configFilePath","extendedPaths","configString","readFileSync","StripBom","config","extendedConfig","base","newConfigPath","includes","push","endsWith","currentDir","dirname","extendedConfigPath","compilerOptions","baseUrl","extendsDir","loadTsConfig","Directory","cacheObject","Map","value","cacheKey","options","get","set","clearCache","Object","values","map","clear","getTsConfigResultSync","exists","reason","path","isCircular","tsconfigResolverSync"],"mappings":"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"}