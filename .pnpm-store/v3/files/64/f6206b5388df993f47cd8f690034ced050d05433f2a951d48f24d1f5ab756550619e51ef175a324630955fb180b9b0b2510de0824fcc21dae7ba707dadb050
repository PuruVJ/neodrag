{"version":3,"names":["transpileNamespace","path","allowNamespaces","node","declare","id","type","remove","get","buildCodeFrameError","name","value","handleNested","t","cloneNode","bound","scope","hasOwnBinding","parent","parentPath","insertAfter","replaceWith","getDeclaration","registerDeclaration","replaceWithMultiple","variableDeclaration","variableDeclarator","identifier","getMemberExpression","itemName","memberExpression","handleVariableDeclaration","hub","kind","file","declarations","every","declarator","isIdentifier","init","assignmentExpression","bindingIdentifiers","getBindingIdentifiers","assignments","idName","push","expressionStatement","sequenceExpression","buildNestedAmbiendModuleError","buildError","Error","parentExport","names","Set","realName","assertIdentifier","generateUid","namespaceTopLevel","isTSModuleBlock","body","exportNamedDeclaration","i","length","subNode","transformed","moduleName","has","add","splice","declaration","nodes","fallthroughValue","objectExpression","memberExpr","template","expression","ast","statement"],"sources":["../src/namespace.ts"],"sourcesContent":["import { template, types as t } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\n\nexport default function transpileNamespace(\n  path: NodePath<t.TSModuleDeclaration>,\n  allowNamespaces: boolean,\n) {\n  if (path.node.declare || path.node.id.type === \"StringLiteral\") {\n    path.remove();\n    return;\n  }\n\n  if (!allowNamespaces) {\n    throw path\n      .get(\"id\")\n      .buildCodeFrameError(\n        \"Namespace not marked type-only declare.\" +\n          \" Non-declarative namespaces are only supported experimentally in Babel.\" +\n          \" To enable and review caveats see:\" +\n          \" https://babeljs.io/docs/en/babel-plugin-transform-typescript\",\n      );\n  }\n\n  const name = path.node.id.name;\n  const value = handleNested(path, t.cloneNode(path.node, true));\n  const bound = path.scope.hasOwnBinding(name);\n  if (path.parent.type === \"ExportNamedDeclaration\") {\n    if (!bound) {\n      path.parentPath.insertAfter(value);\n      path.replaceWith(getDeclaration(name));\n      path.scope.registerDeclaration(path.parentPath);\n    } else {\n      path.parentPath.replaceWith(value);\n    }\n  } else if (bound) {\n    path.replaceWith(value);\n  } else {\n    path.scope.registerDeclaration(\n      path.replaceWithMultiple([getDeclaration(name), value])[0],\n    );\n  }\n}\n\nfunction getDeclaration(name: string) {\n  return t.variableDeclaration(\"let\", [\n    t.variableDeclarator(t.identifier(name)),\n  ]);\n}\n\nfunction getMemberExpression(name: string, itemName: string) {\n  return t.memberExpression(t.identifier(name), t.identifier(itemName));\n}\n\n/**\n * Convert export const foo = 1 to Namepsace.foo = 1;\n *\n * @param {t.VariableDeclaration} node given variable declaration, e.g. `const foo = 1`\n * @param {string} name the generated unique namespace member name\n * @param {*} hub An instance implements HubInterface defined in `@babel/traverse` that can throw a code frame error\n */\nfunction handleVariableDeclaration(\n  node: t.VariableDeclaration,\n  name: string,\n  hub: any,\n): t.Statement[] {\n  if (node.kind !== \"const\") {\n    throw hub.file.buildCodeFrameError(\n      node,\n      \"Namespaces exporting non-const are not supported by Babel.\" +\n        \" Change to const or see:\" +\n        \" https://babeljs.io/docs/en/babel-plugin-transform-typescript\",\n    );\n  }\n  const { declarations } = node;\n  if (\n    declarations.every(\n      (declarator): declarator is t.VariableDeclarator & { id: t.Identifier } =>\n        t.isIdentifier(declarator.id),\n    )\n  ) {\n    // `export const a = 1` transforms to `const a = N.a = 1`, the output\n    // is smaller than `const a = 1; N.a = a`;\n    for (const declarator of declarations) {\n      declarator.init = t.assignmentExpression(\n        \"=\",\n        getMemberExpression(name, declarator.id.name),\n        declarator.init,\n      );\n    }\n    return [node];\n  }\n  // Now we have pattern in declarators\n  // `export const [a] = 1` transforms to `const [a] = 1; N.a = a`\n  const bindingIdentifiers = t.getBindingIdentifiers(node);\n  const assignments = [];\n  // getBindingIdentifiers returns an object without prototype.\n  // eslint-disable-next-line guard-for-in\n  for (const idName in bindingIdentifiers) {\n    assignments.push(\n      t.assignmentExpression(\n        \"=\",\n        getMemberExpression(name, idName),\n        t.cloneNode(bindingIdentifiers[idName]),\n      ),\n    );\n  }\n  return [node, t.expressionStatement(t.sequenceExpression(assignments))];\n}\n\nfunction buildNestedAmbiendModuleError(path: NodePath, node: t.Node) {\n  throw path.hub.buildError(\n    node,\n    \"Ambient modules cannot be nested in other modules or namespaces.\",\n    Error,\n  );\n}\n\nfunction handleNested(\n  path: NodePath,\n  node: t.TSModuleDeclaration,\n  parentExport?: t.Expression,\n) {\n  const names = new Set();\n  const realName = node.id;\n  t.assertIdentifier(realName);\n\n  const name = path.scope.generateUid(realName.name);\n\n  const namespaceTopLevel: t.Statement[] = t.isTSModuleBlock(node.body)\n    ? node.body.body\n    : // We handle `namespace X.Y {}` as if it was\n      //   namespace X {\n      //     export namespace Y {}\n      //   }\n      [t.exportNamedDeclaration(node.body)];\n\n  for (let i = 0; i < namespaceTopLevel.length; i++) {\n    const subNode = namespaceTopLevel[i];\n\n    // The first switch is mainly to detect name usage. Only export\n    // declarations require further transformation.\n    switch (subNode.type) {\n      case \"TSModuleDeclaration\": {\n        if (!t.isIdentifier(subNode.id)) {\n          throw buildNestedAmbiendModuleError(path, subNode);\n        }\n\n        const transformed = handleNested(path, subNode);\n        const moduleName = subNode.id.name;\n        if (names.has(moduleName)) {\n          namespaceTopLevel[i] = transformed;\n        } else {\n          names.add(moduleName);\n          namespaceTopLevel.splice(\n            i++,\n            1,\n            getDeclaration(moduleName),\n            transformed,\n          );\n        }\n        continue;\n      }\n      case \"TSEnumDeclaration\":\n      case \"FunctionDeclaration\":\n      case \"ClassDeclaration\":\n        names.add(subNode.id.name);\n        continue;\n      case \"VariableDeclaration\": {\n        // getBindingIdentifiers returns an object without prototype.\n        // eslint-disable-next-line guard-for-in\n        for (const name in t.getBindingIdentifiers(subNode)) {\n          names.add(name);\n        }\n        continue;\n      }\n      default:\n        // Neither named declaration nor export, continue to next item.\n        continue;\n      case \"ExportNamedDeclaration\":\n      // Export declarations get parsed using the next switch.\n    }\n\n    if (\"declare\" in subNode.declaration && subNode.declaration.declare) {\n      continue;\n    }\n\n    // Transform the export declarations that occur inside of a namespace.\n    switch (subNode.declaration.type) {\n      case \"TSEnumDeclaration\":\n      case \"FunctionDeclaration\":\n      case \"ClassDeclaration\": {\n        const itemName = subNode.declaration.id.name;\n        names.add(itemName);\n        namespaceTopLevel.splice(\n          i++,\n          1,\n          subNode.declaration,\n          t.expressionStatement(\n            t.assignmentExpression(\n              \"=\",\n              getMemberExpression(name, itemName),\n              t.identifier(itemName),\n            ),\n          ),\n        );\n        break;\n      }\n      case \"VariableDeclaration\": {\n        const nodes = handleVariableDeclaration(\n          subNode.declaration,\n          name,\n          path.hub,\n        );\n        namespaceTopLevel.splice(i, nodes.length, ...nodes);\n        i += nodes.length - 1;\n        break;\n      }\n      case \"TSModuleDeclaration\": {\n        if (!t.isIdentifier(subNode.declaration.id)) {\n          throw buildNestedAmbiendModuleError(path, subNode.declaration);\n        }\n\n        const transformed = handleNested(\n          path,\n          subNode.declaration,\n          t.identifier(name),\n        );\n        const moduleName = subNode.declaration.id.name;\n        if (names.has(moduleName)) {\n          namespaceTopLevel[i] = transformed;\n        } else {\n          names.add(moduleName);\n          namespaceTopLevel.splice(\n            i++,\n            1,\n            getDeclaration(moduleName),\n            transformed,\n          );\n        }\n      }\n    }\n  }\n\n  // {}\n  let fallthroughValue: t.Expression = t.objectExpression([]);\n\n  if (parentExport) {\n    const memberExpr = t.memberExpression(parentExport, realName);\n    fallthroughValue = template.expression.ast`\n      ${t.cloneNode(memberExpr)} ||\n        (${t.cloneNode(memberExpr)} = ${fallthroughValue})\n    `;\n  }\n\n  return template.statement.ast`\n    (function (${t.identifier(name)}) {\n      ${namespaceTopLevel}\n    })(${realName} || (${t.cloneNode(realName)} = ${fallthroughValue}));\n  `;\n}\n"],"mappings":"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"}