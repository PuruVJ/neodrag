{"version":3,"names":["iifeVisitor","path","state","scope","node","name","getBinding","parent","hasOwnBinding","needsOuterBinding","stop","skip","collectShadowedParamsNames","param","functionScope","shadowedParams","Object","keys","getBindingIdentifiers","constantViolations","bindings","redeclarator","type","init","declaration","parentPath","isFor","get","remove","add","buildScopeIIFE","body","args","params","push","t","identifier","returnStatement","callExpression","arrowFunctionExpression"],"sources":["../src/shadow-utils.ts"],"sourcesContent":["import { types as t } from \"@babel/core\";\nimport type { NodePath, Scope, Visitor } from \"@babel/traverse\";\n\ntype State = {\n  needsOuterBinding: boolean;\n  scope: Scope;\n};\n\nexport const iifeVisitor: Visitor<State> = {\n  \"ReferencedIdentifier|BindingIdentifier\"(\n    path: NodePath<t.Identifier>,\n    state,\n  ) {\n    const { scope, node } = path;\n    const { name } = node;\n\n    if (\n      name === \"eval\" ||\n      (scope.getBinding(name) === state.scope.parent.getBinding(name) &&\n        state.scope.hasOwnBinding(name))\n    ) {\n      state.needsOuterBinding = true;\n      path.stop();\n    }\n  },\n  // type annotations don't use or introduce \"real\" bindings\n  \"TypeAnnotation|TSTypeAnnotation|TypeParameterDeclaration|TSTypeParameterDeclaration\":\n    (path: NodePath) => path.skip(),\n};\n\nexport function collectShadowedParamsNames(\n  param: NodePath<t.Function[\"params\"][number]>,\n  functionScope: Scope,\n  shadowedParams: Set<string>,\n) {\n  for (const name of Object.keys(param.getBindingIdentifiers())) {\n    const constantViolations = functionScope.bindings[name]?.constantViolations;\n    if (constantViolations) {\n      for (const redeclarator of constantViolations) {\n        const node = redeclarator.node;\n        // If a constant violation is a var or a function declaration,\n        // we first check to see if it's a var without an init.\n        // If so, we remove that declarator.\n        // Otherwise, we have to wrap it in an IIFE.\n        switch (node.type) {\n          case \"VariableDeclarator\": {\n            if (node.init === null) {\n              const declaration = redeclarator.parentPath;\n              // The following uninitialized var declarators should not be removed\n              // for (var x in {})\n              // for (var x;;)\n              if (\n                !declaration.parentPath.isFor() ||\n                declaration.parentPath.get(\"body\") === declaration\n              ) {\n                redeclarator.remove();\n                break;\n              }\n            }\n\n            shadowedParams.add(name);\n            break;\n          }\n          case \"FunctionDeclaration\":\n            shadowedParams.add(name);\n            break;\n        }\n      }\n    }\n  }\n}\n\nexport function buildScopeIIFE(\n  shadowedParams: Set<string>,\n  body: t.BlockStatement,\n) {\n  const args = [];\n  const params = [];\n\n  for (const name of shadowedParams) {\n    // We create them twice; the other option is to use t.cloneNode\n    args.push(t.identifier(name));\n    params.push(t.identifier(name));\n  }\n\n  return t.returnStatement(\n    t.callExpression(t.arrowFunctionExpression(params, body), args),\n  );\n}\n"],"mappings":";;;;;;;;AAAA;AAQO,MAAMA,WAA2B,GAAG;EACzC,wCAAwC,CACtCC,IAA4B,EAC5BC,KAAK,EACL;IACA,MAAM;MAAEC,KAAK;MAAEC;IAAK,CAAC,GAAGH,IAAI;IAC5B,MAAM;MAAEI;IAAK,CAAC,GAAGD,IAAI;IAErB,IACEC,IAAI,KAAK,MAAM,IACdF,KAAK,CAACG,UAAU,CAACD,IAAI,CAAC,KAAKH,KAAK,CAACC,KAAK,CAACI,MAAM,CAACD,UAAU,CAACD,IAAI,CAAC,IAC7DH,KAAK,CAACC,KAAK,CAACK,aAAa,CAACH,IAAI,CAAE,EAClC;MACAH,KAAK,CAACO,iBAAiB,GAAG,IAAI;MAC9BR,IAAI,CAACS,IAAI,EAAE;IACb;EACF,CAAC;EAED,qFAAqF,EAClFT,IAAc,IAAKA,IAAI,CAACU,IAAI;AACjC,CAAC;AAAC;AAEK,SAASC,0BAA0B,CACxCC,KAA6C,EAC7CC,aAAoB,EACpBC,cAA2B,EAC3B;EACA,KAAK,MAAMV,IAAI,IAAIW,MAAM,CAACC,IAAI,CAACJ,KAAK,CAACK,qBAAqB,EAAE,CAAC,EAAE;IAAA;IAC7D,MAAMC,kBAAkB,4BAAGL,aAAa,CAACM,QAAQ,CAACf,IAAI,CAAC,qBAA5B,sBAA8Bc,kBAAkB;IAC3E,IAAIA,kBAAkB,EAAE;MACtB,KAAK,MAAME,YAAY,IAAIF,kBAAkB,EAAE;QAC7C,MAAMf,IAAI,GAAGiB,YAAY,CAACjB,IAAI;QAK9B,QAAQA,IAAI,CAACkB,IAAI;UACf,KAAK,oBAAoB;YAAE;cACzB,IAAIlB,IAAI,CAACmB,IAAI,KAAK,IAAI,EAAE;gBACtB,MAAMC,WAAW,GAAGH,YAAY,CAACI,UAAU;gBAI3C,IACE,CAACD,WAAW,CAACC,UAAU,CAACC,KAAK,EAAE,IAC/BF,WAAW,CAACC,UAAU,CAACE,GAAG,CAAC,MAAM,CAAC,KAAKH,WAAW,EAClD;kBACAH,YAAY,CAACO,MAAM,EAAE;kBACrB;gBACF;cACF;cAEAb,cAAc,CAACc,GAAG,CAACxB,IAAI,CAAC;cACxB;YACF;UACA,KAAK,qBAAqB;YACxBU,cAAc,CAACc,GAAG,CAACxB,IAAI,CAAC;YACxB;QAAM;MAEZ;IACF;EACF;AACF;AAEO,SAASyB,cAAc,CAC5Bf,cAA2B,EAC3BgB,IAAsB,EACtB;EACA,MAAMC,IAAI,GAAG,EAAE;EACf,MAAMC,MAAM,GAAG,EAAE;EAEjB,KAAK,MAAM5B,IAAI,IAAIU,cAAc,EAAE;IAEjCiB,IAAI,CAACE,IAAI,CAACC,WAAC,CAACC,UAAU,CAAC/B,IAAI,CAAC,CAAC;IAC7B4B,MAAM,CAACC,IAAI,CAACC,WAAC,CAACC,UAAU,CAAC/B,IAAI,CAAC,CAAC;EACjC;EAEA,OAAO8B,WAAC,CAACE,eAAe,CACtBF,WAAC,CAACG,cAAc,CAACH,WAAC,CAACI,uBAAuB,CAACN,MAAM,EAAEF,IAAI,CAAC,EAAEC,IAAI,CAAC,CAChE;AACH"}