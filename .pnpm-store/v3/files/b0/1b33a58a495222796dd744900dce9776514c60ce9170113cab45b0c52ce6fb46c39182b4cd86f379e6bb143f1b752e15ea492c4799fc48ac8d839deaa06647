{"version":3,"names":["transpileEnum","path","t","node","declare","remove","name","id","fill","enumFill","parent","type","insertAfter","seen","parentPath","isGlobal","isProgram","scope","registerDeclaration","replaceWith","makeVar","Error","isExportDeclaration","getData","setData","kind","variableDeclaration","variableDeclarator","buildEnumWrapper","template","buildStringAssignment","buildNumericAssignment","buildEnumMember","isString","options","x","translateEnumValues","assignments","map","memberName","memberValue","isStringLiteral","ENUM","cloneNode","NAME","VALUE","ID","ASSIGNMENTS","ReferencedIdentifier","expr","state","has","hasOwnBinding","memberExpression","skip","enumSelfReferenceVisitor","Map","constValue","lastName","get","memberPath","member","isIdentifier","value","initializer","evaluate","undefined","set","numericLiteral","assert","stringLiteral","initializerPath","isReferencedIdentifier","traverse","buildCodeFrameError","lastRef","binaryExpression","evalConstant","evalUnaryExpression","evalBinaryExpression","expression","quasis","length","cooked","argument","operator","left","right"],"sources":["../src/enum.ts"],"sourcesContent":["import { template } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\nimport type * as t from \"@babel/types\";\nimport assert from \"assert\";\n\ntype t = typeof t;\n\nexport default function transpileEnum(\n  path: NodePath<t.TSEnumDeclaration>,\n  t: t,\n) {\n  const { node } = path;\n\n  if (node.declare) {\n    path.remove();\n    return;\n  }\n\n  const name = node.id.name;\n  const fill = enumFill(path, t, node.id);\n\n  switch (path.parent.type) {\n    case \"BlockStatement\":\n    case \"ExportNamedDeclaration\":\n    case \"Program\": {\n      path.insertAfter(fill);\n      if (seen(path.parentPath)) {\n        path.remove();\n      } else {\n        const isGlobal = t.isProgram(path.parent); // && !path.parent.body.some(t.isModuleDeclaration);\n        path.scope.registerDeclaration(\n          path.replaceWith(makeVar(node.id, t, isGlobal ? \"var\" : \"let\"))[0],\n        );\n      }\n      break;\n    }\n\n    default:\n      throw new Error(`Unexpected enum parent '${path.parent.type}`);\n  }\n\n  function seen(parentPath: NodePath<t.Node>): boolean {\n    if (parentPath.isExportDeclaration()) {\n      return seen(parentPath.parentPath);\n    }\n\n    if (parentPath.getData(name)) {\n      return true;\n    } else {\n      parentPath.setData(name, true);\n      return false;\n    }\n  }\n}\n\nfunction makeVar(id: t.Identifier, t: t, kind: \"var\" | \"let\" | \"const\") {\n  return t.variableDeclaration(kind, [t.variableDeclarator(id)]);\n}\n\nconst buildEnumWrapper = template(`\n  (function (ID) {\n    ASSIGNMENTS;\n  })(ID || (ID = {}));\n`);\n\nconst buildStringAssignment = template(`\n  ENUM[\"NAME\"] = VALUE;\n`);\n\nconst buildNumericAssignment = template(`\n  ENUM[ENUM[\"NAME\"] = VALUE] = \"NAME\";\n`);\n\nconst buildEnumMember = (isString: boolean, options: Record<string, unknown>) =>\n  (isString ? buildStringAssignment : buildNumericAssignment)(options);\n\n/**\n * Generates the statement that fills in the variable declared by the enum.\n * `(function (E) { ... assignments ... })(E || (E = {}));`\n */\nfunction enumFill(path: NodePath<t.TSEnumDeclaration>, t: t, id: t.Identifier) {\n  const x = translateEnumValues(path, t);\n  const assignments = x.map(([memberName, memberValue]) =>\n    buildEnumMember(t.isStringLiteral(memberValue), {\n      ENUM: t.cloneNode(id),\n      NAME: memberName,\n      VALUE: memberValue,\n    }),\n  );\n\n  return buildEnumWrapper({\n    ID: t.cloneNode(id),\n    ASSIGNMENTS: assignments,\n  });\n}\n\n/**\n * Maps the name of an enum member to its value.\n * We keep track of the previous enum members so you can write code like:\n *   enum E {\n *     X = 1 << 0,\n *     Y = 1 << 1,\n *     Z = X | Y,\n *   }\n */\ntype PreviousEnumMembers = Map<string, number | string>;\n\ntype EnumSelfReferenceVisitorState = {\n  seen: PreviousEnumMembers;\n  path: NodePath<t.TSEnumDeclaration>;\n  t: t;\n};\n\nfunction ReferencedIdentifier(\n  expr: NodePath<t.Identifier>,\n  state: EnumSelfReferenceVisitorState,\n) {\n  const { seen, path, t } = state;\n  const name = expr.node.name;\n  if (seen.has(name) && !expr.scope.hasOwnBinding(name)) {\n    expr.replaceWith(\n      t.memberExpression(t.cloneNode(path.node.id), t.cloneNode(expr.node)),\n    );\n    expr.skip();\n  }\n}\n\nconst enumSelfReferenceVisitor = {\n  ReferencedIdentifier,\n};\n\nexport function translateEnumValues(\n  path: NodePath<t.TSEnumDeclaration>,\n  t: t,\n): Array<[name: string, value: t.Expression]> {\n  const seen: PreviousEnumMembers = new Map();\n  // Start at -1 so the first enum member is its increment, 0.\n  let constValue: number | string | undefined = -1;\n  let lastName: string;\n\n  return path.get(\"members\").map(memberPath => {\n    const member = memberPath.node;\n    const name = t.isIdentifier(member.id) ? member.id.name : member.id.value;\n    const initializer = member.initializer;\n    let value: t.Expression;\n    if (initializer) {\n      constValue = evaluate(initializer, seen);\n      if (constValue !== undefined) {\n        seen.set(name, constValue);\n        if (typeof constValue === \"number\") {\n          value = t.numericLiteral(constValue);\n        } else {\n          assert(typeof constValue === \"string\");\n          value = t.stringLiteral(constValue);\n        }\n      } else {\n        const initializerPath = memberPath.get(\"initializer\");\n\n        if (initializerPath.isReferencedIdentifier()) {\n          ReferencedIdentifier(initializerPath, {\n            t,\n            seen,\n            path,\n          });\n        } else {\n          initializerPath.traverse(enumSelfReferenceVisitor, { t, seen, path });\n        }\n\n        value = initializerPath.node;\n        seen.set(name, undefined);\n      }\n    } else if (typeof constValue === \"number\") {\n      constValue += 1;\n      value = t.numericLiteral(constValue);\n      seen.set(name, constValue);\n    } else if (typeof constValue === \"string\") {\n      throw path.buildCodeFrameError(\"Enum member must have initializer.\");\n    } else {\n      // create dynamic initializer: 1 + ENUM[\"PREVIOUS\"]\n      const lastRef = t.memberExpression(\n        t.cloneNode(path.node.id),\n        t.stringLiteral(lastName),\n        true,\n      );\n      value = t.binaryExpression(\"+\", t.numericLiteral(1), lastRef);\n      seen.set(name, undefined);\n    }\n\n    lastName = name;\n    return [name, value];\n  });\n}\n\n// Based on the TypeScript repository's `evalConstant` in `checker.ts`.\nfunction evaluate(\n  expr: t.Node,\n  seen: PreviousEnumMembers,\n): number | string | typeof undefined {\n  return evalConstant(expr);\n\n  function evalConstant(expr: t.Node): number | typeof undefined {\n    switch (expr.type) {\n      case \"StringLiteral\":\n        return expr.value;\n      case \"UnaryExpression\":\n        return evalUnaryExpression(expr);\n      case \"BinaryExpression\":\n        return evalBinaryExpression(expr);\n      case \"NumericLiteral\":\n        return expr.value;\n      case \"ParenthesizedExpression\":\n        return evalConstant(expr.expression);\n      case \"Identifier\":\n        return seen.get(expr.name);\n      case \"TemplateLiteral\":\n        if (expr.quasis.length === 1) {\n          return expr.quasis[0].value.cooked;\n        }\n      /* falls through */\n      default:\n        return undefined;\n    }\n  }\n\n  function evalUnaryExpression({\n    argument,\n    operator,\n  }: t.UnaryExpression): number | typeof undefined {\n    const value = evalConstant(argument);\n    if (value === undefined) {\n      return undefined;\n    }\n\n    switch (operator) {\n      case \"+\":\n        return value;\n      case \"-\":\n        return -value;\n      case \"~\":\n        return ~value;\n      default:\n        return undefined;\n    }\n  }\n\n  function evalBinaryExpression(expr: t.BinaryExpression): number | undefined {\n    const left = evalConstant(expr.left);\n    if (left === undefined) {\n      return undefined;\n    }\n    const right = evalConstant(expr.right);\n    if (right === undefined) {\n      return undefined;\n    }\n\n    switch (expr.operator) {\n      case \"|\":\n        return left | right;\n      case \"&\":\n        return left & right;\n      case \">>\":\n        return left >> right;\n      case \">>>\":\n        return left >>> right;\n      case \"<<\":\n        return left << right;\n      case \"^\":\n        return left ^ right;\n      case \"*\":\n        return left * right;\n      case \"/\":\n        return left / right;\n      case \"+\":\n        return left + right;\n      case \"-\":\n        return left - right;\n      case \"%\":\n        return left % right;\n      default:\n        return undefined;\n    }\n  }\n}\n"],"mappings":"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"}