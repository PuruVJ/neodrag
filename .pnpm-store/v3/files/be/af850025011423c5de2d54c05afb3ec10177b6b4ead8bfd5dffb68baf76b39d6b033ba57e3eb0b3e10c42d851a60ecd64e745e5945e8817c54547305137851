"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pruneYarnLockFile = exports.transitiveDependencyYarnLookup = exports.stringifyYarnLockFile = exports.parseYarnLockFile = void 0;
const tslib_1 = require("tslib");
const parsers_1 = require("@yarnpkg/parsers");
const lockfile_1 = require("@yarnpkg/lockfile");
const mapping_1 = require("./utils/mapping");
const hashing_1 = require("./utils/hashing");
const object_sort_1 = require("../utils/object-sort");
const BERRY_LOCK_FILE_DISCLAIMER = `# This file was generated by Nx. Do not edit this file directly\n# Manual changes might be lost - proceed with caution!\n\n`;
/**
 * Parses `yarn.lock` syml file and maps to {@link LockFileData}
 *
 * @param lockFile
 * @returns
 */
function parseYarnLockFile(lockFile) {
    const _a = (0, parsers_1.parseSyml)(lockFile), { __metadata } = _a, dependencies = tslib_1.__rest(_a, ["__metadata"]);
    // Yarn Berry has workspace packages includes, so we need to extract those to metadata
    const isBerry = !!__metadata;
    const [mappedPackages, workspacePackages] = mapPackages(dependencies, isBerry);
    const hash = (0, hashing_1.hashString)(lockFile);
    if (isBerry) {
        return {
            dependencies: mappedPackages,
            lockFileMetadata: {
                __metadata,
                workspacePackages,
            },
            hash,
        };
    }
    else {
        return { dependencies: mappedPackages, hash };
    }
}
exports.parseYarnLockFile = parseYarnLockFile;
function extendVersionProperty(key, value, isBerry) {
    if (isBerry) {
        const packageName = key.slice(0, key.lastIndexOf('@'));
        if (value.resolution !== `${packageName}@npm:${value.version}`) {
            return {
                version: value.resolution.slice(packageName.length + 1),
                actualVersion: value.version,
            };
        }
        return;
    }
    if (value.integrity) {
        return;
    }
    return {
        version: key.slice(key.lastIndexOf('@') + 1),
        actualVersion: value.version,
    };
}
// map original yarn packages to the LockFileData structure
function mapPackages(packages, isBerry) {
    const mappedPackages = {};
    const workspacePackages = {};
    Object.entries(packages).forEach(([keyExpr, value]) => {
        // separate workspace packages from the external ones
        // we only combine them back when stringifying
        if (value.linkType === 'soft') {
            workspacePackages[keyExpr] = value;
        }
        else {
            // key might be "@nrwl/somedep@1.2.3, @nrwl/somedep@^1.0.0..."
            const keys = keyExpr.split(', ');
            let packageName = keys[0].slice(0, keys[0].indexOf('@', 1));
            if (isBerry &&
                keys[0].startsWith(`${packageName}@patch:${packageName}`)) {
                // handle Berry's patch format as a separate package
                packageName = `${packageName}@patch:${packageName}`;
            }
            const newKey = `${packageName}@${value.version}`;
            mappedPackages[packageName] = mappedPackages[packageName] || {};
            if (!mappedPackages[packageName][newKey]) {
                mappedPackages[packageName][newKey] = Object.assign(Object.assign(Object.assign({}, value), extendVersionProperty(keys[0], value, isBerry)), { packageMeta: keys });
            }
            else {
                mappedPackages[packageName][newKey].packageMeta.push(...keys);
            }
        }
    });
    Object.keys(mappedPackages).forEach((packageName) => {
        const versions = mappedPackages[packageName];
        const versionKeys = Object.keys(versions);
        if (versionKeys.length === 1) {
            versions[versionKeys[0]].rootVersion = true;
        }
        else {
            const rootVersionKey = versionKeys.find((v) => (0, mapping_1.isRootVersion)(packageName, versions[v].version));
            // this should never happen, but just in case
            if (rootVersionKey) {
                versions[rootVersionKey].rootVersion = true;
            }
        }
    });
    return [mappedPackages, workspacePackages];
}
/**
 * Generates yarn.lock file from `LockFileData` object
 *
 * @param lockFileData
 * @returns
 */
function stringifyYarnLockFile(lockFileData) {
    var _a;
    // only berry's format has metadata defined
    // this is an easy way to distinguish it from the classic
    const isBerry = !!((_a = lockFileData.lockFileMetadata) === null || _a === void 0 ? void 0 : _a.__metadata);
    const dependencies = unmapPackages(lockFileData.dependencies, isBerry);
    if (isBerry) {
        const lockFile = Object.assign(Object.assign({ __metadata: lockFileData.lockFileMetadata.__metadata }, lockFileData.lockFileMetadata.workspacePackages), dependencies);
        // berry's stringifySyml doesn't generate comment
        return BERRY_LOCK_FILE_DISCLAIMER + (0, parsers_1.stringifySyml)(lockFile);
    }
    else {
        return (0, lockfile_1.stringify)(dependencies);
    }
}
exports.stringifyYarnLockFile = stringifyYarnLockFile;
// revert mapping of packages from LockFileData to the original JSON structure
// E.g. from:
//  "abc": {
//    "abc@1.2.3": {
//      ...value
//      packageMeta: ["abc@^1.0.0", "abc@~1.2.0"]
//    }
// }
// to:
//  "abc@^1.0.0, abc@~1.2.0": {
//    ...value
//  }
//
function unmapPackages(dependencies, isBerry = false) {
    const packages = {};
    Object.values(dependencies).forEach((packageVersions) => {
        Object.values(packageVersions).forEach((value) => {
            const { packageMeta, rootVersion, actualVersion } = value, rest = tslib_1.__rest(value, ["packageMeta", "rootVersion", "actualVersion"]);
            if (actualVersion) {
                rest.version = actualVersion;
            }
            if (isBerry) {
                // berry's `stringifySyml` does not combine packages
                // we have to do it manually
                packages[packageMeta.join(', ')] = rest;
            }
            else {
                // classic's `stringify` combines packages with same resolution
                packageMeta.forEach((key) => {
                    packages[key] = rest;
                });
            }
        });
    });
    return packages;
}
/**
 * Returns matching version of the dependency
 */
function transitiveDependencyYarnLookup({ packageName, versions, version, }) {
    return Object.values(versions).find((v) => v.packageMeta.some((p) => p === `${packageName}@${version}` ||
        p === `${packageName}@npm:${version}`));
}
exports.transitiveDependencyYarnLookup = transitiveDependencyYarnLookup;
/**
 * Prunes the lock file data based on the list of packages and their transitive dependencies
 *
 * @param lockFileData
 * @returns
 */
function pruneYarnLockFile(lockFileData, normalizedPackageJson) {
    var _a;
    const isBerry = !!((_a = lockFileData.lockFileMetadata) === null || _a === void 0 ? void 0 : _a.__metadata);
    const prunedDependencies = pruneDependencies(lockFileData.dependencies, normalizedPackageJson, isBerry);
    const hash = (0, hashing_1.generatePrunnedHash)(lockFileData.hash, normalizedPackageJson);
    let prunedLockFileData;
    if (isBerry) {
        const { __metadata, workspacePackages } = lockFileData.lockFileMetadata;
        prunedLockFileData = {
            lockFileMetadata: {
                __metadata,
                workspacePackages: pruneWorkspacePackages(workspacePackages, prunedDependencies, normalizedPackageJson),
            },
            dependencies: prunedDependencies,
            hash,
        };
    }
    else {
        prunedLockFileData = {
            dependencies: prunedDependencies,
            hash,
        };
    }
    prunedLockFileData.hash = (0, hashing_1.hashString)(JSON.stringify(prunedLockFileData));
    return prunedLockFileData;
}
exports.pruneYarnLockFile = pruneYarnLockFile;
// iterate over packages to collect the affected tree of dependencies
function pruneDependencies(dependencies, normalizedPackageJson, isBerry) {
    const result = {};
    Object.keys(Object.assign(Object.assign(Object.assign({}, normalizedPackageJson.dependencies), normalizedPackageJson.devDependencies), normalizedPackageJson.peerDependencies)).forEach((packageName) => {
        if (dependencies[packageName]) {
            pruneDependency(packageName, normalizedPackageJson, dependencies, result);
            if (isBerry) {
                const patchPackageName = `${packageName}@patch:${packageName}`;
                if (dependencies[patchPackageName]) {
                    pruneDependency(patchPackageName, normalizedPackageJson, dependencies, result, true);
                }
            }
        }
        else {
            console.warn(`Could not find ${packageName} in the lock file. Skipping...`);
        }
    });
    return result;
}
function pruneDependency(packageName, normalizedPackageJson, dependencies, result, isPatch = false) {
    var _a, _b;
    var _c;
    const [key, value] = Object.entries(dependencies[packageName]).find(([, v]) => v.rootVersion);
    (_a = result[packageName]) !== null && _a !== void 0 ? _a : (result[packageName] = {});
    (_b = (_c = result[packageName])[key]) !== null && _b !== void 0 ? _b : (_c[key] = Object.assign(Object.assign({}, value), { packageMeta: [] }));
    let metaVersion;
    if (isPatch) {
        const originalPackageName = packageName.split('@patch:').pop();
        const patchSuffix = value.packageMeta[0].split('#').pop();
        metaVersion = `${packageName}@${getVersionFromPackageJson(normalizedPackageJson, originalPackageName)}#${patchSuffix}`;
    }
    else if (value.resolution) {
        metaVersion = `${value.resolution.replace(value.version, '')}${getVersionFromPackageJson(normalizedPackageJson, packageName)}`;
    }
    else {
        metaVersion = `${packageName}@${getVersionFromPackageJson(normalizedPackageJson, packageName)}`;
    }
    result[packageName][key].packageMeta = ensureMetaVersion(result[packageName][key].packageMeta, metaVersion);
    pruneTransitiveDependencies(dependencies, result, value);
}
function getVersionFromPackageJson(normalizedPackageJson, packageName) {
    var _a, _b, _c;
    return (((_a = normalizedPackageJson.dependencies) === null || _a === void 0 ? void 0 : _a[packageName]) ||
        ((_b = normalizedPackageJson.devDependencies) === null || _b === void 0 ? void 0 : _b[packageName]) ||
        ((_c = normalizedPackageJson.peerDependencies) === null || _c === void 0 ? void 0 : _c[packageName]));
}
// find all transitive dependencies of already pruned packages
// and adds them to the collection
// recursively prunes their dependencies
function pruneTransitiveDependencies(dependencies, prunedDeps, value) {
    var _a, _b;
    [
        ...Object.entries((_a = value.dependencies) !== null && _a !== void 0 ? _a : {}),
        ...Object.entries((_b = value.optionalDependencies) !== null && _b !== void 0 ? _b : {}),
    ].forEach(([packageName, version]) => {
        if (dependencies[packageName]) {
            // check if package with given version exists in data
            // if yes, return key, value and version expression from packageMeta
            const dependencyTriplet = findDependencyTriplet(dependencies[packageName], packageName, version);
            if (dependencyTriplet) {
                const [key, _a, metaVersion] = dependencyTriplet, { packageMeta } = _a, depValue = tslib_1.__rest(_a, ["packageMeta"]);
                if (!prunedDeps[packageName]) {
                    prunedDeps[packageName] = {};
                }
                if (prunedDeps[packageName][key]) {
                    prunedDeps[packageName][key].packageMeta = ensureMetaVersion(prunedDeps[packageName][key].packageMeta, metaVersion);
                }
                else {
                    prunedDeps[packageName][key] = Object.assign(Object.assign({}, depValue), { packageMeta: [metaVersion] });
                    // recursively collect dependencies
                    pruneTransitiveDependencies(dependencies, prunedDeps, prunedDeps[packageName][key]);
                }
            }
        }
    });
}
// prune dependencies of workspace packages from the lockFileMeta
function pruneWorkspacePackages(workspacePackages, prunedDependencies, normalizedPackageJson) {
    var _a;
    const result = {};
    const name = normalizedPackageJson.name;
    const workspaceProjKey = Object.keys(workspacePackages).find((key) => key.startsWith(`${name}@workspace:`)) || `${name}@workspace:^`;
    if (workspaceProjKey) {
        const prunedWorkspaceDependencies = pruneWorkspacePackageDependencies(((_a = workspacePackages[workspaceProjKey]) === null || _a === void 0 ? void 0 : _a.dependencies) || {}, normalizedPackageJson, prunedDependencies);
        result[workspaceProjKey] = {
            version: `${normalizedPackageJson.version || '0.0.0'}-use.local`,
            resolution: workspaceProjKey,
            languageName: 'unknown',
            linkType: 'soft',
            dependencies: (0, object_sort_1.sortObjectByKeys)(prunedWorkspaceDependencies),
        };
    }
    return result;
}
function pruneWorkspacePackageDependencies(dependencies, normalizedPackageJson, prunedDependencies) {
    const result = {};
    Object.entries(dependencies).forEach(([packageName, packageVersion]) => {
        if (isPackageVersionMatch(prunedDependencies[packageName], packageName, packageVersion)) {
            result[packageName] = packageVersion;
        }
    });
    // add all missing deps to root workspace package
    Object.keys(Object.assign(Object.assign(Object.assign({}, normalizedPackageJson.dependencies), normalizedPackageJson.devDependencies), normalizedPackageJson.peerDependencies)).forEach((p) => {
        if (!result[p]) {
            // extract first version expression from package's structure
            const metaVersion = Object.values(prunedDependencies[p])[0]
                .packageMeta[0];
            result[p] = metaVersion.split('@npm:')[1];
        }
    });
    return result;
}
// check if package with given version exists in pruned dependencies
function isPackageVersionMatch(packageVersions, packageName, packageVersion) {
    if (!packageVersions) {
        return false;
    }
    const versionExpr = `${packageName}@${packageVersion}`;
    const berryVersionExpr = `${packageName}@npm:${packageVersion}`;
    const values = Object.values(packageVersions);
    for (let i = 0; i < values.length; i++) {
        if (values[i].packageMeta.includes(versionExpr) ||
            values[i].packageMeta.includes(berryVersionExpr)) {
            return true;
        }
    }
    return false;
}
// find version of the package in LockFileData that matches given depVersion expression
// returns [package@version, packageValue, package@npm:version]
// for berry, the third parameter is different so we return it as well
function findDependencyTriplet(dependency, packageName, version) {
    const entries = Object.entries(dependency);
    for (let i = 0; i < entries.length; i++) {
        const [key, value] = entries[i];
        let metaVersion = `${packageName}@${version}`;
        if (value.packageMeta.includes(metaVersion)) {
            return [key, value, metaVersion];
        }
        // for berry, meta version starts with 'npm:'
        metaVersion = `${packageName}@npm:${version}`;
        if (value.packageMeta.includes(metaVersion)) {
            return [key, value, metaVersion];
        }
    }
    return;
}
function ensureMetaVersion(packageMeta, metaVersion) {
    if (packageMeta.indexOf(metaVersion) === -1) {
        return [...packageMeta, metaVersion].sort();
    }
    return packageMeta;
}
//# sourceMappingURL=yarn.js.map