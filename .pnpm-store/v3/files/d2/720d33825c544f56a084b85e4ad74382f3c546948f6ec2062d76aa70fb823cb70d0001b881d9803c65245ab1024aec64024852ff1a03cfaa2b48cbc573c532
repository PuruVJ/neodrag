{"version":3,"names":["DONE","WeakSet","declare","api","opts","assertVersion","throwIfClosureRequired","tdz","tdzEnabled","Error","name","visitor","VariableDeclaration","path","node","parent","scope","isBlockScoped","convertBlockScopedToVar","_tdzThis","nodes","i","declarations","length","decl","assign","t","assignmentExpression","cloneNode","id","init","buildUndefinedNode","skipTDZChecks","add","push","expressionStatement","addHelper","_blockHoist","isCompletionRecord","replaceWithMultiple","Loop","state","ensureBlock","blockScoping","BlockScoping","get","replace","run","replaceWith","CatchClause","ignoreBlock","isLoop","isCatchClause","buildRetCheck","template","statement","isVariableDeclaration","BLOCK_SCOPED_SYMBOL","kind","isInLoop","loopOrFunctionParent","find","isFunction","moveBindingsToParent","isFor","declar","parentScope","getFunctionParent","getProgramParent","Object","keys","getBindingIdentifiers","binding","getOwnBinding","moveBindingTo","isVar","letReferenceFunctionVisitor","traverse","visitors","merge","ReferencedIdentifier","ref","letReferences","localBinding","getBindingIdentifier","closurify","tdzVisitor","letReferenceBlockVisitor","enter","loopDepth","exit","FunctionParent","skip","hoistVarDeclarationsVisitor","self","isForStatement","pushDeclar","sequenceExpression","isForInStatement","isForOfStatement","left","map","expr","loopLabelVisitor","LabeledStatement","innerLabels","label","continuationVisitor","isAssignmentExpression","isUpdateExpression","outsideReferences","reassignments","isReturnStatement","returnStatements","loopNodeTo","isBreakStatement","isContinueStatement","loopVisitor","oldIgnoreLabeless","ignoreLabeless","Function","SwitchCase","oldInSwitchCase","inSwitchCase","loopIgnored","has","loopText","indexOf","hasBreakContinue","set","stringLiteral","hasReturn","objectExpression","objectProperty","identifier","argument","returnStatement","inherits","isStrict","isProgram","sourceType","isBlockStatement","directives","some","directive","value","constructor","loopPath","blockPath","block","outsideLetReferences","hasLetReferences","body","loopParent","loopLabel","loop","Map","isLabeledStatement","needsClosure","getLetReferences","checkConstants","updateScopeInfo","wrapClosure","remap","labeledStatement","constBindings","Set","bindings","violation","constantViolations","readOnlyError","throwNode","callExpression","operator","includes","logicalExpression","slice","binaryExpression","unaryExpression","isForXStatement","variableDeclaration","variableDeclarator","generateUidIdentifier","unshift","wrappedInClosure","blockScope","letRefs","key","getBinding","hasOwnBinding","removeBinding","outsideLetRefs","blockPathScope","parentHasBinding","hasGlobal","parentBinding","async","generator","parentPath","rename","buildCodeFrameError","outsideRefs","Array","from","delete","checkLoop","hoistVarDeclarations","args","values","params","isSwitch","type","fn","functionExpression","blockStatement","addContinuations","call","nullLiteral","basePath","hasYield","hasType","FUNCTION_TYPES","yieldExpression","hasAsync","awaitExpression","placeholderPath","index","ret","generateUid","buildHas","callPath","listKey","placeholder","fnPath","loopId","p","insertBefore","unwrapFunctionEnvironment","param","paramName","newParamName","forEach","declarators","names","addDeclarationsFromChild","isClassDeclaration","isFunctionDeclaration","declarPaths","cases","consequents","consequent","j","declars","ifStatement","RETURN"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport type { NodePath, Visitor, Scope, Binding } from \"@babel/traverse\";\nimport { skipTDZChecks, visitor as tdzVisitor } from \"./tdz\";\nimport type { TDZVisitorState } from \"./tdz\";\nimport { traverse, template, types as t } from \"@babel/core\";\nimport type { PluginPass } from \"@babel/core\";\n\nconst DONE = new WeakSet();\n\nexport interface Options {\n  tdz?: boolean;\n  throwIfClosureRequired?: boolean;\n}\n\nexport default declare((api, opts: Options) => {\n  api.assertVersion(7);\n\n  const { throwIfClosureRequired = false, tdz: tdzEnabled = false } = opts;\n  if (typeof throwIfClosureRequired !== \"boolean\") {\n    throw new Error(`.throwIfClosureRequired must be a boolean, or undefined`);\n  }\n  if (typeof tdzEnabled !== \"boolean\") {\n    throw new Error(`.tdz must be a boolean, or undefined`);\n  }\n\n  return {\n    name: \"transform-block-scoping\",\n\n    visitor: {\n      VariableDeclaration(path) {\n        const { node, parent, scope } = path;\n        if (!isBlockScoped(node)) return;\n        convertBlockScopedToVar(path, null, parent, scope, true);\n\n        // @ts-expect-error todo(flow->ts): avoid mutations\n        if (node._tdzThis) {\n          const nodes: t.Node[] = [node];\n\n          for (let i = 0; i < node.declarations.length; i++) {\n            const decl = node.declarations[i];\n            const assign = t.assignmentExpression(\n              \"=\",\n              t.cloneNode(decl.id),\n              decl.init || scope.buildUndefinedNode(),\n            );\n            skipTDZChecks.add(assign);\n            nodes.push(t.expressionStatement(assign));\n            decl.init = this.addHelper(\"temporalUndefined\");\n          }\n\n          // @ts-expect-error todo(flow->ts): avoid mutations\n          node._blockHoist = 2;\n\n          if (path.isCompletionRecord()) {\n            // ensure we don't break completion record semantics by returning\n            // the initialiser of the last declarator\n            nodes.push(t.expressionStatement(scope.buildUndefinedNode()));\n          }\n\n          path.replaceWithMultiple(nodes);\n        }\n      },\n\n      Loop(path: NodePath<t.Loop>, state) {\n        const { parent, scope } = path;\n        path.ensureBlock();\n        const blockScoping = new BlockScoping(\n          path,\n          path.get(\"body\"),\n          parent,\n          scope,\n          throwIfClosureRequired,\n          tdzEnabled,\n          state,\n        );\n        const replace = blockScoping.run();\n        if (replace) path.replaceWith(replace);\n      },\n\n      CatchClause(path, state) {\n        const { parent, scope } = path;\n        const blockScoping = new BlockScoping(\n          null,\n          path.get(\"body\"),\n          parent,\n          scope,\n          throwIfClosureRequired,\n          tdzEnabled,\n          state,\n        );\n        blockScoping.run();\n      },\n\n      \"BlockStatement|SwitchStatement|Program\"(\n        path: NodePath<t.BlockStatement | t.SwitchStatement | t.Program>,\n        state,\n      ) {\n        if (!ignoreBlock(path)) {\n          const blockScoping = new BlockScoping(\n            null,\n            path,\n            path.parent,\n            path.scope,\n            throwIfClosureRequired,\n            tdzEnabled,\n            state,\n          );\n          blockScoping.run();\n        }\n      },\n    },\n  };\n});\n\nfunction ignoreBlock(\n  path: NodePath<t.BlockStatement | t.SwitchStatement | t.Program>,\n) {\n  return t.isLoop(path.parent) || t.isCatchClause(path.parent);\n}\n\nconst buildRetCheck = template.statement(`\n  if (typeof RETURN === \"object\") return RETURN.v;\n`);\n\nfunction isBlockScoped(node: t.Node): node is t.VariableDeclaration {\n  if (!t.isVariableDeclaration(node)) return false;\n  if (\n    // @ts-expect-error Fixme: document symbol properties\n    node[t.BLOCK_SCOPED_SYMBOL]\n  ) {\n    return true;\n  }\n\n  if (node.kind !== \"let\" && node.kind !== \"const\" && node.kind !== \"using\") {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * If there is a loop ancestor closer than the closest function, we\n * consider ourselves to be in a loop.\n */\nfunction isInLoop(path: NodePath) {\n  const loopOrFunctionParent = path.find(\n    path => path.isLoop() || path.isFunction(),\n  );\n\n  return loopOrFunctionParent?.isLoop();\n}\n\nfunction convertBlockScopedToVar(\n  path: NodePath<t.VariableDeclaration>,\n  node: t.VariableDeclaration,\n  parent: t.Node,\n  scope: Scope,\n  moveBindingsToParent = false,\n) {\n  if (!node) {\n    node = path.node;\n  }\n\n  // https://github.com/babel/babel/issues/255\n  if (isInLoop(path) && !t.isFor(parent)) {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      declar.init = declar.init || scope.buildUndefinedNode();\n    }\n  }\n\n  // @ts-expect-error todo(flow->ts): avoid mutations\n  node[t.BLOCK_SCOPED_SYMBOL] = true;\n  node.kind = \"var\";\n\n  // Move bindings from current block scope to function scope.\n  if (moveBindingsToParent) {\n    const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n    for (const name of Object.keys(path.getBindingIdentifiers())) {\n      const binding = scope.getOwnBinding(name);\n      if (binding) binding.kind = \"var\";\n      scope.moveBindingTo(name, parentScope);\n    }\n  }\n}\n\nfunction isVar(node: t.Node): node is t.VariableDeclaration {\n  return t.isVariableDeclaration(node, { kind: \"var\" }) && !isBlockScoped(node);\n}\n\ninterface LetReferenceVisitorState extends TDZVisitorState {\n  loopDepth: number;\n  closurify: boolean;\n}\n\nconst letReferenceFunctionVisitor = traverse.visitors.merge([\n  {\n    ReferencedIdentifier(path, state) {\n      const ref = state.letReferences.get(path.node.name);\n\n      // not a part of our scope\n      if (!ref) return;\n\n      // this scope has a variable with the same name so it couldn't belong\n      // to our let scope\n      const localBinding = path.scope.getBindingIdentifier(path.node.name);\n      if (localBinding && localBinding !== ref) return;\n\n      state.closurify = true;\n    },\n  },\n  tdzVisitor,\n] as Visitor<LetReferenceVisitorState>[]);\n\nconst letReferenceBlockVisitor = traverse.visitors.merge([\n  {\n    Loop: {\n      enter(path, state) {\n        state.loopDepth++;\n      },\n      exit(path, state) {\n        state.loopDepth--;\n      },\n    },\n    FunctionParent(path, state) {\n      // References to block-scoped variables only require added closures if it's\n      // possible for the code to run more than once -- otherwise it is safe to\n      // simply rename the variables.\n      if (state.loopDepth > 0) {\n        path.traverse(letReferenceFunctionVisitor, state);\n      } else {\n        path.traverse(tdzVisitor, state);\n      }\n      return path.skip();\n    },\n  },\n  tdzVisitor,\n] as Visitor<LetReferenceVisitorState>[]);\n\nconst hoistVarDeclarationsVisitor: Visitor<BlockScoping> = {\n  enter(path, self) {\n    if (path.isForStatement()) {\n      const { node } = path;\n      if (isVar(node.init)) {\n        const nodes = self.pushDeclar(node.init);\n        if (nodes.length === 1) {\n          node.init = nodes[0];\n        } else {\n          node.init = t.sequenceExpression(nodes);\n        }\n      }\n    } else if (path.isForInStatement() || path.isForOfStatement()) {\n      const { node } = path;\n      if (isVar(node.left)) {\n        self.pushDeclar(node.left);\n        node.left = node.left.declarations[0].id;\n      }\n    } else if (isVar(path.node)) {\n      path.replaceWithMultiple(\n        self.pushDeclar(path.node).map(expr => t.expressionStatement(expr)),\n      );\n    } else if (path.isFunction()) {\n      return path.skip();\n    }\n  },\n};\n\ntype LoopVisitorState = {\n  inSwitchCase: boolean;\n  hasBreakContinue: boolean;\n  innerLabels: string[];\n  hasReturn: boolean;\n  ignoreLabeless: boolean;\n  loopIgnored: WeakSet<t.Node>;\n  isLoop: boolean;\n  map: Map<string, t.BreakStatement | t.ContinueStatement>;\n};\n\nconst loopLabelVisitor: Visitor<LoopVisitorState> = {\n  LabeledStatement({ node }, state) {\n    state.innerLabels.push(node.label.name);\n  },\n};\n\ninterface ContinuationVisitorState {\n  returnStatements: NodePath<t.ReturnStatement>[];\n  reassignments: { [k: string]: boolean | undefined };\n  outsideReferences: Map<string, t.Identifier>;\n}\n\nconst continuationVisitor: Visitor<ContinuationVisitorState> = {\n  enter(path, state) {\n    if (path.isAssignmentExpression() || path.isUpdateExpression()) {\n      for (const name of Object.keys(path.getBindingIdentifiers())) {\n        if (\n          state.outsideReferences.get(name) !==\n          path.scope.getBindingIdentifier(name)\n        ) {\n          continue;\n        }\n        state.reassignments[name] = true;\n      }\n    } else if (path.isReturnStatement()) {\n      state.returnStatements.push(path);\n    }\n  },\n};\n\nfunction loopNodeTo(node: t.Node) {\n  if (t.isBreakStatement(node)) {\n    return \"break\";\n  } else if (t.isContinueStatement(node)) {\n    return \"continue\";\n  }\n}\n\nconst loopVisitor: Visitor<LoopVisitorState> = {\n  Loop(path, state) {\n    const oldIgnoreLabeless = state.ignoreLabeless;\n    state.ignoreLabeless = true;\n    path.traverse(loopVisitor, state);\n    state.ignoreLabeless = oldIgnoreLabeless;\n    path.skip();\n  },\n\n  Function(path) {\n    path.skip();\n  },\n\n  SwitchCase(path, state) {\n    const oldInSwitchCase = state.inSwitchCase;\n    state.inSwitchCase = true;\n    path.traverse(loopVisitor, state);\n    state.inSwitchCase = oldInSwitchCase;\n    path.skip();\n  },\n\n  \"BreakStatement|ContinueStatement|ReturnStatement\"(\n    path: NodePath<t.BreakStatement | t.ContinueStatement | t.ReturnStatement>,\n    state,\n  ) {\n    const { node, scope } = path;\n    if (state.loopIgnored.has(node)) return;\n\n    let replace;\n    let loopText = loopNodeTo(node);\n\n    if (loopText) {\n      if (t.isReturnStatement(node)) {\n        throw new Error(\n          \"Internal error: unexpected return statement with `loopText`\",\n        );\n      }\n      if (node.label) {\n        // we shouldn't be transforming this because it exists somewhere inside\n        if (state.innerLabels.indexOf(node.label.name) >= 0) {\n          return;\n        }\n\n        loopText = `${loopText}|${node.label.name}`;\n      } else {\n        // we shouldn't be transforming these statements because\n        // they don't refer to the actual loop we're scopifying\n        if (state.ignoreLabeless) return;\n\n        // break statements mean something different in this context\n        if (t.isBreakStatement(node) && state.inSwitchCase) return;\n      }\n\n      state.hasBreakContinue = true;\n      state.map.set(loopText, node);\n      replace = t.stringLiteral(loopText);\n    }\n\n    if (t.isReturnStatement(node)) {\n      state.hasReturn = true;\n      replace = t.objectExpression([\n        t.objectProperty(\n          t.identifier(\"v\"),\n          node.argument || scope.buildUndefinedNode(),\n        ),\n      ]);\n    }\n\n    if (replace) {\n      replace = t.returnStatement(replace);\n      state.loopIgnored.add(replace);\n      path.skip();\n      path.replaceWith(t.inherits(replace, node));\n    }\n  },\n};\n\nfunction isStrict(path: NodePath) {\n  return !!path.find(({ node }) => {\n    if (t.isProgram(node)) {\n      if (node.sourceType === \"module\") return true;\n    } else if (!t.isBlockStatement(node)) return false;\n\n    return node.directives.some(\n      directive => directive.value.value === \"use strict\",\n    );\n  });\n}\n\nclass BlockScoping {\n  private parent: t.Node;\n  private state: PluginPass;\n  private scope: Scope;\n  private throwIfClosureRequired: boolean;\n  private tdzEnabled: boolean;\n  private blockPath: NodePath<t.Block | t.SwitchStatement>;\n  private block: t.Block | t.SwitchStatement;\n  private outsideLetReferences: Map<string, t.Identifier>;\n  private hasLetReferences: boolean;\n  private letReferences: Map<string, t.Identifier>;\n  private body: t.Statement[];\n  // todo(flow->ts) add more specific type\n  private loopParent: t.Node;\n  private loopLabel: t.Identifier;\n  private loopPath: NodePath<t.Loop>;\n  private loop: t.Loop;\n  private has: LoopVisitorState;\n  constructor(\n    loopPath: NodePath<t.Loop> | undefined | null,\n    blockPath: NodePath<t.Block | t.SwitchStatement>,\n    parent: t.Node,\n    scope: Scope,\n    throwIfClosureRequired: boolean,\n    tdzEnabled: boolean,\n    state: PluginPass,\n  ) {\n    this.parent = parent;\n    this.scope = scope;\n    this.state = state;\n    this.throwIfClosureRequired = throwIfClosureRequired;\n    this.tdzEnabled = tdzEnabled;\n\n    this.blockPath = blockPath;\n    this.block = blockPath.node;\n\n    this.outsideLetReferences = new Map();\n    this.hasLetReferences = false;\n    this.letReferences = new Map();\n    this.body = [];\n\n    if (loopPath) {\n      this.loopParent = loopPath.parent;\n      this.loopLabel =\n        t.isLabeledStatement(this.loopParent) && this.loopParent.label;\n      this.loopPath = loopPath;\n      this.loop = loopPath.node;\n    }\n  }\n\n  /**\n   * Start the ball rolling.\n   */\n\n  run() {\n    const block = this.block;\n    if (DONE.has(block)) return;\n    DONE.add(block);\n\n    const needsClosure = this.getLetReferences();\n\n    this.checkConstants();\n\n    // this is a block within a `Function/Program` so we can safely leave it be\n    if (t.isFunction(this.parent) || t.isProgram(this.block)) {\n      this.updateScopeInfo();\n      return;\n    }\n\n    // we can skip everything\n    if (!this.hasLetReferences) return;\n\n    if (needsClosure) {\n      this.wrapClosure();\n    } else {\n      this.remap();\n    }\n\n    this.updateScopeInfo(needsClosure);\n\n    if (this.loopLabel && !t.isLabeledStatement(this.loopParent)) {\n      return t.labeledStatement(this.loopLabel, this.loop);\n    }\n  }\n\n  checkConstants() {\n    const constBindings = new Map<string, Binding>();\n\n    // In some cases, there are two different scopes: for example,\n    // for (const x of y) {} has a scope for the loop head and one\n    // for the body.\n    for (const scope of new Set([this.scope, this.blockPath.scope])) {\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        if (binding.kind === \"const\") constBindings.set(name, binding);\n      }\n    }\n\n    const { state } = this;\n\n    for (const [name, binding] of constBindings) {\n      for (const violation of binding.constantViolations) {\n        const readOnlyError = state.addHelper(\"readOnlyError\");\n        const throwNode = t.callExpression(readOnlyError, [\n          t.stringLiteral(name),\n        ]);\n\n        if (violation.isAssignmentExpression()) {\n          const { operator } = violation.node;\n          if (operator === \"=\") {\n            violation.replaceWith(\n              t.sequenceExpression([violation.get(\"right\").node, throwNode]),\n            );\n          } else if ([\"&&=\", \"||=\", \"??=\"].includes(operator)) {\n            violation.replaceWith(\n              t.logicalExpression(\n                // @ts-expect-error todo(flow->ts)\n                operator.slice(0, -1),\n                violation.get(\"left\").node,\n                t.sequenceExpression([violation.get(\"right\").node, throwNode]),\n              ),\n            );\n          } else {\n            violation.replaceWith(\n              t.sequenceExpression([\n                t.binaryExpression(\n                  // @ts-expect-error todo(flow->ts)\n                  operator.slice(0, -1),\n                  violation.get(\"left\").node,\n                  violation.get(\"right\").node,\n                ),\n                throwNode,\n              ]),\n            );\n          }\n        } else if (violation.isUpdateExpression()) {\n          violation.replaceWith(\n            t.sequenceExpression([\n              t.unaryExpression(\"+\", violation.get(\"argument\").node),\n              throwNode,\n            ]),\n          );\n        } else if (violation.isForXStatement()) {\n          // @ts-expect-error TS requires explicit annotation of \"violation\"\n          violation.ensureBlock();\n          violation\n            .get(\"left\")\n            .replaceWith(\n              t.variableDeclaration(\"var\", [\n                t.variableDeclarator(\n                  violation.scope.generateUidIdentifier(name),\n                ),\n              ]),\n            );\n          // @ts-expect-error todo(flow->ts): possible bug \"for(…) switch(){}\"\n          violation.node.body.body.unshift(t.expressionStatement(throwNode));\n        }\n      }\n    }\n  }\n\n  updateScopeInfo(wrappedInClosure?: boolean) {\n    const blockScope = this.blockPath.scope;\n\n    const parentScope =\n      blockScope.getFunctionParent() || blockScope.getProgramParent();\n    const letRefs = this.letReferences;\n\n    for (const key of letRefs.keys()) {\n      const ref = letRefs.get(key);\n      const binding = blockScope.getBinding(ref.name);\n      if (!binding) continue;\n      if (binding.kind === \"let\" || binding.kind === \"const\") {\n        binding.kind = \"var\";\n\n        if (wrappedInClosure) {\n          if (blockScope.hasOwnBinding(ref.name)) {\n            blockScope.removeBinding(ref.name);\n          }\n        } else {\n          blockScope.moveBindingTo(ref.name, parentScope);\n        }\n      }\n    }\n  }\n\n  remap() {\n    const letRefs = this.letReferences;\n    const outsideLetRefs = this.outsideLetReferences;\n    const scope = this.scope;\n    const blockPathScope = this.blockPath.scope;\n\n    // alright, so since we aren't wrapping this block in a closure\n    // we have to check if any of our let variables collide with\n    // those in upper scopes and then if they do, generate a uid\n    // for them and replace all references with it\n\n    for (const key of letRefs.keys()) {\n      // just an Identifier node we collected in `getLetReferences`\n      // this is the defining identifier of a declaration\n      const ref = letRefs.get(key);\n\n      // todo: could skip this if the colliding binding is in another function\n      if (scope.parentHasBinding(key) || scope.hasGlobal(key)) {\n        const binding = scope.getOwnBinding(key);\n        if (binding) {\n          const parentBinding = scope.parent.getOwnBinding(key);\n          if (\n            binding.kind === \"hoisted\" &&\n            // @ts-expect-error todo(flow->ts)\n            !binding.path.node.async &&\n            // @ts-expect-error todo(flow->ts)\n            !binding.path.node.generator &&\n            (!parentBinding || isVar(parentBinding.path.parent)) &&\n            !isStrict(binding.path.parentPath)\n          ) {\n            continue;\n          }\n          // The same identifier might have been bound separately in the block scope and\n          // the enclosing scope (e.g. loop or catch statement), so we should handle both\n          // individually\n          scope.rename(ref.name);\n        }\n\n        if (blockPathScope.hasOwnBinding(key)) {\n          blockPathScope.rename(ref.name);\n        }\n      }\n    }\n\n    for (const key of outsideLetRefs.keys()) {\n      const ref = letRefs.get(key);\n      // check for collisions with a for loop's init variable and the enclosing scope's bindings\n      // https://github.com/babel/babel/issues/8498\n      if (isInLoop(this.blockPath) && blockPathScope.hasOwnBinding(key)) {\n        blockPathScope.rename(ref.name);\n      }\n    }\n  }\n\n  wrapClosure() {\n    if (this.throwIfClosureRequired) {\n      throw this.blockPath.buildCodeFrameError(\n        \"Compiling let/const in this block would add a closure \" +\n          \"(throwIfClosureRequired).\",\n      );\n    }\n    const block = this.block;\n\n    const outsideRefs = this.outsideLetReferences;\n\n    // remap loop heads with colliding variables\n    if (this.loop) {\n      // nb: clone outsideRefs keys since the map is modified within the loop\n      for (const name of Array.from(outsideRefs.keys())) {\n        const id = outsideRefs.get(name);\n\n        if (\n          this.scope.hasGlobal(id.name) ||\n          this.scope.parentHasBinding(id.name)\n        ) {\n          outsideRefs.delete(id.name);\n          this.letReferences.delete(id.name);\n\n          this.scope.rename(id.name);\n\n          this.letReferences.set(id.name, id);\n          outsideRefs.set(id.name, id);\n        }\n      }\n    }\n\n    // if we're inside of a for loop then we search to see if there are any\n    // `break`s, `continue`s, `return`s etc\n    this.has = this.checkLoop();\n\n    // hoist let references to retain scope\n    this.hoistVarDeclarations();\n\n    // turn outsideLetReferences into an array\n    const args = Array.from(outsideRefs.values(), node => t.cloneNode(node));\n    const params = args.map(id => t.cloneNode(id));\n\n    const isSwitch = block.type === \"SwitchStatement\";\n\n    // build the closure that we're going to wrap the block with, possible wrapping switch(){}\n    const fn = t.functionExpression(\n      null,\n      params,\n      t.blockStatement(isSwitch ? [block] : block.body),\n    ) as t.FunctionExpression & { params: t.Identifier[] };\n\n    // continuation\n    this.addContinuations(fn);\n\n    let call: t.CallExpression | t.YieldExpression | t.AwaitExpression =\n      t.callExpression(t.nullLiteral(), args);\n    let basePath = \".callee\";\n\n    // handle generators\n    const hasYield = traverse.hasType(\n      fn.body,\n      \"YieldExpression\",\n      t.FUNCTION_TYPES,\n    );\n    if (hasYield) {\n      fn.generator = true;\n      call = t.yieldExpression(call, true);\n      basePath = \".argument\" + basePath;\n    }\n\n    // handlers async functions\n    const hasAsync = traverse.hasType(\n      fn.body,\n      \"AwaitExpression\",\n      t.FUNCTION_TYPES,\n    );\n    if (hasAsync) {\n      fn.async = true;\n      call = t.awaitExpression(call);\n      basePath = \".argument\" + basePath;\n    }\n\n    let placeholderPath;\n    let index;\n    if (this.has.hasReturn || this.has.hasBreakContinue) {\n      const ret = this.scope.generateUid(\"ret\");\n\n      this.body.push(\n        t.variableDeclaration(\"var\", [\n          t.variableDeclarator(t.identifier(ret), call),\n        ]),\n      );\n      placeholderPath = \"declarations.0.init\" + basePath;\n      index = this.body.length - 1;\n\n      this.buildHas(ret);\n    } else {\n      this.body.push(t.expressionStatement(call));\n      placeholderPath = \"expression\" + basePath;\n      index = this.body.length - 1;\n    }\n\n    let callPath: NodePath;\n    // replace the current block body with the one we're going to build\n    if (isSwitch) {\n      const { parentPath, listKey, key } = this.blockPath;\n\n      this.blockPath.replaceWithMultiple(this.body);\n      callPath = parentPath.get(listKey)[(key as number) + index];\n    } else {\n      block.body = this.body;\n      callPath = this.blockPath.get(\"body\")[index];\n    }\n\n    const placeholder = callPath.get(placeholderPath) as NodePath;\n\n    let fnPath;\n    if (this.loop) {\n      const loopId = this.scope.generateUid(\"loop\");\n      const p = this.loopPath.insertBefore(\n        t.variableDeclaration(\"var\", [\n          t.variableDeclarator(t.identifier(loopId), fn),\n        ]),\n      );\n\n      placeholder.replaceWith(t.identifier(loopId));\n      fnPath = p[0].get(\"declarations.0.init\");\n    } else {\n      placeholder.replaceWith(fn);\n      fnPath = placeholder;\n    }\n\n    // Ensure \"this\", \"arguments\", and \"super\" continue to work in the wrapped function.\n    fnPath.unwrapFunctionEnvironment();\n  }\n\n  /**\n   * If any of the outer let variables are reassigned then we need to rename them in\n   * the closure so we can get direct access to the outer variable to continue the\n   * iteration with bindings based on each iteration.\n   *\n   * Reference: https://github.com/babel/babel/issues/1078\n   */\n\n  addContinuations(fn: t.FunctionExpression & { params: t.Identifier[] }) {\n    const state: ContinuationVisitorState = {\n      reassignments: {},\n      returnStatements: [],\n      outsideReferences: this.outsideLetReferences,\n    };\n\n    this.scope.traverse(fn, continuationVisitor, state);\n\n    for (let i = 0; i < fn.params.length; i++) {\n      const param = fn.params[i];\n      if (!state.reassignments[param.name]) continue;\n\n      const paramName = param.name;\n      const newParamName = this.scope.generateUid(param.name);\n      fn.params[i] = t.identifier(newParamName);\n\n      this.scope.rename(paramName, newParamName, fn);\n\n      state.returnStatements.forEach(returnStatement => {\n        returnStatement.insertBefore(\n          t.expressionStatement(\n            t.assignmentExpression(\n              \"=\",\n              t.identifier(paramName),\n              t.identifier(newParamName),\n            ),\n          ),\n        );\n      });\n\n      // assign outer reference as it's been modified internally and needs to be retained\n      fn.body.body.push(\n        t.expressionStatement(\n          t.assignmentExpression(\n            \"=\",\n            t.identifier(paramName),\n            t.identifier(newParamName),\n          ),\n        ),\n      );\n    }\n  }\n\n  getLetReferences() {\n    const block = this.block;\n\n    const declarators = [];\n\n    if (this.loop) {\n      // @ts-expect-error todo(flow->ts) add check for loop type\n      const init = this.loop.left || this.loop.init;\n      if (isBlockScoped(init)) {\n        declarators.push(init);\n        const names = t.getBindingIdentifiers(init);\n        for (const name of Object.keys(names)) {\n          this.outsideLetReferences.set(name, names[name]);\n        }\n      }\n    }\n\n    const addDeclarationsFromChild = (\n      path: NodePath<t.Statement | t.SwitchCase>,\n      node: t.Statement | t.SwitchCase,\n    ) => {\n      if (\n        t.isClassDeclaration(node) ||\n        t.isFunctionDeclaration(node) ||\n        isBlockScoped(node)\n      ) {\n        if (isBlockScoped(node)) {\n          convertBlockScopedToVar(\n            path as NodePath<t.VariableDeclaration>,\n            node,\n            block,\n            this.scope,\n          );\n        }\n        if (node.type === \"VariableDeclaration\") {\n          for (let i = 0; i < node.declarations.length; i++) {\n            declarators.push(node.declarations[i]);\n          }\n        } else {\n          declarators.push(node);\n        }\n      }\n      if (t.isLabeledStatement(node)) {\n        addDeclarationsFromChild(path.get(\"body\"), node.body);\n      }\n    };\n\n    if (block.type === \"SwitchStatement\") {\n      const declarPaths = (this.blockPath as NodePath<t.SwitchStatement>).get(\n        \"cases\",\n      );\n      for (let i = 0; i < block.cases.length; i++) {\n        const consequents = block.cases[i].consequent;\n\n        for (let j = 0; j < consequents.length; j++) {\n          const declar = consequents[j];\n          addDeclarationsFromChild(declarPaths[i], declar);\n        }\n      }\n    } else {\n      const declarPaths = (this.blockPath as NodePath<t.Block>).get(\"body\");\n      for (let i = 0; i < block.body.length; i++) {\n        addDeclarationsFromChild(declarPaths[i], declarPaths[i].node);\n      }\n    }\n\n    //\n    for (let i = 0; i < declarators.length; i++) {\n      const declar = declarators[i];\n      // Passing true as the third argument causes t.getBindingIdentifiers\n      // to return only the *outer* binding identifiers of this\n      // declaration, rather than (for example) mistakenly including the\n      // parameters of a function declaration. Fixes #4880.\n      const keys = t.getBindingIdentifiers(declar, false, true);\n      for (const key of Object.keys(keys)) {\n        this.letReferences.set(key, keys[key]);\n      }\n      this.hasLetReferences = true;\n    }\n\n    // no let references so we can just quit\n    if (!this.hasLetReferences) return;\n\n    const state: LetReferenceVisitorState = {\n      letReferences: this.letReferences,\n      closurify: false,\n      loopDepth: 0,\n      tdzEnabled: this.tdzEnabled,\n      addHelper: name => this.state.addHelper(name),\n    };\n\n    if (isInLoop(this.blockPath)) {\n      state.loopDepth++;\n    }\n\n    // traverse through this block, stopping on functions and checking if they\n    // contain any local let references\n    this.blockPath.traverse(letReferenceBlockVisitor, state);\n\n    return state.closurify;\n  }\n\n  /**\n   * If we're inside of a loop then traverse it and check if it has one of\n   * the following node types `ReturnStatement`, `BreakStatement`,\n   * `ContinueStatement` and replace it with a return value that we can track\n   * later on.\n   */\n\n  checkLoop() {\n    const state: LoopVisitorState = {\n      hasBreakContinue: false,\n      ignoreLabeless: false,\n      inSwitchCase: false,\n      innerLabels: [],\n      hasReturn: false,\n      isLoop: !!this.loop,\n      map: new Map(),\n      loopIgnored: new WeakSet(),\n    };\n\n    this.blockPath.traverse(loopLabelVisitor, state);\n    this.blockPath.traverse(loopVisitor, state);\n\n    return state;\n  }\n\n  /**\n   * Hoist all let declarations in this block to before it so they retain scope\n   * once we wrap everything in a closure.\n   */\n\n  hoistVarDeclarations() {\n    this.blockPath.traverse(hoistVarDeclarationsVisitor, this);\n  }\n\n  /**\n   * Turn a `VariableDeclaration` into an array of `AssignmentExpressions` with\n   * their declarations hoisted to before the closure wrapper.\n   */\n\n  pushDeclar(node: t.VariableDeclaration): Array<t.AssignmentExpression> {\n    const declars = [];\n    const names = t.getBindingIdentifiers(node);\n    for (const name of Object.keys(names)) {\n      declars.push(t.variableDeclarator(names[name]));\n    }\n\n    this.body.push(t.variableDeclaration(node.kind, declars));\n\n    const replace = [];\n\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      if (!declar.init) continue;\n\n      const expr = t.assignmentExpression(\n        \"=\",\n        t.cloneNode(declar.id),\n        t.cloneNode(declar.init),\n      );\n      replace.push(t.inherits(expr, declar));\n    }\n\n    return replace;\n  }\n\n  buildHas(ret: string) {\n    const body = this.body;\n    const has = this.has;\n\n    if (has.hasBreakContinue) {\n      for (const key of has.map.keys()) {\n        body.push(\n          t.ifStatement(\n            t.binaryExpression(\"===\", t.identifier(ret), t.stringLiteral(key)),\n            has.map.get(key),\n          ),\n        );\n      }\n    }\n\n    // typeof ret === \"object\"\n    if (has.hasReturn) {\n      body.push(\n        buildRetCheck({\n          RETURN: t.identifier(ret),\n        }),\n      );\n    }\n  }\n}\n"],"mappings":"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"}