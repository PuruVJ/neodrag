---
title: 'Introduction'
tagline: 'Neodrag plugins, and how to author them.'
---

import FrameworkSwitch from '$components/FrameworkSwitch.astro';

## What are Plugins?

Think of plugins as Lego blocks for dragging behavior. Instead of having one giant library that does everything, Neodrag v3 breaks things down into small, focused pieces that you can mix and match.

Want grid snapping? Add the `grid()` plugin. Need to constrain movement? Use `bounds()`. Want both? Just use them together. This keeps your bundle small and your code clean.

> **Note:** In this documentation, we assume `draggable` is available in your framework. Svelte provides this automatically, while other frameworks need you to import the appropriate hook or directive.

## Built-in Plugins

Neodrag comes with plugins for common drag behaviors. Here's how you use them:

<FrameworkSwitch>
<div slot="svelte">

```svelte
<script>
  import { grid, axis, bounds, BoundsFrom } from '@neodrag/svelte';
</script>

<div
  {@attach draggable([
    grid([20, 20]), // Snap to 20px grid
    axis('x'), // Only move horizontally
    bounds(BoundsFrom.viewport()), // Stay in viewport
  ])}
>
  Drag me around!
</div>
```

</div>

<div slot="react">

```tsx
import { useRef } from 'react';
import {
  grid,
  axis,
  bounds,
  BoundsFrom,
  useDraggable,
} from '@neodrag/react';

function MyComponent() {
  const dragRef = useRef<HTMLDivElement>(null);

  const dragState = useDraggable(dragRef, [
    grid([20, 20]), // Snap to 20px grid
    axis('x'), // Only move horizontally
    bounds(BoundsFrom.viewport()), // Stay in viewport
  ]);

  return <div ref={dragRef}>Drag me around!</div>;
}
```

</div>

<div slot="vue">

```vue
<script setup>
import {
  grid,
  axis,
  bounds,
  BoundsFrom,
  vDraggable,
} from '@neodrag/vue';
</script>

<template>
  <div
    v-draggable="[
      grid([20, 20]),
      axis('x'),
      bounds(BoundsFrom.viewport()),
    ]"
  >
    Drag me around!
  </div>
</template>
```

</div>

<div slot="solid">

```tsx
import {
  grid,
  axis,
  bounds,
  BoundsFrom,
  useDraggable,
} from '@neodrag/solid';
import { createSignal } from 'solid-js';

function MyComponent() {
  const [element, setElement] = createSignal<HTMLDivElement>();

  const dragState = useDraggable(element, [
    grid([20, 20]), // Snap to 20px grid
    axis('x'), // Only move horizontally
    bounds(BoundsFrom.viewport()), // Stay in viewport
  ]);

  return <div ref={setElement}>Drag me around!</div>;
}
```

</div>

<div slot="vanilla">

```typescript
import {
  grid,
  axis,
  bounds,
  BoundsFrom,
  Draggable,
} from '@neodrag/vanilla';

const element = document.getElementById('my-draggable');
const instance = new Draggable(element, [
  grid([20, 20]), // Snap to 20px grid
  axis('x'), // Only move horizontally
  bounds(BoundsFrom.viewport()), // Stay in viewport
]);
```

</div>
</FrameworkSwitch>

That's it! You just created a draggable that snaps to a grid, only moves horizontally, and stays within the browser window.

## Built-in Plugins You Can Use

Here are the main plugins that come with Neodrag:

**Movement Control:**

- `axis('x' | 'y')` - Lock movement to one direction
- `grid([x, y])` - Snap to grid points
- `bounds(area)` - Keep element within boundaries
- `threshold({ distance: 10, delay: 100 })` - Control when dragging starts

**Visual & Interaction:**

- `disabled()` - Turn off dragging completely
- `controls({ allow: selector })` - Only drag from specific areas
- `events({ onDrag, onDragStart, onDragEnd })` - Get notified of drag events

**System Plugins (included by default):**

- `transform()` - Actually moves the element
- `touchAction()` - Handles mobile touch behavior
- `applyUserSelectHack()` - Prevents text selection while dragging

You can also remove default plugins if you don't need them, but `transform()` is usually required unless you're handling movement yourself.

## Dynamic Updates

Want to change plugin behavior while the user is dragging? Use Compartments:

<FrameworkSwitch>
<div slot="svelte">

```svelte
<script>
  import { axis, Compartment } from '@neodrag/svelte';

  let currentAxis = $state('x');
  const axisCompartment = Compartment.of(() => axis(currentAxis));
</script>

<div {@attach draggable(() => [axisCompartment])}>Drag me!</div>

<button onclick={() => (currentAxis = 'y')}>
  Switch to Y axis
</button>
```

</div>

<div slot="react">

```tsx
import { useRef, useState } from 'react';
import { axis, useDraggable, useCompartment } from '@neodrag/react';

function MyComponent() {
  const dragRef = useRef<HTMLDivElement>(null);
  const [currentAxis, setCurrentAxis] = useState('x');

  const axisCompartment = useCompartment(
    () => axis(currentAxis),
    [currentAxis],
  );

  const dragState = useDraggable(dragRef, () => [axisCompartment]);

  return (
    <div>
      <div ref={dragRef}>Drag me!</div>
      <button onClick={() => setCurrentAxis('y')}>
        Switch to Y axis
      </button>
    </div>
  );
}
```

</div>

<div slot="vue">

```vue
<script setup>
import { ref } from 'vue';
import { axis, vDraggable, useCompartment } from '@neodrag/vue';

const currentAxis = ref('x');
const axisCompartment = useCompartment(() => axis(currentAxis.value));

const plugins = () => [axisCompartment];
</script>

<template>
  <div>
    <div v-draggable="plugins">Drag me!</div>
    <button @click="currentAxis = 'y'">Switch to Y axis</button>
  </div>
</template>
```

</div>

<div slot="solid">

```tsx
import { createSignal } from 'solid-js';
import {
  axis,
  useDraggable,
  createCompartment,
} from '@neodrag/solid';

function MyComponent() {
  const [element, setElement] = createSignal<HTMLDivElement>();
  const [currentAxis, setCurrentAxis] = createSignal('x');

  const axisCompartment = createCompartment(() =>
    axis(currentAxis()),
  );

  const dragState = useDraggable(element, [axisCompartment]);

  return (
    <div>
      <div ref={setElement}>Drag me!</div>
      <button onClick={() => setCurrentAxis('y')}>
        Switch to Y axis
      </button>
    </div>
  );
}
```

</div>

<div slot="vanilla">

```typescript
import { Compartment, axis, Draggable } from '@neodrag/vanilla';

let currentAxis = 'x';
const axisCompartment = new Compartment(() => axis(currentAxis));

const element = document.getElementById('my-draggable');
const instance = new Draggable(element, () => [axisCompartment]);

// Later, update the axis
currentAxis = 'y';
axisCompartment.current = axis(currentAxis);
```

</div>
</FrameworkSwitch>

Compartments let you update individual plugins without recreating the whole drag system. This is especially useful for reactive UIs.

> **⚠️ Important:** Automatic updates no longer work in v3! Simply changing plugin options or recreating plugin arrays won't update the draggable. You must use Compartments for dynamic behavior.

## Writing Plugins

Let's create a simple plugin that logs drag events:

```typescript
const logger = {
  name: 'my:logger',

  start(ctx, state, event) {
    console.log('Started dragging at:', ctx.initial.x, ctx.initial.y);
  },

  drag(ctx, state, event) {
    console.log('Current position:', ctx.offset.x, ctx.offset.y);
  },

  end(ctx, state, event) {
    console.log('Stopped dragging at:', ctx.offset.x, ctx.offset.y);
  },
};
```

Then use it like any other plugin:

<FrameworkSwitch>
<div slot="svelte">

```svelte
<div {@attach draggable([logger])}>
  Check your console while dragging!
</div>
```

</div>

<div slot="react">

```tsx
const dragState = useDraggable(dragRef, [logger]);
```

</div>

<div slot="vue">

```vue
<div v-draggable="[logger]">
  Check your console while dragging!
</div>
```

</div>

<div slot="solid">

```tsx
const dragState = useDraggable(element, [logger]);
```

</div>

<div slot="vanilla">

```typescript
const instance = new Draggable(element, [logger]);
```

</div>
</FrameworkSwitch>

Want to make it configurable? Use the plugin factory:

```typescript
import { unstable_definePlugin } from '@neodrag/core/plugins';

const logger = unstable_definePlugin((prefix = 'DRAG') => ({
  name: 'my:logger',

  start(ctx) {
    console.log(
      `${prefix}: Started at`,
      ctx.initial.x,
      ctx.initial.y,
    );
  },

  drag(ctx) {
    console.log(`${prefix}: Moving to`, ctx.offset.x, ctx.offset.y);
  },

  end(ctx) {
    console.log(`${prefix}: Ended at`, ctx.offset.x, ctx.offset.y);
  },
}));

// Use it with custom prefix
const plugins = [logger('MY_APP')];
```

---

## Plugin Internals

Now let's look under the hood at how plugins really work.

## Lifecycle Hooks

Every plugin can implement these hooks. They run at different stages of dragging:

```typescript
interface Plugin {
  name: string; // Unique identifier
  priority?: number; // Higher = runs earlier (default: 0)
  liveUpdate?: boolean; // Can update during active drag
  cancelable?: boolean; // Respects cancellation (default: true)

  // Lifecycle hooks
  setup?: (ctx) => state; // Plugin initialization
  shouldStart?: (ctx, state, event) => boolean; // Should dragging begin?
  start?: (ctx, state, event) => void; // Dragging started
  drag?: (ctx, state, event) => void; // During dragging
  end?: (ctx, state, event) => void; // Dragging ended
  cleanup?: (ctx, state) => void; // Plugin destroyed
}
```

Here's the complete flow:

1. **`setup`** - Plugin initializes, returns state object
2. **`shouldStart`** - User pressed down, should we start dragging?
3. **`start`** - Dragging actually begins
4. **`drag`** - Called repeatedly while dragging
5. **`end`** - User released, dragging stops
6. **`cleanup`** - Plugin is being removed/destroyed

## Context Object

The `ctx` parameter gives you access to everything about the current drag:

```typescript
interface PluginContext {
  // Position data
  initial: { x: number; y: number }; // Where drag started
  offset: { x: number; y: number }; // Current position
  delta: { x: number; y: number }; // Change since drag started
  proposed: { x: number | null; y: number | null }; // Proposed change this cycle

  // State
  isDragging: boolean; // Currently dragging?
  isInteracting: boolean; // User pressed down?

  // DOM elements
  rootNode: HTMLElement | SVGElement; // Element with draggable applied
  currentlyDraggedNode: HTMLElement | SVGElement; // What's actually being dragged
  cachedRootNodeRect: DOMRect; // Cached bounding box
  lastEvent: PointerEvent | null; // Last pointer event

  // Control methods
  propose: (x: number | null, y: number | null) => void; // Suggest new movement
  cancel: () => void; // Cancel this drag cycle
  preventStart: () => void; // Don't start dragging
  setForcedPosition: (x: number, y: number) => void; // Jump to position

  // Effect scheduling
  effect: {
    immediate: (fn) => void; // Run in next microtask
    paint: (fn) => void; // Run in next animation frame
  };
}
```

### Position Values Explained

- **`initial`** - Mouse position when dragging started (never changes)
- **`offset`** - How far the element has moved from its original position
- **`delta`** - Same as offset, but resets each drag cycle
- **`proposed`** - What movement the current plugin cycle wants to apply

Here's a practical example:

```typescript
const positionLogger = {
  name: 'position:logger',

  drag(ctx) {
    console.log({
      // Where the mouse was when drag started
      initial: ctx.initial,

      // Total movement since drag started
      offset: ctx.offset,

      // Movement just this cycle
      delta: ctx.delta,

      // What movement is being proposed this cycle
      proposed: ctx.proposed,
    });
  },
};
```

## Modifying Movement

Plugins can change how the element moves by calling `ctx.propose()`:

```typescript
// A plugin that halves all movement
const slowMotion = {
  name: 'my:slowmotion',

  drag(ctx) {
    // Take the proposed movement and cut it in half
    const halfX =
      ctx.proposed.x !== null ? ctx.proposed.x * 0.5 : null;
    const halfY =
      ctx.proposed.y !== null ? ctx.proposed.y * 0.5 : null;

    ctx.propose(halfX, halfY);
  },
};

// A plugin that only allows upward movement
const onlyUp = {
  name: 'my:onlyup',

  drag(ctx) {
    // Keep X movement, but only allow negative Y (upward)
    const limitedY =
      ctx.proposed.y !== null ? Math.min(0, ctx.proposed.y) : null;

    ctx.propose(ctx.proposed.x, limitedY);
  },
};
```

The key thing: plugins run in order, so later plugins see the changes made by earlier plugins.

## Priority & Order

Plugins run in priority order (higher numbers first):

```typescript
const firstPlugin = {
  name: 'first',
  priority: 100, // Runs first
  drag(ctx) {
    console.log('I run first!');
    ctx.propose(ctx.proposed.x, 0); // Lock Y movement
  },
};

const secondPlugin = {
  name: 'second',
  priority: 50, // Runs second
  drag(ctx) {
    console.log('I run second, Y is already locked');
    // ctx.proposed.y is now 0 from the first plugin
  },
};

const defaultPlugin = {
  name: 'default',
  // priority: 0 (default)
  drag(ctx) {
    console.log('I run last');
  },
};
```

Core plugins typically use negative priorities so your plugins run first:

```typescript
// Your plugin runs before the built-in transform plugin
const yourPlugin = {
  name: 'your:plugin',
  priority: 10, // Positive priority
  // ...
};

// Built-in transform plugin
const transform = {
  name: 'neodrag:transform',
  priority: -1000, // Very low priority, runs last
  // ...
};
```

## Cancellation

Plugins can control whether other plugins run using several methods:

### 1. Return `false` to stop the hook chain

```typescript
const gatekeeper = {
  name: 'gatekeeper',
  priority: 100,

  shouldStart(ctx, state, event) {
    if (!userCanDrag()) {
      return false; // No other shouldStart hooks will run
    }
    return true;
  },
};
```

### 2. Use `ctx.cancel()` to skip cancelable plugins

```typescript
const conditionalCancel = {
  name: 'conditional',

  drag(ctx) {
    if (ctx.offset.x > 100) {
      ctx.cancel(); // Skip remaining cancelable plugins this cycle
    }
  },
};

const alwaysRuns = {
  name: 'always',
  cancelable: false, // Will run even after ctx.cancel()

  drag(ctx) {
    console.log('I always run!');
  },
};
```

### 3. Use `ctx.preventStart()` during threshold phase

```typescript
const smartThreshold = {
  name: 'smart:threshold',

  drag(ctx) {
    // If not dragging yet, we're in threshold phase
    if (!ctx.isDragging) {
      if (shouldPreventDragging()) {
        ctx.preventStart(); // Don't start dragging
      }
    }
  },
};
```

## Effect Scheduling

Use `ctx.effect` to schedule DOM updates efficiently:

```typescript
const visualFeedback = {
  name: 'visual:feedback',

  setup(ctx) {
    return {
      indicator: document.createElement('div'),
    };
  },

  start(ctx, state) {
    // Use paint for visual changes
    ctx.effect.paint(() => {
      state.indicator.style.display = 'block';
      document.body.appendChild(state.indicator);
    });
  },

  drag(ctx, state) {
    // Use immediate for fast updates
    ctx.effect.immediate(() => {
      state.indicator.textContent = `${ctx.offset.x}, ${ctx.offset.y}`;
    });

    // Use paint for visual positioning
    ctx.effect.paint(() => {
      state.indicator.style.left = ctx.offset.x + 'px';
      state.indicator.style.top = ctx.offset.y + 'px';
    });
  },

  end(ctx, state) {
    ctx.effect.paint(() => {
      state.indicator.remove();
    });
  },
};
```

- **`immediate`** - Runs in next microtask (fast, for data updates)
- **`paint`** - Runs in next animation frame (smooth, for visual changes)

## Advanced Example

Here's a more complex plugin that creates a ghost element during dragging:

```typescript
import { unstable_definePlugin } from '@neodrag/core/plugins';

const ghostElement = unstable_definePlugin((options = {}) => ({
  name: 'my:ghost',

  setup(ctx) {
    return {
      ghost: null,
      originalOpacity: ctx.rootNode.style.opacity,
      options: { opacity: 0.5, ...options },
    };
  },

  start(ctx, state) {
    ctx.effect.paint(() => {
      // Create ghost element
      state.ghost = ctx.rootNode.cloneNode(true);
      state.ghost.style.position = 'absolute';
      state.ghost.style.opacity = state.options.opacity;
      state.ghost.style.pointerEvents = 'none';
      state.ghost.style.zIndex = '9999';

      // Position it at current location
      const rect = ctx.cachedRootNodeRect;
      state.ghost.style.left = rect.left + 'px';
      state.ghost.style.top = rect.top + 'px';

      // Add to document
      document.body.appendChild(state.ghost);

      // Make original element semi-transparent
      ctx.rootNode.style.opacity = '0.3';
    });
  },

  drag(ctx, state) {
    if (state.ghost) {
      ctx.effect.paint(() => {
        // Update ghost position
        const rect = ctx.cachedRootNodeRect;
        state.ghost.style.left = rect.left + ctx.offset.x + 'px';
        state.ghost.style.top = rect.top + ctx.offset.y + 'px';
      });
    }
  },

  end(ctx, state) {
    ctx.effect.paint(() => {
      // Remove ghost
      if (state.ghost) {
        state.ghost.remove();
        state.ghost = null;
      }

      // Restore original opacity
      ctx.rootNode.style.opacity = state.originalOpacity;
    });
  },

  cleanup(ctx, state) {
    // Clean up if plugin is removed mid-drag
    if (state.ghost) {
      state.ghost.remove();
    }
    ctx.rootNode.style.opacity = state.originalOpacity;
  },
}));

// Usage
const plugins = [ghostElement({ opacity: 0.7 })];
```

## Performance

For high-performance apps, use Compartments to update plugins efficiently:

<FrameworkSwitch>
<div slot="svelte">

```svelte
<script>
  import { position, axis, Compartment } from '@neodrag/svelte';

  // Create reactive state
  let x = $state(0);
  let y = $state(0);
  let currentAxis = $state('both');

  // Create compartments that react to state changes
  const positionComp = Compartment.of(() =>
    position({ current: { x, y } }),
  );

  const axisComp = Compartment.of(() =>
    currentAxis !== 'both' ? axis(currentAxis) : undefined,
  );

  function moveX() {
    x += 10;
  }

  function toggleAxis() {
    currentAxis = currentAxis === 'x' ? 'y' : 'x';
  }
</script>

<div {@attach draggable(() => [positionComp, axisComp])}>
  High-performance draggable!
</div>

<button onclick={moveX}>Move X +10</button>
<button onclick={toggleAxis}>Toggle Axis</button>
```

</div>

<div slot="react">

```tsx
import { useState, useRef } from 'react';
import {
  position,
  axis,
  useDraggable,
  useCompartment,
} from '@neodrag/react';

function HighPerformanceComponent() {
  const dragRef = useRef<HTMLDivElement>(null);
  const [x, setX] = useState(0);
  const [y, setY] = useState(0);
  const [currentAxis, setCurrentAxis] = useState('both');

  // Create compartments that react to state changes
  const positionComp = useCompartment(
    () => position({ current: { x, y } }),
    [x, y],
  );

  const axisComp = useCompartment(
    () => (currentAxis !== 'both' ? axis(currentAxis) : undefined),
    [currentAxis],
  );

  const dragState = useDraggable(dragRef, () => [
    positionComp,
    axisComp,
  ]);

  return (
    <div>
      <div ref={dragRef}>High-performance draggable!</div>
      <button onClick={() => setX(x + 10)}>Move X +10</button>
      <button
        onClick={() =>
          setCurrentAxis(currentAxis === 'x' ? 'y' : 'x')
        }
      >
        Toggle Axis
      </button>
    </div>
  );
}
```

</div>

<div slot="vue">

```vue
<script setup>
import { ref } from 'vue';
import {
  position,
  axis,
  vDraggable,
  useCompartment,
} from '@neodrag/vue';

const x = ref(0);
const y = ref(0);
const currentAxis = ref('both');

// Create compartments that react to state changes
const positionComp = useCompartment(() =>
  position({ current: { x: x.value, y: y.value } }),
);

const axisComp = useCompartment(() =>
  currentAxis.value !== 'both' ? axis(currentAxis.value) : undefined,
);

const plugins = () => [positionComp, axisComp];

function moveX() {
  x.value += 10;
}

function toggleAxis() {
  currentAxis.value = currentAxis.value === 'x' ? 'y' : 'x';
}
</script>

<template>
  <div>
    <div v-draggable="plugins">High-performance draggable!</div>
    <button @click="moveX">Move X +10</button>
    <button @click="toggleAxis">Toggle Axis</button>
  </div>
</template>
```

</div>

<div slot="solid">

```tsx
import { createSignal } from 'solid-js';
import {
  position,
  axis,
  useDraggable,
  createCompartment,
} from '@neodrag/solid';

function HighPerformanceComponent() {
  const [element, setElement] = createSignal<HTMLDivElement>();
  const [x, setX] = createSignal(0);
  const [y, setY] = createSignal(0);
  const [currentAxis, setCurrentAxis] = createSignal('both');

  // Create compartments that react to signals
  const positionComp = createCompartment(() =>
    position({ current: { x: x(), y: y() } }),
  );

  const axisComp = createCompartment(() =>
    currentAxis() !== 'both' ? axis(currentAxis()) : undefined,
  );

  const dragState = useDraggable(element, [positionComp, axisComp]);

  return (
    <div>
      <div ref={setElement}>High-performance draggable!</div>
      <button onClick={() => setX(x() + 10)}>Move X +10</button>
      <button
        onClick={() =>
          setCurrentAxis(currentAxis() === 'x' ? 'y' : 'x')
        }
      >
        Toggle Axis
      </button>
    </div>
  );
}
```

</div>

<div slot="vanilla">

```typescript
import {
  Compartment,
  position,
  axis,
  Draggable,
} from '@neodrag/vanilla';

let x = 0,
  y = 0,
  currentAxis = 'both';

// Create compartments
const positionComp = new Compartment(() =>
  position({ current: { x, y } }),
);

const axisComp = new Compartment(() =>
  currentAxis !== 'both' ? axis(currentAxis) : undefined,
);

const element = document.getElementById('my-draggable');
const instance = new Draggable(element, () => [
  positionComp,
  axisComp,
]);

// Update when values change
function updatePosition(newX, newY) {
  x = newX;
  y = newY;
  positionComp.current = position({ current: { x, y } });
}

function updateAxis(newAxis) {
  currentAxis = newAxis;
  axisComp.current =
    currentAxis !== 'both' ? axis(currentAxis) : undefined;
}
```

</div>
</FrameworkSwitch>

With Compartments:

- Only changed plugins get updated
- Updates can happen during active drags
- Much better performance in reactive apps
- No unnecessary plugin recreation

## Composition

One of the most powerful features of Neodrag v3 is how easily you can combine plugins. Each plugin focuses on one thing, making complex behaviors simple to build.

### Combining Multiple Behaviors

```typescript
// A draggable that snaps to grid, stays in bounds, and logs events
const plugins = [
  grid([20, 20]),
  bounds(BoundsFrom.viewport({ padding: { top: 50 } })),
  events({
    onDragStart: (data) => console.log('Started at:', data.offset),
    onDrag: (data) => console.log('Moving to:', data.offset),
    onDragEnd: (data) => console.log('Ended at:', data.offset),
  }),
];
```

### Plugin Order Matters

Plugins run in priority order, so their sequence affects the final behavior:

```typescript
// Order 1: Grid first, then bounds
const plugins1 = [
  grid([50, 50]), // Snaps to 50px grid
  bounds(BoundsFrom.viewport()), // Then applies bounds
];

// Order 2: Bounds first, then grid
const plugins2 = [
  bounds(BoundsFrom.viewport()), // Applies bounds first
  grid([50, 50]), // Then snaps to grid (might go out of bounds!)
];

// Better: Use priority to be explicit
const plugins3 = [
  { ...bounds(BoundsFrom.viewport()), priority: -1 }, // Lower priority = later
  grid([50, 50]), // Higher priority = earlier
];
```

The first example works better because grid snapping happens first, then bounds checking ensures the element stays in view.

## Third-Party Plugins

Want to share your plugin? Here's how to create a publishable one:

```typescript
// my-awesome-plugin.ts
import { unstable_definePlugin } from '@neodrag/core/plugins';

export const awesomePlugin = unstable_definePlugin(
  (options = {}) => ({
    name: 'awesome:plugin',

    setup(ctx) {
      // Plugin setup logic
      return {
        /* state */
      };
    },

    // ... other hooks
  }),
);

// Export types for TypeScript users
export interface AwesomePluginOptions {
  speed?: number;
  color?: string;
}
```

Publish it as `neodrag-plugin-awesome` and users can install it:

```bash
npm install neodrag-plugin-awesome
```

Then use it like any built-in plugin:

```typescript
import { awesomePlugin } from 'neodrag-plugin-awesome';

const plugins = [awesomePlugin({ speed: 2, color: 'blue' })];
```

## Debugging

Add console logs to understand plugin execution:

```typescript
const debugPlugin = {
  name: 'debug:execution',
  priority: 999, // Run early to see what happens

  setup(ctx) {
    console.log('🔧 Plugin setup');
    return {};
  },

  shouldStart(ctx, state, event) {
    console.log('🤔 Should start?', event.type);
    return true;
  },

  start(ctx, state, event) {
    console.log('🚀 Drag started');
  },

  drag(ctx, state, event) {
    console.log('🏃 Dragging:', ctx.offset);
  },

  end(ctx, state, event) {
    console.log('🛑 Drag ended');
  },
};
```

You can also inspect the global instances:

```typescript
// Check all active draggable instances
console.log('Active draggables:', instances.size);

// Inspect a specific instance
for (const [element, instance] of instances) {
  console.log('Element:', element);
  console.log(
    'Plugins:',
    instance.plugins.map((p) => p.name),
  );
  console.log('Current state:', instance.ctx);
}
```

That's the complete guide to Neodrag plugins! Start with the built-in plugins, then create your own when you need custom behavior. The plugin system is designed to be simple to use but powerful enough for complex drag interactions.
