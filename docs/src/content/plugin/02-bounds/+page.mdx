---
title: 'bounds'
tagline: 'Keep draggable elements within specified boundaries'
---

import FrameworkSwitch from '$components/FrameworkSwitch.astro';

## What it does

The `bounds` plugin keeps draggable elements within specified boundaries. Whether it's staying inside a parent container, the viewport, or custom regions - bounds ensures your elements can't escape their designated areas.

```typescript
bounds(BoundsFrom.viewport()); // Stay in browser window
bounds(BoundsFrom.parent()); // Stay in parent element
bounds(BoundsFrom.element(el)); // Stay in specific element
```

## Basic Usage

<FrameworkSwitch>
<div slot="svelte">

```svelte
<script>
  import { bounds, BoundsFrom } from '@neodrag/svelte';
</script>

<!-- Stay within viewport -->
<div {@attach draggable([bounds(BoundsFrom.viewport())])}>
  Can't leave the screen
</div>

<!-- Stay within parent -->
<div class="container">
  <div {@attach draggable([bounds(BoundsFrom.parent())])}>
    Contained child
  </div>
</div>
```

</div>

<div slot="react">

```tsx
import { useRef } from 'react';
import { bounds, BoundsFrom, useDraggable } from '@neodrag/react';

function BoundedElements() {
  const containerRef = useRef<HTMLDivElement>(null);
  const viewportRef = useRef<HTMLDivElement>(null);
  const parentRef = useRef<HTMLDivElement>(null);

  useDraggable(viewportRef, [bounds(BoundsFrom.viewport())]);
  useDraggable(parentRef, [bounds(BoundsFrom.parent())]);

  return (
    <div>
      <div ref={viewportRef}>Can't leave the screen</div>

      <div className="container">
        <div ref={parentRef}>Contained child</div>
      </div>
    </div>
  );
}
```

</div>

<div slot="vue">

```vue
<script setup>
import { bounds, BoundsFrom, vDraggable } from '@neodrag/vue';
</script>

<template>
  <div>
    <div v-draggable="[bounds(BoundsFrom.viewport())]">
      Can't leave the screen
    </div>

    <div class="container">
      <div v-draggable="[bounds(BoundsFrom.parent())]">
        Contained child
      </div>
    </div>
  </div>
</template>
```

</div>

<div slot="solid">

```tsx
import { createSignal } from 'solid-js';
import { bounds, BoundsFrom, useDraggable } from '@neodrag/solid';

function BoundedElements() {
  const [viewport, setViewport] = createSignal<HTMLDivElement>();
  const [parent, setParent] = createSignal<HTMLDivElement>();

  useDraggable(viewport, [bounds(BoundsFrom.viewport())]);
  useDraggable(parent, [bounds(BoundsFrom.parent())]);

  return (
    <div>
      <div ref={setViewport}>Can't leave the screen</div>

      <div class="container">
        <div ref={setParent}>Contained child</div>
      </div>
    </div>
  );
}
```

</div>

<div slot="vanilla">

```typescript
import { bounds, BoundsFrom, Draggable } from '@neodrag/vanilla';

const viewport = document.getElementById('viewport');
const parent = document.getElementById('parent');

new Draggable(viewport, [bounds(BoundsFrom.viewport())]);
new Draggable(parent, [bounds(BoundsFrom.parent())]);
```

</div>
</FrameworkSwitch>

## BoundsFrom Utility

The `BoundsFrom` utility provides ready-made boundary functions:

### Common Boundaries

```typescript
// Stay within browser viewport
BoundsFrom.viewport();

// Stay within parent element
BoundsFrom.parent();

// Stay within specific element
BoundsFrom.element(containerElement);

// Stay within element found by selector
BoundsFrom.selector('#container');
```

### With Padding

Add padding to create margins around boundaries:

```typescript
// Viewport with 50px margin on all sides
BoundsFrom.viewport({
  top: 50,
  right: 50,
  bottom: 50,
  left: 50,
});

// Parent with 20px top/bottom margin
BoundsFrom.parent({
  top: 20,
  bottom: 20,
});
```

## Dynamic Boundaries

Update boundaries using compartments:

<FrameworkSwitch>
<div slot="svelte">

```svelte
<script>
  import {
    bounds,
    BoundsFrom,
    createCompartment,
  } from '@neodrag/svelte';

  let boundaryType = $state('viewport');
  let containerRef = $state();

  const boundsComp = createCompartment(() => {
    switch (boundaryType) {
      case 'viewport':
        return bounds(BoundsFrom.viewport());
      case 'parent':
        return bounds(BoundsFrom.parent());
      case 'container':
        return bounds(BoundsFrom.element(containerRef));
      default:
        return bounds(BoundsFrom.viewport());
    }
  });
</script>

<div bind:this={containerRef} class="container">
  <div {@attach draggable(() => [boundsComp])}>
    Current boundary: {boundaryType}
  </div>
</div>

<select bind:value={boundaryType}>
  <option value="viewport">Viewport</option>
  <option value="parent">Parent</option>
  <option value="container">Container</option>
</select>
```

</div>

<div slot="react">

```tsx
import { useRef, useState } from 'react';
import {
  bounds,
  BoundsFrom,
  useDraggable,
  useCompartment,
} from '@neodrag/react';

function DynamicBounds() {
  const elementRef = useRef<HTMLDivElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const [boundaryType, setBoundaryType] = useState('viewport');

  const boundsComp = useCompartment(() => {
    switch (boundaryType) {
      case 'viewport':
        return bounds(BoundsFrom.viewport());
      case 'parent':
        return bounds(BoundsFrom.parent());
      case 'container':
        return bounds(BoundsFrom.element(containerRef.current));
      default:
        return bounds(BoundsFrom.viewport());
    }
  }, [boundaryType]);

  useDraggable(elementRef, () => [boundsComp]);

  return (
    <div>
      <div ref={containerRef} className="container">
        <div ref={elementRef}>Current boundary: {boundaryType}</div>
      </div>

      <select
        value={boundaryType}
        onChange={(e) => setBoundaryType(e.target.value)}
      >
        <option value="viewport">Viewport</option>
        <option value="parent">Parent</option>
        <option value="container">Container</option>
      </select>
    </div>
  );
}
```

</div>

<div slot="vue">

```vue
<script setup>
import { ref } from 'vue';
import {
  bounds,
  BoundsFrom,
  vDraggable,
  useCompartment,
} from '@neodrag/vue';

const boundaryType = ref('viewport');
const containerRef = ref();

const boundsComp = useCompartment(() => {
  switch (boundaryType.value) {
    case 'viewport':
      return bounds(BoundsFrom.viewport());
    case 'parent':
      return bounds(BoundsFrom.parent());
    case 'container':
      return bounds(BoundsFrom.element(containerRef.value));
    default:
      return bounds(BoundsFrom.viewport());
  }
});

const plugins = () => [boundsComp];
</script>

<template>
  <div>
    <div ref="containerRef" class="container">
      <div v-draggable="plugins">
        Current boundary: {{ boundaryType }}
      </div>
    </div>

    <select v-model="boundaryType">
      <option value="viewport">Viewport</option>
      <option value="parent">Parent</option>
      <option value="container">Container</option>
    </select>
  </div>
</template>
```

</div>

<div slot="solid">

```tsx
import { createSignal } from 'solid-js';
import {
  bounds,
  BoundsFrom,
  useDraggable,
  createCompartment,
} from '@neodrag/solid';

function DynamicBounds() {
  const [element, setElement] = createSignal<HTMLDivElement>();
  const [container, setContainer] = createSignal<HTMLDivElement>();
  const [boundaryType, setBoundaryType] = createSignal('viewport');

  const boundsComp = createCompartment(() => {
    switch (boundaryType()) {
      case 'viewport':
        return bounds(BoundsFrom.viewport());
      case 'parent':
        return bounds(BoundsFrom.parent());
      case 'container':
        return bounds(BoundsFrom.element(container()));
      default:
        return bounds(BoundsFrom.viewport());
    }
  });

  useDraggable(element, [boundsComp]);

  return (
    <div>
      <div ref={setContainer} class="container">
        <div ref={setElement}>Current boundary: {boundaryType()}</div>
      </div>

      <select
        value={boundaryType()}
        onChange={(e) => setBoundaryType(e.target.value)}
      >
        <option value="viewport">Viewport</option>
        <option value="parent">Parent</option>
        <option value="container">Container</option>
      </select>
    </div>
  );
}
```

</div>

<div slot="vanilla">

```typescript
import {
  bounds,
  BoundsFrom,
  Compartment,
  Draggable,
} from '@neodrag/vanilla';

const element = document.getElementById('element');
const container = document.getElementById('container');
const select = document.getElementById('boundary-select');

let boundaryType = 'viewport';

const boundsComp = new Compartment(() => {
  switch (boundaryType) {
    case 'viewport':
      return bounds(BoundsFrom.viewport());
    case 'parent':
      return bounds(BoundsFrom.parent());
    case 'container':
      return bounds(BoundsFrom.element(container));
    default:
      return bounds(BoundsFrom.viewport());
  }
});

new Draggable(element, () => [boundsComp]);

select.addEventListener('change', (e) => {
  boundaryType = e.target.value;
  boundsComp.current = boundsComp.current; // Trigger update
});
```

</div>
</FrameworkSwitch>

## Combining with Other Plugins

### With Axis Constraint

```typescript
// Horizontal slider that stays within parent
const plugins = [axis('x'), bounds(BoundsFrom.parent())];
```

### With Grid Snapping

```typescript
// Grid snapping within viewport boundaries
const plugins = [
  grid([20, 20]),
  bounds(BoundsFrom.viewport({ top: 50 })),
];
```

### Plugin Order

Bounds typically runs after other movement plugins:

```typescript
const plugins = [
  grid([10, 10]), // Apply grid first
  bounds(BoundsFrom.parent()), // Then constrain to bounds
];
```

## Common Use Cases

### Draggable Modal

<FrameworkSwitch>
<div slot="svelte">

```svelte
<script>
  import {
    bounds,
    BoundsFrom,
    controls,
    ControlFrom,
  } from '@neodrag/svelte';
</script>

<div
  class="modal"
  {@attach draggable([
    bounds(BoundsFrom.viewport({ top: 0 })),
    controls({ allow: ControlFrom.selector('.modal-header') }),
  ])}
>
  <div class="modal-header">Drag me to move modal</div>
  <div class="modal-content">Modal content here...</div>
</div>

<style>
  .modal {
    position: fixed;
    top: 50px;
    left: 100px;
    width: 400px;
    background: white;
    border: 1px solid #ccc;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  }

  .modal-header {
    padding: 16px;
    background: #f5f5f5;
    cursor: move;
    border-bottom: 1px solid #ddd;
  }

  .modal-content {
    padding: 16px;
  }
</style>
```

</div>

<div slot="react">

```tsx
import { useRef } from 'react';
import {
  bounds,
  BoundsFrom,
  controls,
  ControlFrom,
  useDraggable,
} from '@neodrag/react';

function DraggableModal() {
  const modalRef = useRef<HTMLDivElement>(null);

  useDraggable(modalRef, [
    bounds(BoundsFrom.viewport({ top: 0 })),
    controls({ allow: ControlFrom.selector('.modal-header') }),
  ]);

  return (
    <div ref={modalRef} className="modal">
      <div className="modal-header">Drag me to move modal</div>
      <div className="modal-content">Modal content here...</div>
    </div>
  );
}
```

</div>

<div slot="vue">

```vue
<script setup>
import {
  bounds,
  BoundsFrom,
  controls,
  ControlFrom,
  vDraggable,
} from '@neodrag/vue';

const plugins = [
  bounds(BoundsFrom.viewport({ top: 0 })),
  controls({ allow: ControlFrom.selector('.modal-header') }),
];
</script>

<template>
  <div v-draggable="plugins" class="modal">
    <div class="modal-header">Drag me to move modal</div>
    <div class="modal-content">Modal content here...</div>
  </div>
</template>
```

</div>

<div slot="solid">

```tsx
import { createSignal } from 'solid-js';
import {
  bounds,
  BoundsFrom,
  controls,
  ControlFrom,
  useDraggable,
} from '@neodrag/solid';

function DraggableModal() {
  const [modal, setModal] = createSignal<HTMLDivElement>();

  useDraggable(modal, [
    bounds(BoundsFrom.viewport({ top: 0 })),
    controls({ allow: ControlFrom.selector('.modal-header') }),
  ]);

  return (
    <div ref={setModal} class="modal">
      <div class="modal-header">Drag me to move modal</div>
      <div class="modal-content">Modal content here...</div>
    </div>
  );
}
```

</div>

<div slot="vanilla">

```typescript
import {
  bounds,
  BoundsFrom,
  controls,
  ControlFrom,
  Draggable,
} from '@neodrag/vanilla';

const modal = document.getElementById('modal');

new Draggable(modal, [
  bounds(BoundsFrom.viewport({ top: 0 })),
  controls({ allow: ControlFrom.selector('.modal-header') }),
]);
```

</div>
</FrameworkSwitch>

### Drag and Drop with Zones

```typescript
// Card that can be dropped in specific zones
const plugins = [
  bounds(() => {
    const zone1 = document
      .getElementById('drop-zone-1')
      .getBoundingClientRect();
    const zone2 = document
      .getElementById('drop-zone-2')
      .getBoundingClientRect();

    // Allow movement between zones
    return [
      [
        Math.min(zone1.left, zone2.left),
        Math.min(zone1.top, zone2.top),
      ],
      [
        Math.max(zone1.right, zone2.right),
        Math.max(zone1.bottom, zone2.bottom),
      ],
    ];
  }),
];
```

## Custom Boundaries

For complex boundary logic, pass a function that returns coordinates:

```typescript
bounds(() => {
  // Custom diamond-shaped boundary
  const centerX = window.innerWidth / 2;
  const centerY = window.innerHeight / 2;
  const size = 200;

  return [
    [centerX - size, centerY - size],
    [centerX + size, centerY + size],
  ];
});
```

## How It Works

The bounds plugin calculates the allowed movement area and clamps the proposed position:

1. **Boundary calculation** - Runs the boundary function to get `[[x1, y1], [x2, y2]]`
2. **Element positioning** - Considers the element's size and current position
3. **Movement clamping** - Limits `proposed.x` and `proposed.y` to stay within bounds

The boundary function is called:

- On drag start (always)
- During drag (if `shouldRecompute` returns true)
- On drag end (if `shouldRecompute` returns true)

## API Reference

```typescript
function bounds(
  boundsFn: () => [[number, number], [number, number]],
  shouldRecompute?: (ctx: {
    hook: 'dragStart' | 'drag' | 'dragEnd';
  }) => boolean,
): Plugin;
```

**Parameters:**

- `boundsFn` - Function returning `[[x1, y1], [x2, y2]]` coordinates
- `shouldRecompute` - When to recalculate boundaries (default: drag start only)

**BoundsFrom utilities:**

- `BoundsFrom.viewport(padding?)` - Browser viewport
- `BoundsFrom.parent(padding?)` - Parent element
- `BoundsFrom.element(el, padding?)` - Specific element
- `BoundsFrom.selector(selector, padding?, root?)` - Element by selector

**Returns:** A plugin object for use with draggable.
