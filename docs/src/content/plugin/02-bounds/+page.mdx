---
title: 'bounds'
tagline: 'Keep draggable elements within specified boundaries'
---

import FrameworkSwitch from '$components/FrameworkSwitch.astro';

The `bounds` plugin keeps draggable elements within specified boundaries. Whether it's staying inside a parent container, the viewport, or custom regions - bounds ensures your elements can't escape their designated areas.

```typescript
bounds(BoundsFrom.viewport()); // Stay in browser window
bounds(BoundsFrom.parent()); // Stay in parent element
bounds(BoundsFrom.element(el)); // Stay in specific element
```

## Basic Usage

<FrameworkSwitch>
<div slot="svelte">

```svelte
<script>
  import { bounds, BoundsFrom } from '@neodrag/svelte';
</script>

<!-- Stay within viewport -->
<div {@attach draggable([bounds(BoundsFrom.viewport())])}>
  Can't leave the screen
</div>

<!-- Stay within parent -->
<div class="container">
  <div {@attach draggable([bounds(BoundsFrom.parent())])}>
    Contained child
  </div>
</div>
```

</div>

<div slot="react">

```tsx
import { useRef } from 'react';
import { bounds, BoundsFrom, useDraggable } from '@neodrag/react';

function BoundedElements() {
  const viewportRef = useRef<HTMLDivElement>(null);
  const parentRef = useRef<HTMLDivElement>(null);

  useDraggable(viewportRef, [bounds(BoundsFrom.viewport())]);
  useDraggable(parentRef, [bounds(BoundsFrom.parent())]);

  return (
    <div>
      <div ref={viewportRef}>Can't leave the screen</div>
      <div className="container">
        <div ref={parentRef}>Contained child</div>
      </div>
    </div>
  );
}
```

</div>

<div slot="vue">

```vue
<script setup>
import { bounds, BoundsFrom, vDraggable } from '@neodrag/vue';
</script>

<template>
  <div>
    <div v-draggable="[bounds(BoundsFrom.viewport())]">
      Can't leave the screen
    </div>
    <div class="container">
      <div v-draggable="[bounds(BoundsFrom.parent())]">
        Contained child
      </div>
    </div>
  </div>
</template>
```

</div>

<div slot="solid">

```tsx
import { createSignal } from 'solid-js';
import { bounds, BoundsFrom, useDraggable } from '@neodrag/solid';

function BoundedElements() {
  const [viewport, setViewport] = createSignal<HTMLDivElement>();
  const [parent, setParent] = createSignal<HTMLDivElement>();

  useDraggable(viewport, [bounds(BoundsFrom.viewport())]);
  useDraggable(parent, [bounds(BoundsFrom.parent())]);

  return (
    <div>
      <div ref={setViewport}>Can't leave the screen</div>
      <div class="container">
        <div ref={setParent}>Contained child</div>
      </div>
    </div>
  );
}
```

</div>

<div slot="vanilla">

```typescript
import { bounds, BoundsFrom, Draggable } from '@neodrag/vanilla';

const viewport = document.getElementById('viewport');
const parent = document.getElementById('parent');

new Draggable(viewport, [bounds(BoundsFrom.viewport())]);
new Draggable(parent, [bounds(BoundsFrom.parent())]);
```

</div>
</FrameworkSwitch>

## BoundsFrom Utilities

```typescript
// Viewport with padding
bounds(BoundsFrom.viewport({ top: 60, left: 20 }));

// Parent with padding
bounds(BoundsFrom.parent({ bottom: 10 }));

// Specific element
bounds(BoundsFrom.element(targetElement));

// Element by selector
bounds(BoundsFrom.selector('#container'));

// All padding options
bounds(
  BoundsFrom.viewport({
    top: 10,
    right: 20,
    bottom: 30,
    left: 40,
  }),
);
```

## Dynamic Boundaries

For boundaries that change during dragging, use a function:

<FrameworkSwitch>
<div slot="svelte">

```svelte
<script>
  import { bounds } from '@neodrag/svelte';

  let windowWidth = $state(window.innerWidth);
  let windowHeight = $state(window.innerHeight);

  // Update on resize
  $effect(() => {
    function handleResize() {
      windowWidth = window.innerWidth;
      windowHeight = window.innerHeight;
    }
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  });

  const dynamicBounds = () => [
    [0, 0],
    [windowWidth - 100, windowHeight - 100],
  ];
</script>

<div {@attach draggable([bounds(dynamicBounds)])}>
  Responsive boundaries
</div>
```

</div>

<div slot="react">

```tsx
import { useState, useEffect, useRef } from 'react';
import { bounds, useDraggable } from '@neodrag/react';

function ResponsiveBounds() {
  const ref = useRef<HTMLDivElement>(null);
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });

  useEffect(() => {
    function handleResize() {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    }
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  const dynamicBounds = () => [
    [0, 0],
    [windowSize.width - 100, windowSize.height - 100],
  ];

  useDraggable(ref, [bounds(dynamicBounds)]);

  return <div ref={ref}>Responsive boundaries</div>;
}
```

</div>

<div slot="vue">

```vue
<script setup>
import { ref, onMounted, onUnmounted } from 'vue';
import { bounds, vDraggable } from '@neodrag/vue';

const windowWidth = ref(window.innerWidth);
const windowHeight = ref(window.innerHeight);

function handleResize() {
  windowWidth.value = window.innerWidth;
  windowHeight.value = window.innerHeight;
}

onMounted(() => {
  window.addEventListener('resize', handleResize);
});

onUnmounted(() => {
  window.removeEventListener('resize', handleResize);
});

const dynamicBounds = () => [
  [0, 0],
  [windowWidth.value - 100, windowHeight.value - 100],
];

const plugins = [bounds(dynamicBounds)];
</script>

<template>
  <div v-draggable="plugins">Responsive boundaries</div>
</template>
```

</div>

<div slot="solid">

```tsx
import { createSignal, onMount, onCleanup } from 'solid-js';
import { bounds, useDraggable } from '@neodrag/solid';

function ResponsiveBounds() {
  const [element, setElement] = createSignal<HTMLDivElement>();
  const [windowSize, setWindowSize] = createSignal({
    width: window.innerWidth,
    height: window.innerHeight,
  });

  onMount(() => {
    function handleResize() {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    }
    window.addEventListener('resize', handleResize);
    onCleanup(() =>
      window.removeEventListener('resize', handleResize),
    );
  });

  const dynamicBounds = () => [
    [0, 0],
    [windowSize().width - 100, windowSize().height - 100],
  ];

  useDraggable(element, [bounds(dynamicBounds)]);

  return <div ref={setElement}>Responsive boundaries</div>;
}
```

</div>

<div slot="vanilla">

```typescript
import { bounds, Draggable } from '@neodrag/vanilla';

let windowWidth = window.innerWidth;
let windowHeight = window.innerHeight;

function handleResize() {
  windowWidth = window.innerWidth;
  windowHeight = window.innerHeight;
}

window.addEventListener('resize', handleResize);

const dynamicBounds = () => [
  [0, 0],
  [windowWidth - 100, windowHeight - 100],
];

const element = document.getElementById('responsive');
new Draggable(element, [bounds(dynamicBounds)]);
```

</div>
</FrameworkSwitch>

## Common Use Cases

### Draggable Modal

<FrameworkSwitch>
<div slot="svelte">

```svelte
<script>
  import {
    bounds,
    BoundsFrom,
    controls,
    ControlFrom,
  } from '@neodrag/svelte';
</script>

<div
  {@attach draggable([
    bounds(BoundsFrom.viewport({ top: 0 })),
    controls({ allow: ControlFrom.selector('.modal-header') }),
  ])}
  class="modal"
>
  <div class="modal-header">Drag me to move modal</div>
  <div class="modal-content">Modal content here...</div>
</div>
```

</div>

<div slot="react">

```tsx
import { useRef } from 'react';
import {
  bounds,
  BoundsFrom,
  controls,
  ControlFrom,
  useDraggable,
} from '@neodrag/react';

function DraggableModal() {
  const ref = useRef<HTMLDivElement>(null);

  useDraggable(ref, [
    bounds(BoundsFrom.viewport({ top: 0 })),
    controls({ allow: ControlFrom.selector('.modal-header') }),
  ]);

  return (
    <div ref={ref} className="modal">
      <div className="modal-header">Drag me to move modal</div>
      <div className="modal-content">Modal content here...</div>
    </div>
  );
}
```

</div>

<div slot="vue">

```vue
<script setup>
import {
  bounds,
  BoundsFrom,
  controls,
  ControlFrom,
  vDraggable,
} from '@neodrag/vue';

const plugins = [
  bounds(BoundsFrom.viewport({ top: 0 })),
  controls({ allow: ControlFrom.selector('.modal-header') }),
];
</script>

<template>
  <div v-draggable="plugins" class="modal">
    <div class="modal-header">Drag me to move modal</div>
    <div class="modal-content">Modal content here...</div>
  </div>
</template>
```

</div>

<div slot="solid">

```tsx
import { createSignal } from 'solid-js';
import {
  bounds,
  BoundsFrom,
  controls,
  ControlFrom,
  useDraggable,
} from '@neodrag/solid';

function DraggableModal() {
  const [modal, setModal] = createSignal<HTMLDivElement>();

  useDraggable(modal, [
    bounds(BoundsFrom.viewport({ top: 0 })),
    controls({ allow: ControlFrom.selector('.modal-header') }),
  ]);

  return (
    <div ref={setModal} class="modal">
      <div class="modal-header">Drag me to move modal</div>
      <div class="modal-content">Modal content here...</div>
    </div>
  );
}
```

</div>

<div slot="vanilla">

```typescript
import {
  bounds,
  BoundsFrom,
  controls,
  ControlFrom,
  Draggable,
} from '@neodrag/vanilla';

const modal = document.getElementById('modal');

new Draggable(modal, [
  bounds(BoundsFrom.viewport({ top: 0 })),
  controls({ allow: ControlFrom.selector('.modal-header') }),
]);
```

</div>
</FrameworkSwitch>

### Image Gallery Viewport

```typescript
// Image larger than container - allow scrolling via drag
const plugins = [
  bounds(() => {
    const container = document.getElementById('gallery-container');
    const image = document.getElementById('large-image');

    const containerRect = container.getBoundingClientRect();
    const imageRect = image.getBoundingClientRect();

    return [
      [
        containerRect.width - imageRect.width,
        containerRect.height - imageRect.height,
      ],
      [0, 0],
    ];
  }),
];
```

### Drag and Drop Zones

```typescript
// Card that can be dropped in specific zones
const plugins = [
  bounds(() => {
    const zone1 = document
      .getElementById('drop-zone-1')
      .getBoundingClientRect();
    const zone2 = document
      .getElementById('drop-zone-2')
      .getBoundingClientRect();

    // Allow movement between zones
    return [
      [
        Math.min(zone1.left, zone2.left),
        Math.min(zone1.top, zone2.top),
      ],
      [
        Math.max(zone1.right, zone2.right),
        Math.max(zone1.bottom, zone2.bottom),
      ],
    ];
  }),
];
```

## Custom Boundaries

For complex boundary logic, pass a function that returns coordinates:

```typescript
// Diamond-shaped boundary
bounds(() => {
  const centerX = window.innerWidth / 2;
  const centerY = window.innerHeight / 2;
  const size = 200;

  return [
    [centerX - size, centerY - size],
    [centerX + size, centerY + size],
  ];
});

// Time-based boundaries (smaller at night)
bounds(() => {
  const hour = new Date().getHours();
  const isNight = hour < 6 || hour > 22;
  const factor = isNight ? 0.5 : 1;

  return [
    [0, 0],
    [window.innerWidth * factor, window.innerHeight * factor],
  ];
});
```

## Recomputing Boundaries

By default, boundaries are calculated once at drag start. For dynamic boundaries, control when they're recalculated:

```typescript
bounds(boundaryFunction, (ctx) => {
  // Recompute on every drag event
  return ctx.hook === 'drag';
});

bounds(boundaryFunction, (ctx) => {
  // Only recompute at start and end
  return ctx.hook === 'dragStart' || ctx.hook === 'dragEnd';
});
```

## How It Works

The bounds plugin calculates the allowed movement area and clamps the proposed position:

1. **Boundary calculation** - Runs the boundary function to get `[[x1, y1], [x2, y2]]`
2. **Element positioning** - Considers the element's size and current position
3. **Movement clamping** - Limits `proposed.x` and `proposed.y` to stay within bounds

The boundary function is called:

- On drag start (always)
- During drag (if `shouldRecompute` returns true)
- On drag end (if `shouldRecompute` returns true)

## API Reference

```typescript
function bounds(
  boundsFn: () => [[number, number], [number, number]],
  shouldRecompute?: (ctx: {
    hook: 'dragStart' | 'drag' | 'dragEnd';
  }) => boolean,
): Plugin;
```

**Parameters:**

- `boundsFn` - Function returning `[[x1, y1], [x2, y2]]` coordinates
- `shouldRecompute` - When to recalculate boundaries (default: drag start only)

**BoundsFrom utilities:**

- `BoundsFrom.viewport(padding?)` - Browser viewport
- `BoundsFrom.parent(padding?)` - Parent element
- `BoundsFrom.element(el, padding?)` - Specific element
- `BoundsFrom.selector(selector, padding?, root?)` - Element by selector

**Returns:** A plugin object for use with draggable.
