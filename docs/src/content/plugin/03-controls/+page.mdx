---
title: 'controls'
tagline: 'Define which areas can initiate dragging'
---

import FrameworkSwitch from '$components/FrameworkSwitch.astro';

The `controls` plugin defines which parts of an element can be used to start dragging. Think modal headers, card handles, or toolbar grips - only specific areas should be draggable while the rest remains interactive.

```typescript
controls({ allow: ControlFrom.selector('.handle') }); // Only .handle can drag
controls({ block: ControlFrom.selector('.button') }); // Everything except .button
controls({ allow: handle, block: button }); // Allow handle, block button
```

## Basic Usage

<FrameworkSwitch>
<div slot="svelte">

```svelte
<script>
  import { controls, ControlFrom } from '@neodrag/svelte';
</script>

<!-- Only the header can drag the modal -->
<div
  {@attach draggable([
    controls({ allow: ControlFrom.selector('.modal-header') }),
  ])}
>
  <div class="modal-header">Drag handle</div>
  <div class="modal-content">
    <button>This button won't drag</button>
    <p>Neither will this text</p>
  </div>
</div>

<!-- Everything except buttons can drag -->
<div
  {@attach draggable([
    controls({ block: ControlFrom.selector('button') }),
  ])}
>
  <p>Drag here works</p>
  <button>But not here</button>
</div>
```

</div>

<div slot="react">

```tsx
import { useRef } from 'react';
import { controls, ControlFrom, useDraggable } from '@neodrag/react';

function ControlledDraggables() {
  const modalRef = useRef<HTMLDivElement>(null);
  const cardRef = useRef<HTMLDivElement>(null);

  useDraggable(modalRef, [
    controls({ allow: ControlFrom.selector('.modal-header') }),
  ]);

  useDraggable(cardRef, [
    controls({ block: ControlFrom.selector('button') }),
  ]);

  return (
    <div>
      <div ref={modalRef}>
        <div className="modal-header">Drag handle</div>
        <div className="modal-content">
          <button>This button won't drag</button>
          <p>Neither will this text</p>
        </div>
      </div>

      <div ref={cardRef}>
        <p>Drag here works</p>
        <button>But not here</button>
      </div>
    </div>
  );
}
```

</div>

<div slot="vue">

```vue
<script setup>
import { controls, ControlFrom, vDraggable } from '@neodrag/vue';

const modalPlugins = [
  controls({ allow: ControlFrom.selector('.modal-header') }),
];

const cardPlugins = [
  controls({ block: ControlFrom.selector('button') }),
];
</script>

<template>
  <div>
    <div v-draggable="modalPlugins">
      <div class="modal-header">Drag handle</div>
      <div class="modal-content">
        <button>This button won't drag</button>
        <p>Neither will this text</p>
      </div>
    </div>

    <div v-draggable="cardPlugins">
      <p>Drag here works</p>
      <button>But not here</button>
    </div>
  </div>
</template>
```

</div>

<div slot="solid">

```tsx
import { createSignal } from 'solid-js';
import { controls, ControlFrom, useDraggable } from '@neodrag/solid';

function ControlledDraggables() {
  const [modal, setModal] = createSignal<HTMLDivElement>();
  const [card, setCard] = createSignal<HTMLDivElement>();

  useDraggable(modal, [
    controls({ allow: ControlFrom.selector('.modal-header') }),
  ]);

  useDraggable(card, [
    controls({ block: ControlFrom.selector('button') }),
  ]);

  return (
    <div>
      <div ref={setModal}>
        <div class="modal-header">Drag handle</div>
        <div class="modal-content">
          <button>This button won't drag</button>
          <p>Neither will this text</p>
        </div>
      </div>

      <div ref={setCard}>
        <p>Drag here works</p>
        <button>But not here</button>
      </div>
    </div>
  );
}
```

</div>

<div slot="vanilla">

```typescript
import { controls, ControlFrom, Draggable } from '@neodrag/vanilla';

const modal = document.getElementById('modal');
const card = document.getElementById('card');

new Draggable(modal, [
  controls({ allow: ControlFrom.selector('.modal-header') }),
]);

new Draggable(card, [
  controls({ block: ControlFrom.selector('button') }),
]);
```

</div>
</FrameworkSwitch>

## ControlFrom Utilities

```typescript
// CSS selectors
ControlFrom.selector('.handle'); // All elements matching selector
ControlFrom.selector('button, input'); // Multiple selectors

// Specific elements
const handleElement = document.querySelector('.my-handle');
ControlFrom.elements([handleElement]);
ControlFrom.elements(document.querySelectorAll('.handles'));
```

## Priority with Overlapping Zones

When zones overlap, control which takes precedence:

```typescript
controls({
  allow: ControlFrom.selector('.card-header'),
  block: ControlFrom.selector('.card-header .close-button'),
  priority: 'block', // Block wins when zones overlap
});

// Default priority: 'allow' (allow zones win)
controls({
  allow: ControlFrom.selector('.toolbar'),
  block: ControlFrom.selector('.toolbar button'),
  // priority: 'allow' is default - toolbar dragging works except on buttons
});
```

## Dynamic Controls

Change control zones using compartments:

<FrameworkSwitch>
<div slot="svelte">

```svelte
<script>
  import {
    controls,
    ControlFrom,
    Compartment,
  } from '@neodrag/svelte';

  let editMode = $state(false);

  const controlsComp = Compartment.of(() =>
    controls({
      allow: editMode
        ? ControlFrom.selector('.edit-handle')
        : ControlFrom.selector('.view-handle'),
    }),
  );
</script>

<div {@attach draggable(() => [controlsComp])}>
  <div class="view-handle" class:hidden={editMode}>
    View Mode Handle
  </div>
  <div class="edit-handle" class:hidden={!editMode}>
    Edit Mode Handle
  </div>
  <div class="content">Content area</div>
</div>

<button onclick={() => (editMode = !editMode)}>
  Toggle {editMode ? 'View' : 'Edit'} Mode
</button>
```

</div>

<div slot="react">

```tsx
import { useState, useRef } from 'react';
import {
  controls,
  ControlFrom,
  useDraggable,
  useCompartment,
} from '@neodrag/react';

function DynamicControls() {
  const ref = useRef<HTMLDivElement>(null);
  const [editMode, setEditMode] = useState(false);

  const controlsComp = useCompartment(
    () =>
      controls({
        allow: editMode
          ? ControlFrom.selector('.edit-handle')
          : ControlFrom.selector('.view-handle'),
      }),
    [editMode],
  );

  useDraggable(ref, () => [controlsComp]);

  return (
    <div>
      <div ref={ref}>
        <div className={`view-handle ${editMode ? 'hidden' : ''}`}>
          View Mode Handle
        </div>
        <div className={`edit-handle ${!editMode ? 'hidden' : ''}`}>
          Edit Mode Handle
        </div>
        <div className="content">Content area</div>
      </div>

      <button onClick={() => setEditMode(!editMode)}>
        Toggle {editMode ? 'View' : 'Edit'} Mode
      </button>
    </div>
  );
}
```

</div>

<div slot="vue">

```vue
<script setup>
import { ref } from 'vue';
import {
  controls,
  ControlFrom,
  vDraggable,
  useCompartment,
} from '@neodrag/vue';

const editMode = ref(false);

const controlsComp = useCompartment(() =>
  controls({
    allow: editMode.value
      ? ControlFrom.selector('.edit-handle')
      : ControlFrom.selector('.view-handle'),
  }),
);

function toggleMode() {
  editMode.value = !editMode.value;
}
</script>

<template>
  <div>
    <div v-draggable="() => [controlsComp]">
      <div class="view-handle" :class="{ hidden: editMode }">
        View Mode Handle
      </div>
      <div class="edit-handle" :class="{ hidden: !editMode }">
        Edit Mode Handle
      </div>
      <div class="content">Content area</div>
    </div>

    <button @click="toggleMode">
      Toggle {{ editMode ? 'View' : 'Edit' }} Mode
    </button>
  </div>
</template>
```

</div>

<div slot="solid">

```tsx
import { createSignal } from 'solid-js';
import {
  controls,
  ControlFrom,
  useDraggable,
  createCompartment,
} from '@neodrag/solid';

function DynamicControls() {
  const [element, setElement] = createSignal<HTMLDivElement>();
  const [editMode, setEditMode] = createSignal(false);

  const controlsComp = createCompartment(() =>
    controls({
      allow: editMode()
        ? ControlFrom.selector('.edit-handle')
        : ControlFrom.selector('.view-handle'),
    }),
  );

  useDraggable(element, [controlsComp]);

  return (
    <div>
      <div ref={setElement}>
        <div class={`view-handle ${editMode() ? 'hidden' : ''}`}>
          View Mode Handle
        </div>
        <div class={`edit-handle ${!editMode() ? 'hidden' : ''}`}>
          Edit Mode Handle
        </div>
        <div class="content">Content area</div>
      </div>

      <button onClick={() => setEditMode(!editMode())}>
        Toggle {editMode() ? 'View' : 'Edit'} Mode
      </button>
    </div>
  );
}
```

</div>

<div slot="vanilla">

```typescript
import {
  controls,
  ControlFrom,
  Compartment,
  Draggable,
} from '@neodrag/vanilla';

let editMode = false;
const element = document.getElementById('element');

const controlsComp = new Compartment(() =>
  controls({
    allow: editMode
      ? ControlFrom.selector('.edit-handle')
      : ControlFrom.selector('.view-handle'),
  }),
);

new Draggable(element, () => [controlsComp]);

document.getElementById('toggle').addEventListener('click', () => {
  editMode = !editMode;
  controlsComp.current = controls({
    allow: editMode
      ? ControlFrom.selector('.edit-handle')
      : ControlFrom.selector('.view-handle'),
  });
});
```

</div>
</FrameworkSwitch>

## Combining with Other Plugins

```typescript
// Draggable modal with multiple constraints
const plugins = [
  controls({ allow: ControlFrom.selector('.modal-header') }),
  bounds(BoundsFrom.viewport({ top: 0 })),
  axis('both'), // Allow any direction
];

// Card with handle and grid snapping
const plugins = [
  controls({ allow: ControlFrom.selector('.drag-handle') }),
  grid([20, 20]),
  bounds(BoundsFrom.parent()),
];
```

## Common Use Cases

### Draggable Card with Handle

<FrameworkSwitch>
<div slot="svelte">

```svelte
<script>
  import { controls, ControlFrom } from '@neodrag/svelte';
</script>

<div
  {@attach draggable([
    controls({ allow: ControlFrom.selector('.drag-handle') }),
  ])}
  class="card"
>
  <div class="card-header">
    <span class="drag-handle">⋮⋮</span>
    <h3>Card Title</h3>
    <button class="close">×</button>
  </div>
  <div class="card-content">
    <p>Card content here...</p>
    <button>Action Button</button>
  </div>
</div>
```

</div>

<div slot="react">

```tsx
import { useRef } from 'react';
import { controls, ControlFrom, useDraggable } from '@neodrag/react';

function DraggableCard() {
  const ref = useRef<HTMLDivElement>(null);

  useDraggable(ref, [
    controls({ allow: ControlFrom.selector('.drag-handle') }),
  ]);

  return (
    <div ref={ref} className="card">
      <div className="card-header">
        <span className="drag-handle">⋮⋮</span>
        <h3>Card Title</h3>
        <button className="close">×</button>
      </div>
      <div className="card-content">
        <p>Card content here...</p>
        <button>Action Button</button>
      </div>
    </div>
  );
}
```

</div>

<div slot="vue">

```vue
<script setup>
import { controls, ControlFrom, vDraggable } from '@neodrag/vue';

const plugins = [
  controls({ allow: ControlFrom.selector('.drag-handle') }),
];
</script>

<template>
  <div v-draggable="plugins" class="card">
    <div class="card-header">
      <span class="drag-handle">⋮⋮</span>
      <h3>Card Title</h3>
      <button class="close">×</button>
    </div>
    <div class="card-content">
      <p>Card content here...</p>
      <button>Action Button</button>
    </div>
  </div>
</template>
```

</div>

<div slot="solid">

```tsx
import { createSignal } from 'solid-js';
import { controls, ControlFrom, useDraggable } from '@neodrag/solid';

function DraggableCard() {
  const [card, setCard] = createSignal<HTMLDivElement>();

  useDraggable(card, [
    controls({ allow: ControlFrom.selector('.drag-handle') }),
  ]);

  return (
    <div ref={setCard} class="card">
      <div class="card-header">
        <span class="drag-handle">⋮⋮</span>
        <h3>Card Title</h3>
        <button class="close">×</button>
      </div>
      <div class="card-content">
        <p>Card content here...</p>
        <button>Action Button</button>
      </div>
    </div>
  );
}
```

</div>

<div slot="vanilla">

```typescript
import { controls, ControlFrom, Draggable } from '@neodrag/vanilla';

const card = document.getElementById('card');

new Draggable(card, [
  controls({ allow: ControlFrom.selector('.drag-handle') }),
]);
```

</div>
</FrameworkSwitch>

### Modal Dialog

```typescript
// Modal that drags from header but not from interactive elements
controls({
  allow: ControlFrom.selector('.modal-header'),
  block: ControlFrom.selector('.modal-header button'),
});
```

### Complex UI with Multiple Zones

```typescript
// Allow toolbar and sidebar, block all buttons and inputs
controls({
  allow: ControlFrom.selector('.toolbar, .sidebar'),
  block: ControlFrom.selector('button, input, select, textarea'),
});
```

## Nested Control Zones

When control zones overlap, the most specific (smallest) zone takes precedence:

```typescript
controls({
  allow: ControlFrom.selector('.card'), // Entire card is draggable
  block: ControlFrom.selector('.card .content'), // Except content area
});

// If user clicks in content area, block wins (more specific)
// If user clicks in header area, allow wins
```

## How It Works

The controls plugin:

1. **Finds control zones** on setup by querying the DOM
2. **Checks click position** in `shouldStart` hook
3. **Determines permission** based on which zones contain the click point
4. **Returns boolean** to allow/prevent drag start

**Zone priority logic:**

- If `allow` zones exist and click is outside all of them → block
- If click is in both allow and block zones → use `priority` option
- Smaller (nested) zones take precedence over larger ones

## API Reference

```typescript
function controls(options?: {
  allow?: ReturnType<
    typeof ControlFrom.selector | typeof ControlFrom.elements
  >;
  block?: ReturnType<
    typeof ControlFrom.selector | typeof ControlFrom.elements
  >;
  priority?: 'allow' | 'block';
}): Plugin;
```

**Options:**

- `allow` - Control zones that can initiate dragging
- `block` - Control zones that cannot initiate dragging
- `priority` - Which wins when zones overlap ('allow' | 'block')

**ControlFrom utilities:**

- `ControlFrom.selector(cssSelector)` - Elements matching CSS selector
- `ControlFrom.elements(nodeList)` - Specific DOM elements

**Returns:** A plugin object for use with draggable.
