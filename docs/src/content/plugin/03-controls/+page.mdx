---
title: 'controls'
tagline: 'Define which areas can initiate dragging'
---

import FrameworkSwitch from '$components/FrameworkSwitch.astro';

## What it does

The `controls` plugin defines which parts of an element can be used to start dragging. Think modal headers, card handles, or toolbar grips - only specific areas should be draggable while the rest remains interactive.

```typescript
controls({ allow: ControlFrom.selector('.handle') }); // Only .handle can drag
controls({ block: ControlFrom.selector('.button') }); // Everything except .button
controls({ allow: handle, block: button }); // Allow handle, block button
```

## Basic Usage

<FrameworkSwitch>
<div slot="svelte">

```svelte
<script>
  import { controls, ControlFrom } from '@neodrag/svelte';
</script>

<!-- Only the header can drag the modal -->
<div
  {@attach draggable([
    controls({ allow: ControlFrom.selector('.modal-header') }),
  ])}
>
  <div class="modal-header">Drag handle</div>
  <div class="modal-content">
    <button>This button won't drag</button>
    <p>Neither will this text</p>
  </div>
</div>

<!-- Everything except buttons can drag -->
<div
  {@attach draggable([
    controls({ block: ControlFrom.selector('button') }),
  ])}
>
  <p>Drag here works</p>
  <button>But not here</button>
</div>
```

</div>

<div slot="react">

```tsx
import { useRef } from 'react';
import { controls, ControlFrom, useDraggable } from '@neodrag/react';

function ControlledDraggables() {
  const modalRef = useRef<HTMLDivElement>(null);
  const cardRef = useRef<HTMLDivElement>(null);

  useDraggable(modalRef, [
    controls({ allow: ControlFrom.selector('.modal-header') }),
  ]);

  useDraggable(cardRef, [
    controls({ block: ControlFrom.selector('button') }),
  ]);

  return (
    <div>
      <div ref={modalRef}>
        <div className="modal-header">Drag handle</div>
        <div className="modal-content">
          <button>This button won't drag</button>
          <p>Neither will this text</p>
        </div>
      </div>

      <div ref={cardRef}>
        <p>Drag here works</p>
        <button>But not here</button>
      </div>
    </div>
  );
}
```

</div>

<div slot="vue">

```vue
<script setup>
import { controls, ControlFrom, vDraggable } from '@neodrag/vue';

const modalPlugins = [
  controls({ allow: ControlFrom.selector('.modal-header') }),
];

const cardPlugins = [
  controls({ block: ControlFrom.selector('button') }),
];
</script>

<template>
  <div>
    <div v-draggable="modalPlugins">
      <div class="modal-header">Drag handle</div>
      <div class="modal-content">
        <button>This button won't drag</button>
        <p>Neither will this text</p>
      </div>
    </div>

    <div v-draggable="cardPlugins">
      <p>Drag here works</p>
      <button>But not here</button>
    </div>
  </div>
</template>
```

</div>

<div slot="solid">

```tsx
import { createSignal } from 'solid-js';
import { controls, ControlFrom, useDraggable } from '@neodrag/solid';

function ControlledDraggables() {
  const [modal, setModal] = createSignal<HTMLDivElement>();
  const [card, setCard] = createSignal<HTMLDivElement>();

  useDraggable(modal, [
    controls({ allow: ControlFrom.selector('.modal-header') }),
  ]);

  useDraggable(card, [
    controls({ block: ControlFrom.selector('button') }),
  ]);

  return (
    <div>
      <div ref={setModal}>
        <div class="modal-header">Drag handle</div>
        <div class="modal-content">
          <button>This button won't drag</button>
          <p>Neither will this text</p>
        </div>
      </div>

      <div ref={setCard}>
        <p>Drag here works</p>
        <button>But not here</button>
      </div>
    </div>
  );
}
```

</div>

<div slot="vanilla">

```typescript
import { controls, ControlFrom, Draggable } from '@neodrag/vanilla';

const modal = document.getElementById('modal');
const card = document.getElementById('card');

new Draggable(modal, [
  controls({ allow: ControlFrom.selector('.modal-header') }),
]);

new Draggable(card, [
  controls({ block: ControlFrom.selector('button') }),
]);
```

</div>
</FrameworkSwitch>

## ControlFrom Utility

The `ControlFrom` utility helps you define control zones:

### By Selector

```typescript
// Only elements matching selector can drag
ControlFrom.selector('.drag-handle');
ControlFrom.selector('[data-draggable]');
ControlFrom.selector('.header, .toolbar');
```

### By Elements

```typescript
// Specific DOM elements
const handle = document.querySelector('.handle');
ControlFrom.elements([handle]);

// Multiple elements
const handles = document.querySelectorAll('.handle');
ControlFrom.elements(handles);
```

## Control Options

### Allow Only

When you specify `allow` zones, only those areas can initiate dragging:

```typescript
controls({
  allow: ControlFrom.selector('.drag-handle'),
});
// Only .drag-handle can start dragging
```

### Block Areas

When you specify `block` zones, those areas cannot initiate dragging:

```typescript
controls({
  block: ControlFrom.selector('button, input, a'),
});
// Everything except buttons, inputs, and links can drag
```

### Combined Allow and Block

Use both to create complex control patterns:

```typescript
controls({
  allow: ControlFrom.selector('.card-header'),
  block: ControlFrom.selector('.card-header .close-button'),
});
// Header can drag, except the close button
```

### Priority

When zones overlap, priority determines which takes precedence:

```typescript
controls({
  allow: ControlFrom.selector('.container'),
  block: ControlFrom.selector('.no-drag'),
  priority: 'block', // Block zones win when overlapping
});
```

## Dynamic Controls

Update control zones using compartments:

<FrameworkSwitch>
<div slot="svelte">

```svelte
<script>
  import {
    controls,
    ControlFrom,
    Compartment,
  } from '@neodrag/svelte';

  let mode = $state('header-only');

  const controlsComp = Compartment.of(() => {
    switch (mode) {
      case 'header-only':
        return controls({ allow: ControlFrom.selector('.header') });
      case 'no-buttons':
        return controls({ block: ControlFrom.selector('button') });
      case 'free':
        return controls({ allow: ControlFrom.selector('*') });
      default:
        return controls({});
    }
  });
</script>

<div {@attach draggable(() => [controlsComp])}>
  <div class="header">Header (mode: {mode})</div>
  <div class="content">
    <p>Some content</p>
    <button>A button</button>
  </div>
</div>

<select bind:value={mode}>
  <option value="header-only">Header Only</option>
  <option value="no-buttons">No Buttons</option>
  <option value="free">Free Drag</option>
</select>
```

</div>

<div slot="react">

```tsx
import { useRef, useState } from 'react';
import {
  controls,
  ControlFrom,
  useDraggable,
  useCompartment,
} from '@neodrag/react';

function DynamicControls() {
  const elementRef = useRef<HTMLDivElement>(null);
  const [mode, setMode] = useState('header-only');

  const controlsComp = useCompartment(() => {
    switch (mode) {
      case 'header-only':
        return controls({ allow: ControlFrom.selector('.header') });
      case 'no-buttons':
        return controls({ block: ControlFrom.selector('button') });
      case 'free':
        return controls({ allow: ControlFrom.selector('*') });
      default:
        return controls({});
    }
  }, [mode]);

  useDraggable(elementRef, () => [controlsComp]);

  return (
    <div>
      <div ref={elementRef}>
        <div className="header">Header (mode: {mode})</div>
        <div className="content">
          <p>Some content</p>
          <button>A button</button>
        </div>
      </div>

      <select value={mode} onChange={(e) => setMode(e.target.value)}>
        <option value="header-only">Header Only</option>
        <option value="no-buttons">No Buttons</option>
        <option value="free">Free Drag</option>
      </select>
    </div>
  );
}
```

</div>

<div slot="vue">

```vue
<script setup>
import { ref } from 'vue';
import {
  controls,
  ControlFrom,
  vDraggable,
  useCompartment,
} from '@neodrag/vue';

const mode = ref('header-only');

const controlsComp = useCompartment(() => {
  switch (mode.value) {
    case 'header-only':
      return controls({ allow: ControlFrom.selector('.header') });
    case 'no-buttons':
      return controls({ block: ControlFrom.selector('button') });
    case 'free':
      return controls({ allow: ControlFrom.selector('*') });
    default:
      return controls({});
  }
});

const plugins = () => [controlsComp];
</script>

<template>
  <div>
    <div v-draggable="plugins">
      <div class="header">Header (mode: {{ mode }})</div>
      <div class="content">
        <p>Some content</p>
        <button>A button</button>
      </div>
    </div>

    <select v-model="mode">
      <option value="header-only">Header Only</option>
      <option value="no-buttons">No Buttons</option>
      <option value="free">Free Drag</option>
    </select>
  </div>
</template>
```

</div>

<div slot="solid">

```tsx
import { createSignal } from 'solid-js';
import {
  controls,
  ControlFrom,
  useDraggable,
  createCompartment,
} from '@neodrag/solid';

function DynamicControls() {
  const [element, setElement] = createSignal<HTMLDivElement>();
  const [mode, setMode] = createSignal('header-only');

  const controlsComp = createCompartment(() => {
    switch (mode()) {
      case 'header-only':
        return controls({ allow: ControlFrom.selector('.header') });
      case 'no-buttons':
        return controls({ block: ControlFrom.selector('button') });
      case 'free':
        return controls({ allow: ControlFrom.selector('*') });
      default:
        return controls({});
    }
  });

  useDraggable(element, [controlsComp]);

  return (
    <div>
      <div ref={setElement}>
        <div class="header">Header (mode: {mode()})</div>
        <div class="content">
          <p>Some content</p>
          <button>A button</button>
        </div>
      </div>

      <select
        value={mode()}
        onChange={(e) => setMode(e.target.value)}
      >
        <option value="header-only">Header Only</option>
        <option value="no-buttons">No Buttons</option>
        <option value="free">Free Drag</option>
      </select>
    </div>
  );
}
```

</div>

<div slot="vanilla">

```typescript
import {
  controls,
  ControlFrom,
  Compartment,
  Draggable,
} from '@neodrag/vanilla';

const element = document.getElementById('element');
const select = document.getElementById('mode-select');

let mode = 'header-only';

const controlsComp = new Compartment(() => {
  switch (mode) {
    case 'header-only':
      return controls({ allow: ControlFrom.selector('.header') });
    case 'no-buttons':
      return controls({ block: ControlFrom.selector('button') });
    case 'free':
      return controls({ allow: ControlFrom.selector('*') });
    default:
      return controls({});
  }
});

new Draggable(element, () => [controlsComp]);

select.addEventListener('change', (e) => {
  mode = e.target.value;
  controlsComp.current = controlsComp.current; // Trigger update
});
```

</div>
</FrameworkSwitch>

## Common Use Cases

### Draggable Card with Handle

<FrameworkSwitch>
<div slot="svelte">

```svelte
<script>
  import { controls, ControlFrom } from '@neodrag/svelte';
</script>

<div
  class="card"
  {@attach draggable([
    controls({ allow: ControlFrom.selector('.drag-handle') }),
  ])}
>
  <div class="card-header">
    <span class="drag-handle">⋮⋮</span>
    <h3>Card Title</h3>
    <button class="close">×</button>
  </div>
  <div class="card-content">
    <p>Card content here...</p>
    <button>Action Button</button>
  </div>
</div>

<style>
  .card {
    width: 300px;
    border: 1px solid #ddd;
    border-radius: 8px;
    background: white;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }

  .card-header {
    display: flex;
    align-items: center;
    padding: 16px;
    border-bottom: 1px solid #eee;
  }

  .drag-handle {
    cursor: grab;
    padding: 4px;
    margin-right: 8px;
    color: #666;
    user-select: none;
  }

  .drag-handle:hover {
    background: #f0f0f0;
    border-radius: 4px;
  }

  .close {
    margin-left: auto;
    background: none;
    border: none;
    font-size: 18px;
    cursor: pointer;
  }

  .card-content {
    padding: 16px;
  }
</style>
```

</div>

<div slot="react">

```tsx
import { useRef } from 'react';
import { controls, ControlFrom, useDraggable } from '@neodrag/react';

function DraggableCard() {
  const cardRef = useRef<HTMLDivElement>(null);

  useDraggable(cardRef, [
    controls({ allow: ControlFrom.selector('.drag-handle') }),
  ]);

  return (
    <div ref={cardRef} className="card">
      <div className="card-header">
        <span className="drag-handle">⋮⋮</span>
        <h3>Card Title</h3>
        <button className="close">×</button>
      </div>
      <div className="card-content">
        <p>Card content here...</p>
        <button>Action Button</button>
      </div>
    </div>
  );
}
```

</div>

<div slot="vue">

```vue
<script setup>
import { controls, ControlFrom, vDraggable } from '@neodrag/vue';

const plugins = [
  controls({ allow: ControlFrom.selector('.drag-handle') }),
];
</script>

<template>
  <div v-draggable="plugins" class="card">
    <div class="card-header">
      <span class="drag-handle">⋮⋮</span>
      <h3>Card Title</h3>
      <button class="close">×</button>
    </div>
    <div class="card-content">
      <p>Card content here...</p>
      <button>Action Button</button>
    </div>
  </div>
</template>
```

</div>

<div slot="solid">

```tsx
import { createSignal } from 'solid-js';
import { controls, ControlFrom, useDraggable } from '@neodrag/solid';

function DraggableCard() {
  const [card, setCard] = createSignal<HTMLDivElement>();

  useDraggable(card, [
    controls({ allow: ControlFrom.selector('.drag-handle') }),
  ]);

  return (
    <div ref={setCard} class="card">
      <div class="card-header">
        <span class="drag-handle">⋮⋮</span>
        <h3>Card Title</h3>
        <button class="close">×</button>
      </div>
      <div class="card-content">
        <p>Card content here...</p>
        <button>Action Button</button>
      </div>
    </div>
  );
}
```

</div>

<div slot="vanilla">

```typescript
import { controls, ControlFrom, Draggable } from '@neodrag/vanilla';

const card = document.getElementById('card');

new Draggable(card, [
  controls({ allow: ControlFrom.selector('.drag-handle') }),
]);
```

</div>
</FrameworkSwitch>

### Modal Dialog

```typescript
// Modal that drags from header but not from interactive elements
controls({
  allow: ControlFrom.selector('.modal-header'),
  block: ControlFrom.selector('.modal-header button'),
});
```

### Complex UI with Multiple Zones

```typescript
// Allow toolbar and sidebar, block all buttons and inputs
controls({
  allow: ControlFrom.selector('.toolbar, .sidebar'),
  block: ControlFrom.selector('button, input, select, textarea'),
});
```

## Nested Control Zones

When control zones overlap, the most specific (smallest) zone takes precedence:

```typescript
controls({
  allow: ControlFrom.selector('.card'), // Entire card is draggable
  block: ControlFrom.selector('.card .content'), // Except content area
});

// If user clicks in content area, block wins (more specific)
// If user clicks in header area, allow wins
```

## How It Works

The controls plugin:

1. **Finds control zones** on setup by querying the DOM
2. **Checks click position** in `shouldStart` hook
3. **Determines permission** based on which zones contain the click point
4. **Returns boolean** to allow/prevent drag start

**Zone priority logic:**

- If `allow` zones exist and click is outside all of them → block
- If click is in both allow and block zones → use `priority` option
- Smaller (nested) zones take precedence over larger ones

## API Reference

```typescript
function controls(options?: {
  allow?: ReturnType<
    typeof ControlFrom.selector | typeof ControlFrom.elements
  >;
  block?: ReturnType<
    typeof ControlFrom.selector | typeof ControlFrom.elements
  >;
  priority?: 'allow' | 'block';
}): Plugin;
```

**Options:**

- `allow` - Control zones that can initiate dragging
- `block` - Control zones that cannot initiate dragging
- `priority` - Which wins when zones overlap ('allow' | 'block')

**ControlFrom utilities:**

- `ControlFrom.selector(cssSelector)` - Elements matching CSS selector
- `ControlFrom.elements(nodeList)` - Specific DOM elements

**Returns:** A plugin object for use with draggable.
