---
title: 'position'
tagline: 'Control element position programmatically'
---

import FrameworkSwitch from '$components/FrameworkSwitch.astro';

The `position` plugin controls where draggable elements are positioned. Set initial positions, move elements programmatically, or create two-way binding between app state and element position.

```typescript
position({ current: { x: 100, y: 50 } }); // Force to position
position({ default: { x: 0, y: 0 } }); // Set initial position
```

## Basic Usage

<FrameworkSwitch>
<div slot="svelte">

```svelte
<script>
  import { position } from '@neodrag/svelte';

  let currentPos = { x: 100, y: 50 };
  let defaultPos = { x: 0, y: 0 };
</script>

<!-- Force element to specific position -->
<div {@attach draggable([position({ current: currentPos })])}>
  Controlled position
</div>

<!-- Set initial position only -->
<div {@attach draggable([position({ default: defaultPos })])}>
  Initial position, then user controls
</div>
```

</div>

<div slot="react">

```tsx
import { useRef, useState } from 'react';
import { position, useDraggable } from '@neodrag/react';

function PositionExample() {
  const controlledRef = useRef<HTMLDivElement>(null);
  const initialRef = useRef<HTMLDivElement>(null);

  const [currentPos, setCurrentPos] = useState({ x: 100, y: 50 });

  useDraggable(controlledRef, [position({ current: currentPos })]);
  useDraggable(initialRef, [position({ default: { x: 0, y: 0 } })]);

  return (
    <div>
      <div ref={controlledRef}>Controlled position</div>
      <div ref={initialRef}>Initial position, then user controls</div>
      <button onClick={() => setCurrentPos({ x: 200, y: 100 })}>
        Move to (200, 100)
      </button>
    </div>
  );
}
```

</div>

<div slot="vue">

```vue
<script setup>
import { ref } from 'vue';
import { position, vDraggable } from '@neodrag/vue';

const currentPos = ref({ x: 100, y: 50 });
const defaultPos = ref({ x: 0, y: 0 });

function moveElement() {
  currentPos.value = { x: 200, y: 100 };
}
</script>

<template>
  <div v-draggable="[position({ current: currentPos })]">
    Controlled position
  </div>

  <div v-draggable="[position({ default: defaultPos })]">
    Initial position, then user controls
  </div>

  <button @click="moveElement">Move to (200, 100)</button>
</template>
```

</div>

<div slot="solid">

```tsx
import { createSignal } from 'solid-js';
import { position, useDraggable } from '@neodrag/solid';

function PositionExample() {
  const [controlledRef, setControlledRef] =
    createSignal<HTMLElement | null>(null);
  const [initialRef, setInitialRef] =
    createSignal<HTMLElement | null>(null);
  const [currentPos, setCurrentPos] = createSignal({ x: 100, y: 50 });

  useDraggable(controlledRef, [position({ current: currentPos() })]);
  useDraggable(initialRef, [position({ default: { x: 0, y: 0 } })]);

  return (
    <div>
      <div ref={setControlledRef}>Controlled position</div>
      <div ref={setInitialRef}>
        Initial position, then user controls
      </div>
      <button onClick={() => setCurrentPos({ x: 200, y: 100 })}>
        Move to (200, 100)
      </button>
    </div>
  );
}
```

</div>

<div slot="vanilla">

```typescript
import { draggable, position } from '@neodrag/vanilla';

const element = document.querySelector('#draggable');
let currentPos = { x: 100, y: 50 };

// Controlled position
const controlled = draggable(element, [
  position({ current: currentPos }),
]);

// Move programmatically
function moveElement() {
  currentPos = { x: 200, y: 100 };
  controlled.update([position({ current: currentPos })]);
}

// Initial position only
const initial = draggable(element, [
  position({ default: { x: 0, y: 0 } }),
]);
```

</div>
</FrameworkSwitch>

## Two-Way Binding

<FrameworkSwitch>
<div slot="svelte">

```svelte
<script>
  import { position, events } from '@neodrag/svelte';

  let elementPosition = { x: 50, y: 50 };

  // Save position to localStorage
  function savePosition(pos) {
    localStorage.setItem('elementPosition', JSON.stringify(pos));
  }
</script>

<div
  {@attach draggable([
    position({ current: elementPosition }),
    events({
      onDrag: (data) => {
        elementPosition = data.offset;
        savePosition(elementPosition);
      },
    }),
  ])}
>
  Position synced with state
</div>

<p>Current position: {elementPosition.x}, {elementPosition.y}</p>
```

</div>

<div slot="react">

```tsx
import { useState, useRef } from 'react';
import { position, events, useDraggable } from '@neodrag/react';

function SyncedPosition() {
  const ref = useRef<HTMLDivElement>(null);
  const [elementPosition, setElementPosition] = useState({
    x: 50,
    y: 50,
  });

  useDraggable(ref, [
    position({ current: elementPosition }),
    events({
      onDrag: (data) => {
        setElementPosition(data.offset);
        localStorage.setItem(
          'elementPosition',
          JSON.stringify(data.offset),
        );
      },
    }),
  ]);

  return (
    <div>
      <div ref={ref}>Position synced with state</div>
      <p>
        Current position: {elementPosition.x}, {elementPosition.y}
      </p>
    </div>
  );
}
```

</div>

<div slot="vue">

```vue
<script setup>
import { ref } from 'vue';
import { position, events, vDraggable } from '@neodrag/vue';

const elementPosition = ref({ x: 50, y: 50 });

function updatePosition(data) {
  elementPosition.value = data.offset;
  localStorage.setItem(
    'elementPosition',
    JSON.stringify(data.offset),
  );
}
</script>

<template>
  <div
    v-draggable="[
      position({ current: elementPosition }),
      events({ onDrag: updatePosition }),
    ]"
  >
    Position synced with state
  </div>

  <p>
    Current position: {{ elementPosition.x }}, {{ elementPosition.y }}
  </p>
</template>
```

</div>

<div slot="solid">

```tsx
import { createSignal } from 'solid-js';
import { position, events, useDraggable } from '@neodrag/solid';

function SyncedPosition() {
  const [divRef, setDivRef] = createSignal<HTMLElement | null>(null);
  const [elementPosition, setElementPosition] = createSignal({
    x: 50,
    y: 50,
  });

  useDraggable(divRef, () => [
    position({ current: elementPosition() }),
    events({
      onDrag: (data) => {
        setElementPosition(data.offset);
        localStorage.setItem(
          'elementPosition',
          JSON.stringify(data.offset),
        );
      },
    }),
  ]);

  return (
    <div>
      <div ref={setDivRef}>Position synced with state</div>
      <p>
        Current position: {elementPosition().x}, {elementPosition().y}
      </p>
    </div>
  );
}
```

</div>

<div slot="vanilla">

```typescript
import { draggable, position, events } from '@neodrag/vanilla';

let elementPosition = { x: 50, y: 50 };

const instance = draggable(element, [
  position({ current: elementPosition }),
  events({
    onDrag: (data) => {
      elementPosition = data.offset;
      localStorage.setItem(
        'elementPosition',
        JSON.stringify(data.offset),
      );
      updateDisplay();
    },
  }),
]);

function updateDisplay() {
  document.querySelector('#position-display').textContent =
    `Current position: ${elementPosition.x}, ${elementPosition.y}`;
}
```

</div>
</FrameworkSwitch>

## Common Use Cases

### Animated Positioning

```typescript
function animateToPosition(targetX, targetY, duration = 500) {
  const startPos = getCurrentPosition();
  const startTime = Date.now();

  function animate() {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const ease = 1 - Math.pow(1 - progress, 3); // Ease out cubic

    const currentX = startPos.x + (targetX - startPos.x) * ease;
    const currentY = startPos.y + (targetY - startPos.y) * ease;

    positionComp.current = position({
      current: { x: currentX, y: currentY },
    });

    if (progress < 1) {
      requestAnimationFrame(animate);
    }
  }

  animate();
}
```

### Multi-Element Coordination

```typescript
const formation = [
  { id: 'leader', offset: { x: 0, y: 0 } },
  { id: 'follower1', offset: { x: 50, y: 0 } },
  { id: 'follower2', offset: { x: 25, y: 50 } },
];

events({
  onDrag: (data) => {
    if (data.rootNode.id === 'leader') {
      formation.forEach((item) => {
        if (item.id !== 'leader') {
          const followerPos = {
            x: data.offset.x + item.offset.x,
            y: data.offset.y + item.offset.y,
          };
          updateElementPosition(item.id, followerPos);
        }
      });
    }
  },
});
```

### Snap to Targets

```typescript
const targets = [
  { x: 100, y: 100 },
  { x: 200, y: 150 },
  { x: 300, y: 50 },
];

events({
  onDragEnd: (data) => {
    const snapDistance = 20;
    const nearest = targets.find((target) => {
      const distance = Math.sqrt(
        Math.pow(data.offset.x - target.x, 2) +
          Math.pow(data.offset.y - target.y, 2),
      );
      return distance <= snapDistance;
    });

    if (nearest) {
      positionComp.current = position({ current: nearest });
    }
  },
});
```

## Combining with Other Plugins

```typescript
// Position runs first, then other plugins modify
const plugins = [
  position({ current: { x: 100, y: 50 } }), // High priority - runs first
  grid([20, 20]), // Then grid snapping
  bounds(BoundsFrom.parent()), // Finally bounds checking
];
```

Position plugin has high priority (1000) ensuring it sets the base position before other plugins modify movement.

## How It Works

The position plugin:

1. **Runs in setup** when not currently interacting
2. **Uses `setForcedPosition()`** to immediately jump to coordinates
3. **Checks for changes** - only updates if position actually changed
4. **High priority** - runs before other position-modifying plugins
5. **Live updates** - can change position during active drags

```typescript
setup(ctx) {
  if (!ctx.isInteracting) {
    const x = options?.current?.x ?? options?.default?.x ?? ctx.offset.x;
    const y = options?.current?.y ?? options?.default?.y ?? ctx.offset.y;

    if (x !== ctx.offset.x || y !== ctx.offset.y) {
      ctx.setForcedPosition(x, y);
    }
  }
}
```

## API Reference

```typescript
function position(
  options?: {
    current?: { x: number; y: number } | null;
    default?: { x: number; y: number } | null;
  } | null,
): Plugin;
```

**Options:**

- `current` - Force element to this position (overrides dragging)
- `default` - Set initial position (user can still drag normally)

**Behavior:**

- `current` takes precedence over `default`
- Only updates if position actually changed
- Runs with high priority (1000)
- Supports live updates during dragging

**Returns:** A plugin object for use with draggable.
